"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRywrQkFBK0I7QUFDbEMsR0FBRyw0QkFBNEI7QUFDL0IsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyx1QkFBdUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTEVOT1ZPXFxEb2N1bWVudHNcXGdpdGh1YlxcemlrcmlhbmJpYS5naXRodWIuaW9cXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcY2pzXFxyZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKChleHBvcnRzLkNvbmN1cnJlbnRSb290ID0gMSksXG4gIChleHBvcnRzLkNvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gOCksXG4gIChleHBvcnRzLkRlZmF1bHRFdmVudFByaW9yaXR5ID0gMzIpLFxuICAoZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSAyKSxcbiAgKGV4cG9ydHMuSWRsZUV2ZW50UHJpb3JpdHkgPSAyNjg0MzU0NTYpLFxuICAoZXhwb3J0cy5MZWdhY3lSb290ID0gMCksXG4gIChleHBvcnRzLk5vRXZlbnRQcmlvcml0eSA9IDApKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPassiveEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;\n            case 11:\n                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;\n            case 1:\n                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        return null === current ? \"\" : getStackByFiberInDevAndProd(current);\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n        try {\n            return callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            current = previousFiber;\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 64) return \"TransitionHydration\";\n        if (lane & 4194176) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194176;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;\n        root = 0 !== root.finishedLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 64:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function onCommitRoot$1(root, eventPriority) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n            var didError = 128 === (root.current.flags & 128);\n            switch(eventPriority){\n                case 2:\n                    var schedulerPriority = ImmediatePriority;\n                    break;\n                case 8:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                case 32:\n                    schedulerPriority = NormalPriority$1;\n                    break;\n                case 268435456:\n                    schedulerPriority = IdlePriority;\n                    break;\n                default:\n                    schedulerPriority = NormalPriority$1;\n            }\n            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 3:\n            case 27:\n                rootOrSingletonContext = !0;\n                return;\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var shouldClear = !1;\n        supportsSingletons ? 3 !== fiber.tag && 27 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0) : 3 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0);\n        if (shouldClear && nextHydratableInstance) {\n            for(shouldClear = nextHydratableInstance; shouldClear;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(shouldClear);\n                diffNode.serverTail.push(description);\n                shouldClear = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratableSibling(shouldClear);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === fiber.tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diffRoot));\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [\n            update\n        ] : sourceFiber.push(update), update.lane = lane | 536870912);\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPassiveEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateTask(cb) {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            cb();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();\n        }) : scheduleCallback$3(ImmediatePriority, cb);\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 33554434;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber$1 = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber$1.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber$1;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber$1.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {\n            destroy: void 0\n        }, null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {\n                destroy: void 0\n            }, null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber$1.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            ReactSharedInternals.T._updatedFibers = new Set();\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber$1;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        currentStateHook = \"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;\n        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;\n        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {\n            destroy: void 0\n        }, null));\n        return [\n            currentStateHook,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushEffect(tag, create, inst, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            inst: inst,\n            deps: deps,\n            next: null\n        };\n        create = currentlyRenderingFiber$1.updateQueue;\n        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);\n        inst = create.lastEffect;\n        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {\n            destroy: void 0\n        }, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (currentlyRenderingFiber$1.mode & 64) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        currentTransition._updatedFibers = new Set();\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \":\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \":\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \":\" + identifierPrefix + \"r\" + treeId.toString(32) + \":\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);\n        action = {\n            lane: JSCompiler_OptimizeArgumentsArray_p0,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);\n    }\n    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194176)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;\n        markRef(current, workInProgress);\n        if (\"hidden\" === nextProps.mode || nextIsDetached) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = nextIsDetached & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864);\n            _instance = !0;\n        } else if (null === current$jscomp$0) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current$jscomp$0, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current$jscomp$0, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;\n            isRendering = !1;\n            current = workInProgress;\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & 8) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current$jscomp$0 = workInProgress.child;\n        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current$jscomp$0;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;\n                    (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                        dehydrated: JSCompiler_temp$jscomp$0,\n                        treeContext: null !== treeContextProvider ? {\n                            id: treeContextId,\n                            overflow: treeContextOverflow\n                        } : null,\n                        retryLane: 536870912\n                    }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress, workInProgress.child = didSuspend, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);\n                    JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress, nextInstance), throwOnHydrationMismatch(workInProgress));\n                }\n                nextInstance = workInProgress.memoizedState;\n                if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            nextInstance = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextInstance\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n        }\n        JSCompiler_temp$jscomp$0 = current.memoizedState;\n        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(nextInstance)) nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), showFallback.stack = nextProps || \"\", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {\n                value: showFallback,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp) {\n                    nextProps = renderLanes & -renderLanes;\n                    if (0 !== (nextProps & 42)) nextProps = 1;\n                    else switch(nextProps){\n                        case 2:\n                            nextProps = 1;\n                            break;\n                        case 8:\n                            nextProps = 4;\n                            break;\n                        case 32:\n                            nextProps = 16;\n                            break;\n                        case 128:\n                        case 256:\n                        case 512:\n                        case 1024:\n                        case 2048:\n                        case 4096:\n                        case 8192:\n                        case 16384:\n                        case 32768:\n                        case 65536:\n                        case 131072:\n                        case 262144:\n                        case 524288:\n                        case 1048576:\n                        case 2097152:\n                        case 4194304:\n                        case 8388608:\n                        case 16777216:\n                        case 33554432:\n                            nextProps = 64;\n                            break;\n                        case 268435456:\n                            nextProps = 134217728;\n                            break;\n                        default:\n                            nextProps = 0;\n                    }\n                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;\n                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                }\n                isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextInstance) ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), registerSuspenseInstanceRetry(nextInstance, workInProgress), workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {\n            parent: didSuspend,\n            pool: didSuspend\n        } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChild(prevSibling)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$1(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) instance = node.child, null !== instance && (instance.return = node), appendAllChildrenToContainer(containerChildSet, node, !(null !== node.memoizedProps && \"manual\" === node.memoizedProps.mode), !0);\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current ? appendAllChildren(_oldProps, workInProgress, !1, !1) : markUpdate(workInProgress));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {\n        if (maySuspendCommit(type, props)) {\n            if (workInProgress.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    renderLanes = workInProgress.type;\n                    var nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, renderLanes, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    nextResource = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, nextResource, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                renderLanes = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, renderLanes, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (nextResource = requiredContext(rootInstanceStackCursor.current), nextResource = createInstance(renderLanes, newProps, nextResource, current, workInProgress), appendAllChildren(nextResource, workInProgress, !1, !1), workInProgress.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes, newProps, current) && markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress), markUpdate(workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        nextResource = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        var returnFiber = hydrationParentFiber;\n                        if (null !== returnFiber) switch(returnFiber.tag){\n                            case 3:\n                                nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress);\n                    } else workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        nextResource = !1;\n                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), nextResource = !0;\n                    if (!nextResource) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                nextResource = workInProgress.memoizedState;\n                if (null === nextResource) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                returnFiber = nextResource.rendering;\n                if (null === returnFiber) if (newProps) cutOffTailIfNeeded(nextResource, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        returnFiber = findFirstSuspended(current);\n                        if (null !== returnFiber) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(nextResource, !1);\n                            current = returnFiber.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && \"hidden\" === nextResource.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                    nextResource.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = nextResource.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, nextResource.last = returnFiber);\n                }\n                if (null !== nextResource.tail) return current = nextResource.tail, nextResource.rendering = current, nextResource.tail = current.sibling, nextResource.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            var instance = finishedWork.stateNode;\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    instance = getPublicInstance(instance);\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instance);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instance);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instance;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && (supportsSingletons ? 27 !== fiber.tag : 1) && 18 !== fiber.tag;){\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        if (supportsMutation && (!supportsSingletons || 27 !== finishedWork.tag)) {\n            a: {\n                for(var parent = finishedWork.return; null !== parent;){\n                    if (isHostParent(parent)) {\n                        var parentFiber = parent;\n                        break a;\n                    }\n                    parent = parent.return;\n                }\n                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            switch(parentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        parent = parentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                        break;\n                    }\n                case 5:\n                    parent = parentFiber.stateNode;\n                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                    break;\n                case 3:\n                case 4:\n                    parent = parentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n        root = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = !1;\n        return root;\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 26:\n                if (supportsResources) {\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                    break;\n                }\n            case 27:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!prevProps) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = prevProps;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                flags & 512 && (\"manual\" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    hostParent = deletedFiber.stateNode;\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    releaseSingletonInstance(deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function commitMutationEffects(root, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitMutationEffectsOnFiber(finishedWork, root);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons && flags & 4 && null === finishedWork.alternate) {\n                    hoistableRoot = finishedWork.stateNode;\n                    var props = finishedWork.memoizedProps;\n                    try {\n                        clearSingleton(hoistableRoot), runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, hoistableRoot, finishedWork);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                }\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                supportsResources ? (prepareToCommitHoistables(), props = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = props) : recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                root = finishedWork.stateNode;\n                root._current = finishedWork;\n                root._visibility &= -3;\n                root._visibility |= root._pendingVisibility & 2;\n                if (flags & 8192 && (root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || wasHidden || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation && (null === finishedWork.memoizedProps || \"manual\" !== finishedWork.memoizedProps.mode))) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag || supportsSingletons && 27 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    props = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, props) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function commitLayoutEffects(finishedWork, root, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    prevEffectDuration = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);\n                break;\n            case 3:\n            case 4:\n                if (supportsResources) {\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                    recursivelyAccumulateSuspenseyCommit(fiber);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevEffectDuration._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & 4 && (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber;\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                var sibling = current.sibling, returnFiber = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== sibling) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    break a;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);\n            else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && queueRecoverableErrors(exitStatus);\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194176) === lanes) {\n                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                                break a;\n                            }\n                            break;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    shouldTimeSlice.finishedWork = forceSync;\n                    shouldTimeSlice.finishedLanes = lanes;\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, -0, 0);\n                    else {\n                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, -0, 0), exitStatus);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, -0, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function queueRecoverableErrors(errors) {\n        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var subtreeFlags = finishedWork.subtreeFlags;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {\n                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber$1 = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootDidNotComplete;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootDidNotComplete;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrent() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n    }\n    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(2), ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n        } finally{\n            ReactSharedInternals.T = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n    }\n    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        do flushPassiveEffects();\n        while (null !== rootWithPendingPassiveEffects);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var finishedWork = root.finishedWork;\n        didIncludeRenderPhaseUpdate = root.finishedLanes;\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);\n        if (null === finishedWork) return markCommitStopped(), null;\n        0 === didIncludeRenderPhaseUpdate && console.error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n        root.callbackNode = null;\n        root.callbackPriority = 0;\n        root.cancelPendingCommit = null;\n        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n        remainingLanes |= concurrentlyUpdatedLanes;\n        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);\n        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback(NormalPriority$1, function() {\n            flushPassiveEffects(!0);\n            return null;\n        }));\n        commitStartTime = now();\n        transitions = 0 !== (finishedWork.flags & 15990);\n        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = getCurrentUpdatePriority(), setCurrentUpdatePriority(2), updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), resetAfterCommit(root.containerInfo), root.current = finishedWork, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, setCurrentUpdatePriority(spawnedLane), ReactSharedInternals.T = transitions) : root.current = finishedWork;\n        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n        remainingLanes = root.pendingLanes;\n        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n        transitions || commitDoubleInvokeEffectsInDEV(root);\n        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n        isDevToolsPresent && root.memoizedUpdaters.clear();\n        onCommitRoot();\n        ensureRootIsScheduled(root);\n        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);\n        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n        remainingLanes = root.pendingLanes;\n        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        markCommitStopped();\n        return null;\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPassiveEffects() {\n        if (null !== rootWithPendingPassiveEffects) {\n            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;\n            pendingPassiveEffectsRemainingLanes = 0;\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n            renderPriority = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(priority);\n                ReactSharedInternals.T = null;\n                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;\n                else {\n                    priority = pendingPassiveTransitions;\n                    pendingPassiveTransitions = null;\n                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;\n                    rootWithPendingPassiveEffects = null;\n                    pendingPassiveEffectsLanes = 0;\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n                    isFlushingPassiveEffects = !0;\n                    didScheduleUpdateDuringPassiveEffects = !1;\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                    var prevExecutionContext = executionContext;\n                    executionContext |= CommitContext;\n                    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n                    executionContext = prevExecutionContext;\n                    flushSyncWorkAcrossRoots_impl(0, !1);\n                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n                    if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n                    } catch (err) {\n                        hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n                    }\n                    var stateNode = root$jscomp$0.current.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                    JSCompiler_inline_result = !0;\n                }\n                return JSCompiler_inline_result;\n            } finally{\n                setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n            }\n        }\n        return !1;\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & 64) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 31457280;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 31457282;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        pendingProps = createFiber(22, pendingProps, key, mode);\n        pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n        pendingProps.lanes = lanes;\n        var primaryChildInstance = {\n            _visibility: 1,\n            _pendingVisibility: 1,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null,\n            _current: null,\n            detach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 === (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            },\n            attach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 !== (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            }\n        };\n        pendingProps.stateNode = primaryChildInstance;\n        return pendingProps;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isDevToolsPresent && (tag |= 2);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        0 === container.tag && flushPassiveEffects();\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    Symbol.for(\"react.debug_trace_mode\");\n    var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, isArrayImpl = Array.isArray, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance, appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance, scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    $$$config.afterActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;\n    $$$config.resolveEventType;\n    $$$config.resolveEventTimeStamp;\n    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance, waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance, clearContainer = $$$config.clearContainer, cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, clearSingleton = $$$config.clearSingleton, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, objectIs = \"function\" === typeof Object.is ? Object.is : is, CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;\n    var createFunctionComponentUpdateQueue = function() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    };\n    var ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n    ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n    ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        mountHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        isMounted: function(component) {\n            var owner = current;\n            if (null !== owner && isRendering && 1 === owner.tag) {\n                var instance = owner.stateNode;\n                instance._warnedAboutRefsInRender || console.error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(owner) || \"A component\");\n                instance._warnedAboutRefsInRender = !0;\n            }\n            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;\n        },\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag) {\n            var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        initialChildren.current.lanes = tag;\n        markRootUpdated$1(initialChildren, tag);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error, errorInfo) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\"), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error, errorInfo) {\n        reportGlobalError(error);\n        error = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\";\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            console.warn(\"%s\\n\\n%s\\n\", error, \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPassiveEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            findFiberByHostInstance: getInstanceFromNode,\n            reconcilerVersion: \"19.0.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = function() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    };\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0FLTSxJQUpILFFBQVFDLE9BQU8sR0FBRyxTQUFVQyxTQUFTO0lBQ3BDLFNBQVNDLFNBQVNDLEtBQUssRUFBRUMsRUFBRTtRQUN6QixJQUFLRCxRQUFRQSxNQUFNRSxhQUFhLEVBQUUsU0FBU0YsU0FBUyxJQUFJQyxJQUN0RCxRQUFTRCxNQUFNRyxJQUFJLEVBQUdGO1FBQ3hCLE9BQU9EO0lBQ1Q7SUFDQSxTQUFTSSxnQkFBZ0JDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7UUFDOUMsSUFBSUQsU0FBU0QsS0FBS0csTUFBTSxFQUFFLE9BQU9EO1FBQ2pDLElBQUlFLE1BQU1KLElBQUksQ0FBQ0MsTUFBTSxFQUNuQkksVUFBVUMsWUFBWVAsT0FBT0EsSUFBSVEsS0FBSyxLQUFLQyxPQUFPLENBQUMsR0FBR1Q7UUFDeERNLE9BQU8sQ0FBQ0QsSUFBSSxHQUFHTixnQkFBZ0JDLEdBQUcsQ0FBQ0ssSUFBSSxFQUFFSixNQUFNQyxRQUFRLEdBQUdDO1FBQzFELE9BQU9HO0lBQ1Q7SUFDQSxTQUFTSSxlQUFlVixHQUFHLEVBQUVXLE9BQU8sRUFBRUMsT0FBTztRQUMzQyxJQUFJRCxRQUFRUCxNQUFNLEtBQUtRLFFBQVFSLE1BQU0sRUFDbkNTLFFBQVFDLElBQUksQ0FBQzthQUNWO1lBQ0gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFFBQVFSLE1BQU0sR0FBRyxHQUFHVyxJQUN0QyxJQUFJSixPQUFPLENBQUNJLEVBQUUsS0FBS0gsT0FBTyxDQUFDRyxFQUFFLEVBQUU7Z0JBQzdCRixRQUFRQyxJQUFJLENBQ1Y7Z0JBRUY7WUFDRjtZQUNGLE9BQU9FLG1CQUFtQmhCLEtBQUtXLFNBQVNDLFNBQVM7UUFDbkQ7SUFDRjtJQUNBLFNBQVNJ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QXFCdXRCLENBQUMsSUFDN0J0MEIsUUFBUWdDLEtBQUssQ0FDWDtZQUVKLElBQUl5d0Qsa0JBQ0ZuNkIsOEJBQThCQyxXQUFXdDVCLElBQUksQ0FBQ3FiLEtBQUs7WUFDckQ4ZCx5QkFDRUcsV0FDQWs2QixpQkFDQSxDQUFDLEdBQ0RwNkIsa0JBQWtCRTtZQUVwQixPQUFPakksT0FBT2tpQztRQUNoQjtJQUVSO0lBQ0E3ekQsUUFBUSt6RCxlQUFlLEdBQUcsU0FDeEIxeEQsT0FBTyxFQUNQMnBDLFNBQVMsRUFDVHNhLGVBQWUsRUFDZjk3QyxRQUFRO1FBRVIsSUFBSXZILFVBQVUrb0MsVUFBVS9vQyxPQUFPLEVBQzdCK0osT0FBTzBzQixrQkFBa0J6MkI7UUFDM0JzakQsb0JBQ0V0akQsU0FDQStKLE1BQ0EzSyxTQUNBMnBDLFdBQ0FzYSxpQkFDQTk3QztRQUVGLE9BQU93QztJQUNUO0lBQ0FoTixRQUFRd0MsbUJBQW1CLEdBQUdBO0lBQzlCLE9BQU94QztBQUNULEdBQ0NELHlCQUFzQixHQUFHQSxPQUFPQyxPQUFPLEVBQ3hDZ0gsT0FBT3lCLGNBQWMsQ0FBQzFJLE9BQU9DLE9BQU8sRUFBRSxjQUFjO0lBQUVXLE9BQU8sQ0FBQztBQUFFLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTEVOT1ZPXFxEb2N1bWVudHNcXGdpdGh1YlxcemlrcmlhbmJpYS5naXRodWIuaW9cXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcY2pzXFxyZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gICgobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJCQkY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gZmluZEhvb2soZmliZXIsIGlkKSB7XG4gICAgICBmb3IgKGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTsgbnVsbCAhPT0gZmliZXIgJiYgMCA8IGlkOyApXG4gICAgICAgIChmaWJlciA9IGZpYmVyLm5leHQpLCBpZC0tO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZShvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpXG4gICAgICAgIGNvbnNvbGUud2FybihcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aFxuICAgICAgICA/ICgodXBkYXRlZFtuZXdQYXRoW2luZGV4XV0gPSB1cGRhdGVkW29sZEtleV0pLFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpXG4gICAgICAgICAgICA/IHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSlcbiAgICAgICAgICAgIDogZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XSlcbiAgICAgICAgOiAodXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKFxuICAgICAgICAgICAgb2JqW29sZEtleV0sXG4gICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIGluZGV4ICsgMVxuICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIGluZGV4KSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc0FycmF5SW1wbCh1cGRhdGVkKSA/IHVwZGF0ZWQuc3BsaWNlKGtleSwgMSkgOiBkZWxldGUgdXBkYXRlZFtrZXldLFxuICAgICAgICAgIHVwZGF0ZWRcbiAgICAgICAgKTtcbiAgICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kSW1wbCgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkRXJyb3JJbXBsKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJvb3Qocm9vdCwgZWxlbWVudCkge1xuICAgICAgcm9vdC5jb250ZXh0ID09PSBlbXB0eUNvbnRleHRPYmplY3QgJiZcbiAgICAgICAgKHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCksIGZsdXNoU3luY1dvcmsoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpIHtcbiAgICAgIGlmIChudWxsICE9PSByZXNvbHZlRmFtaWx5KSB7XG4gICAgICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXM7XG4gICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICAgICAgZmx1c2hTeW5jV29yaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSZWZyZXNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRIb29rQWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KCkge31cbiAgICBmdW5jdGlvbiBzZXRUb1NvcnRlZFN0cmluZyhzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIFwiQ2FjaGVcIjtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHJldHVybiBcIkRlaHlkcmF0ZWRGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSB0eXBlLnJlbmRlciksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgICAoXCJcIiAhPT0gZmliZXIgPyBcIkZvcndhcmRSZWYoXCIgKyBmaWJlciArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIFwiUm9vdFwiO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIFwiVGV4dFwiO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA/IFwiU3RyaWN0TW9kZVwiIDogXCJNb2RlXCI7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZXR1cm4gXCJTY29wZVwiO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIFwiVHJhY2luZ01hcmtlclwiO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdHlwZSA9IGZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICAgICAgaWYgKG51bGwgIT0gdHlwZSlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0eXBlLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGVbaV0ubmFtZSkgcmV0dXJuIHR5cGVbaV0ubmFtZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIucmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIucmV0dXJuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMSkpLCBmaWJlcjtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlciwgITEpKSwgZmliZXJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSwgITApKSwgZmliZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZW50cnkubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvLFxuICAgICAgICAgICAgICAgICAgZW52ID0gZW50cnkuZW52O1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcbiAgICAgICAgICAgICAgICAgIGVudHJ5Lm5hbWUgKyAoZW52ID8gXCIgW1wiICsgZW52ICsgXCJdXCIgOiBcIlwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5mbyA9IEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnQgPyBcIlwiIDogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY2FsbGJhY2ssIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgIG51bGwgPT09IGZpYmVyID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudCA9IHByZXZpb3VzRmliZXI7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJydW5XaXRoRmliZXJJbkRFViBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGluIHByb2R1Y3Rpb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciBub2RlID0gZmliZXIsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG4gICAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSBmb3IgKDsgbm9kZS5yZXR1cm47ICkgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZpYmVyID0gbm9kZTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobm9kZSA9IGZpYmVyKSxcbiAgICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiYgKG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm4pLFxuICAgICAgICAgICAgKGZpYmVyID0gbm9kZS5yZXR1cm4pO1xuICAgICAgICB3aGlsZSAoZmliZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbmVhcmVzdE1vdW50ZWQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgICAgIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoIWFsdGVybmF0ZSkge1xuICAgICAgICBhbHRlcm5hdGUgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcbiAgICAgICAgaWYgKG51bGwgPT09IGFsdGVybmF0ZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGUgIT09IGZpYmVyID8gbnVsbCA6IGZpYmVyO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgYSA9IGZpYmVyLCBiID0gYWx0ZXJuYXRlOyA7ICkge1xuICAgICAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50QSkgYnJlYWs7XG4gICAgICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRCKSB7XG4gICAgICAgICAgYiA9IHBhcmVudEEucmV0dXJuO1xuICAgICAgICAgIGlmIChudWxsICE9PSBiKSB7XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgICAgIGZvciAocGFyZW50QiA9IHBhcmVudEEuY2hpbGQ7IHBhcmVudEI7ICkge1xuICAgICAgICAgICAgaWYgKHBhcmVudEIgPT09IGEpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGZpYmVyO1xuICAgICAgICAgICAgaWYgKHBhcmVudEIgPT09IGIpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGFsdGVybmF0ZTtcbiAgICAgICAgICAgIHBhcmVudEIgPSBwYXJlbnRCLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSAoYSA9IHBhcmVudEEpLCAoYiA9IHBhcmVudEIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBkaWRGaW5kQ2hpbGQgPSAhMSwgX2NoaWxkID0gcGFyZW50QS5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgICBmb3IgKF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7IF9jaGlsZDsgKSB7XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKDMgIT09IGEudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICByZXR1cm4gYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSA/IGZpYmVyIDogYWx0ZXJuYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gcGFyZW50ID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKHBhcmVudCkgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKSByZXR1cm4gbm9kZTtcbiAgICAgIGZvciAobm9kZSA9IG5vZGUuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICB0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSk7XG4gICAgICAgIGlmIChudWxsICE9PSB0YWcpIHJldHVybiB0YWc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICA0ICE9PSBub2RlLnRhZyAmJlxuICAgICAgICAgICgodGFnID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSksIG51bGwgIT09IHRhZylcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY3VycmVudDogZGVmYXVsdFZhbHVlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gICAgICAwID4gaW5kZXgkanNjb21wJDBcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBwb3AuXCIpXG4gICAgICAgIDogKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLlwiKSxcbiAgICAgICAgICAoY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSksXG4gICAgICAgICAgKHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdID0gbnVsbCksXG4gICAgICAgICAgKGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdID0gbnVsbCksXG4gICAgICAgICAgaW5kZXgkanNjb21wJDAtLSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgICAgIGluZGV4JGpzY29tcCQwKys7XG4gICAgICB2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSA9IGN1cnNvci5jdXJyZW50O1xuICAgICAgZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBmaWJlcjtcbiAgICAgIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICAgICAgeCA+Pj49IDA7XG4gICAgICByZXR1cm4gMCA9PT0geCA/IDMyIDogKDMxIC0gKChsb2ckMSh4KSAvIExOMikgfCAwKSkgfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSkge1xuICAgICAgaWYgKGxhbmUgJiAxKSByZXR1cm4gXCJTeW5jSHlkcmF0aW9uTGFuZVwiO1xuICAgICAgaWYgKGxhbmUgJiAyKSByZXR1cm4gXCJTeW5jXCI7XG4gICAgICBpZiAobGFuZSAmIDQpIHJldHVybiBcIklucHV0Q29udGludW91c0h5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA4KSByZXR1cm4gXCJJbnB1dENvbnRpbnVvdXNcIjtcbiAgICAgIGlmIChsYW5lICYgMTYpIHJldHVybiBcIkRlZmF1bHRIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMzIpIHJldHVybiBcIkRlZmF1bHRcIjtcbiAgICAgIGlmIChsYW5lICYgNjQpIHJldHVybiBcIlRyYW5zaXRpb25IeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgNDE5NDE3NikgcmV0dXJuIFwiVHJhbnNpdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA2MjkxNDU2MCkgcmV0dXJuIFwiUmV0cnlcIjtcbiAgICAgIGlmIChsYW5lICYgNjcxMDg4NjQpIHJldHVybiBcIlNlbGVjdGl2ZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAxMzQyMTc3MjgpIHJldHVybiBcIklkbGVIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMjY4NDM1NDU2KSByZXR1cm4gXCJJZGxlXCI7XG4gICAgICBpZiAobGFuZSAmIDUzNjg3MDkxMikgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICBpZiAobGFuZSAmIDEwNzM3NDE4MjQpIHJldHVybiBcIkRlZmVycmVkXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gICAgICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgICBzd2l0Y2ggKGxhbmVzICYgLWxhbmVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA0MTk0MTc2O1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA2MjkxNDU2MDtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICAgIHJldHVybiAxMzQyMTc3Mjg7XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSByZXR1cm4gMDtcbiAgICAgIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgd2FybUxhbmVzID0gcm9vdC53YXJtTGFuZXM7XG4gICAgICByb290ID0gMCAhPT0gcm9vdC5maW5pc2hlZExhbmVzO1xuICAgICAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiAxMzQyMTc3Mjc7XG4gICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgID8gKChwZW5kaW5nTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBwZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBlbmRpbmdMYW5lcykpXG4gICAgICAgICAgICA6ICgocGluZ2VkTGFuZXMgJj0gbm9uSWRsZVBlbmRpbmdMYW5lcyksXG4gICAgICAgICAgICAgIDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSkpXG4gICAgICAgIDogKChub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICA6IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSk7XG4gICAgICByZXR1cm4gMCA9PT0gbmV4dExhbmVzXG4gICAgICAgID8gMFxuICAgICAgICA6IDAgIT09IHdpcExhbmVzICYmXG4gICAgICAgICAgICB3aXBMYW5lcyAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAwID09PSAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgJiZcbiAgICAgICAgICAgICgoc3VzcGVuZGVkTGFuZXMgPSBuZXh0TGFuZXMgJiAtbmV4dExhbmVzKSxcbiAgICAgICAgICAgICh3YXJtTGFuZXMgPSB3aXBMYW5lcyAmIC13aXBMYW5lcyksXG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSB3YXJtTGFuZXMgfHxcbiAgICAgICAgICAgICAgKDMyID09PSBzdXNwZW5kZWRMYW5lcyAmJiAwICE9PSAod2FybUxhbmVzICYgNDE5NDE3NikpKVxuICAgICAgICAgID8gd2lwTGFuZXNcbiAgICAgICAgICA6IG5leHRMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCByZW5kZXJMYW5lcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgMCA9PT1cbiAgICAgICAgKHJvb3QucGVuZGluZ0xhbmVzICZcbiAgICAgICAgICB+KHJvb3Quc3VzcGVuZGVkTGFuZXMgJiB+cm9vdC5waW5nZWRMYW5lcykgJlxuICAgICAgICAgIHJlbmRlckxhbmVzKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBzd2l0Y2ggKGxhbmUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1ZTM7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC0xXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA8PD0gMTtcbiAgICAgIDAgPT09IChuZXh0VHJhbnNpdGlvbkxhbmUgJiA0MTk0MTc2KSAmJiAobmV4dFRyYW5zaXRpb25MYW5lID0gMTI4KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gICAgICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRSZXRyeUxhbmUgJiA2MjkxNDU2MCkgJiYgKG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgICAgIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gICAgICByZXR1cm4gbGFuZU1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTtcbiAgICAgIDI2ODQzNTQ1NiAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkTGFuZXMsXG4gICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICAgICAgcm9vdC53YXJtTGFuZXMgPSAwO1xuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gICAgICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gICAgICBmb3IgKFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gICAgICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IDA7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSAtMTtcbiAgICAgICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG4gICAgICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsLCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpbmRleF07XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgMCk7XG4gICAgICAwICE9PSBzdXNwZW5kZWRSZXRyeUxhbmVzICYmXG4gICAgICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgICAgICAwICE9PSByb290LnRhZyAmJlxuICAgICAgICAocm9vdC5zdXNwZW5kZWRMYW5lcyB8PVxuICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7XG4gICAgICB2YXIgc3Bhd25lZExhbmVJbmRleCA9IDMxIC0gY2x6MzIoc3Bhd25lZExhbmUpO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSA9XG4gICAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8XG4gICAgICAgIDEwNzM3NDE4MjQgfFxuICAgICAgICAoZW50YW5nbGVkTGFuZXMgJiA0MTk0MjE4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHZhciByb290RW50YW5nbGVkTGFuZXMgPSAocm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICBmb3IgKHJvb3QgPSByb290LmVudGFuZ2xlbWVudHM7IHJvb3RFbnRhbmdsZWRMYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocm9vdEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgKGxhbmUgJiBlbnRhbmdsZWRMYW5lcykgfCAocm9vdFtpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykgJiZcbiAgICAgICAgICAocm9vdFtpbmRleF0gfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgICAgICByb290RW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChyb290ID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwOyAwIDwgbGFuZXM7ICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgcm9vdFtpbmRleF0uYWRkKGZpYmVyKTtcbiAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IGxhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpO1xuICAgICAgICAgIHJvb3QgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIGluZGV4ID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgICAgICAgMCA8IGluZGV4LnNpemUgJiZcbiAgICAgICAgICAgIChpbmRleC5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIG1lbW9pemVkVXBkYXRlcnMuaGFzKGFsdGVybmF0ZSkpIHx8XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmRleC5jbGVhcigpKTtcbiAgICAgICAgICBsYW5lcyAmPSB+cm9vdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICAgICAgbGFuZXMgJj0gLWxhbmVzO1xuICAgICAgcmV0dXJuIDIgPCBsYW5lc1xuICAgICAgICA/IDggPCBsYW5lc1xuICAgICAgICAgID8gMCAhPT0gKGxhbmVzICYgMTM0MjE3NzI3KVxuICAgICAgICAgICAgPyAzMlxuICAgICAgICAgICAgOiAyNjg0MzU0NTZcbiAgICAgICAgICA6IDhcbiAgICAgICAgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykgcmV0dXJuICExO1xuICAgICAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gICAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSByZXR1cm4gITA7XG4gICAgICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHNcIlxuICAgICAgICAgICksXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIChyZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKSksIChpbmplY3RlZEhvb2sgPSBob29rKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy5cIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob29rLmNoZWNrRENFID8gITAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Db21taXRSb290JDEocm9vdCwgZXZlbnRQcmlvcml0eSkge1xuICAgICAgaWYgKGluamVjdGVkSG9vayAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGRpZEVycm9yID0gMTI4ID09PSAocm9vdC5jdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QoXG4gICAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5LFxuICAgICAgICAgICAgZGlkRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9nICYmXG4gICAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBwcm9maWxpbmdIb29rcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcykge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgICB9O1xuICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya0NvdW50O1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHRyZWVGb3JrQ291bnQgPSB0b3RhbENoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICB0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCAoMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGgpKSB8XG4gICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdDtcbiAgICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IGxlbmd0aCArIHdvcmtJblByb2dyZXNzO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCBsZW5ndGgpIHwgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHwgYmFzZUlkV2l0aExlYWRpbmdCaXQpLFxuICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLnJldHVybiAmJlxuICAgICAgICAocHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCAxKSwgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgMSwgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyOyApXG4gICAgICAgICh0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpO1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlQ29udGV4dFByb3ZpZGVyOyApXG4gICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gICAgICBpc0h5ZHJhdGluZyB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gYmUgaHlkcmF0aW5nLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICAgbnVsbCA9PT0gYyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTtcbiAgICAgIGNvbnRleHQgIT09IG5leHRDb250ZXh0ICYmXG4gICAgICAgIChwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpLFxuICAgICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dENvbnRleHQsIGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgICAgICAocG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpLCBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKSk7XG4gICAgICBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIpLFxuICAgICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgID8gKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gTm90UGVuZGluZ1RyYW5zaXRpb24pXG4gICAgICAgICAgOiAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gTm90UGVuZGluZ1RyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcyAmJlxuICAgICAgICAwID09PSBub2RlLnNlcnZlclRhaWwubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIDMgPCBub2RlLmRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gMTUgLSBpbmRlbnRcbiAgICAgICAgPyBmaW5kTm90YWJsZU5vZGUobm9kZS5jaGlsZHJlblswXSwgaW5kZW50KVxuICAgICAgICA6IG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGVudGF0aW9uKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiICBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIrIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVkKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiLSBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZmliZXIudHlwZTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gXCJMYXp5XCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci50eXBlLnJlbmRlciksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZmliZXIudHlwZSksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVUZXh0Tm9kZShjb250ZW50LCBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZWVkc0VzY2FwaW5nLnRlc3QoY29udGVudClcbiAgICAgICAgPyAoKGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjb250ZW50KSksXG4gICAgICAgICAgY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgICA/IDggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyAne1wiLi4uXCJ9J1xuICAgICAgICAgICAgICA6IFwie1wiICsgY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSA3KSArICcuLi5cIn0nXG4gICAgICAgICAgICA6IFwie1wiICsgY29udGVudCArIFwifVwiKVxuICAgICAgICA6IGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICA6IGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gMykgKyBcIi4uLlwiXG4gICAgICAgICAgOiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogaW5kZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlcnZlclByb3BzKVxuICAgICAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCI7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BzKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGZpcnN0RGlmZiA9IDA7XG4gICAgICAgICAgZmlyc3REaWZmIDwgc2VydmVyUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgZmlyc3REaWZmIDwgY2xpZW50VGV4dC5sZW5ndGggJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wcy5jaGFyQ29kZUF0KGZpcnN0RGlmZikgPT09XG4gICAgICAgICAgICBjbGllbnRUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKTtcbiAgICAgICAgICBmaXJzdERpZmYrK1xuICAgICAgICApO1xuICAgICAgICBmaXJzdERpZmYgPiBtYXhMZW5ndGggLSA4ICYmXG4gICAgICAgICAgMTAgPCBmaXJzdERpZmYgJiZcbiAgICAgICAgICAoKGNsaWVudFRleHQgPSBcIi4uLlwiICsgY2xpZW50VGV4dC5zbGljZShmaXJzdERpZmYgLSA4KSksXG4gICAgICAgICAgKHNlcnZlclByb3BzID0gXCIuLi5cIiArIHNlcnZlclByb3BzLnNsaWNlKGZpcnN0RGlmZiAtIDgpKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYWRkZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICtcbiAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICByZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyUHJvcHMsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLFxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgICAgID8gJ1wiLi4uXCInXG4gICAgICAgICAgICAgICAgOiB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA0KSArICcuLi5cIidcbiAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkpXG4gICAgICAgICAgICAgID8gXCI8XCIgKyBtYXhMZW5ndGggKyBcIj5cIlxuICAgICAgICAgICAgICA6IFwiPC4uLj5cIjtcbiAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIGlmIChcIk9iamVjdFwiID09PSBuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG1heExlbmd0aCAtPSAyO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdmFsdWUpXG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvblByb3BOYW1lID0gSlNPTi5zdHJpbmdpZnkocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSAhPT0gJ1wiJyArIHByb3BOYW1lICsgJ1wiJyAmJlxuICAgICAgICAgICAgICAgICAgKHByb3BOYW1lID0ganNvblByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBqc29uUHJvcE5hbWUgPSBkZXNjcmliZVZhbHVlKFxuICAgICAgICAgICAgICAgICAgdmFsdWVbcHJvcE5hbWVdLFxuICAgICAgICAgICAgICAgICAgMTUgPiBtYXhMZW5ndGggPyBtYXhMZW5ndGggOiAxNVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IGpzb25Qcm9wTmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJcIiA9PT0gbmFtZSA/IFwiLi4uXCIgOiBcIiwgLi4uXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZSArPVxuICAgICAgICAgICAgICAgICAgKFwiXCIgPT09IG5hbWUgPyBcIlwiIDogXCIsXCIpICsgcHJvcE5hbWUgKyBcIjpcIiArIGpzb25Qcm9wTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgbmFtZSArIFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgbWF4TGVuZ3RoXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVQcm9wVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSB8fCBuZWVkc0VzY2FwaW5nLnRlc3QodmFsdWUpXG4gICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggLSAyKSArIFwifVwiXG4gICAgICAgIDogdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMlxuICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgIDogJ1wiJyArIHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDUpICsgJy4uLlwiJ1xuICAgICAgICAgIDogJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgcHJvcHMsIHJvd1ByZWZpeCkge1xuICAgICAgdmFyIHJlbWFpbmluZ1Jvd0xlbmd0aCA9IDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSB0eXBlLmxlbmd0aCxcbiAgICAgICAgcHJvcGVydGllcyA9IFtdLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gcHJvcHMpXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSBwcm9wTmFtZS5sZW5ndGggLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW1haW5pbmdSb3dMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BOYW1lICsgXCI9XCIgKyBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gMCA9PT0gcHJvcGVydGllcy5sZW5ndGhcbiAgICAgICAgPyByb3dQcmVmaXggKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICA6IDAgPCByZW1haW5pbmdSb3dMZW5ndGhcbiAgICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiIFwiICsgcHJvcGVydGllcy5qb2luKFwiIFwiKSArIFwiPlxcblwiXG4gICAgICAgICAgOiByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIiAgXCIgK1xuICAgICAgICAgICAgcHJvcGVydGllcy5qb2luKFwiXFxuXCIgKyByb3dQcmVmaXggKyBcIiAgXCIpICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudE9iamVjdCwgc2VydmVyT2JqZWN0LCBpbmRlbnQpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gXCJcIixcbiAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcyA9IGFzc2lnbih7fSwgc2VydmVyT2JqZWN0KSxcbiAgICAgICAgcHJvcE5hbWU7XG4gICAgICBmb3IgKHByb3BOYW1lIGluIGNsaWVudE9iamVjdClcbiAgICAgICAgaWYgKGNsaWVudE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQgLSBwcm9wTmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShjbGllbnRPYmplY3RbcHJvcE5hbWVdLCBtYXhMZW5ndGgpO1xuICAgICAgICAgIHNlcnZlck9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSlcbiAgICAgICAgICAgID8gKChtYXhMZW5ndGggPSBkZXNjcmliZVZhbHVlKHNlcnZlck9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCkpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudFByb3BWYWx1ZSArIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgbWF4TGVuZ3RoICsgXCJcXG5cIikpXG4gICAgICAgICAgICA6IChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzKVxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZSkgJiZcbiAgICAgICAgICAoKGNsaWVudE9iamVjdCA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW19wcm9wTmFtZV0sXG4gICAgICAgICAgICAxMjAgLSAyICogaW5kZW50IC0gX3Byb3BOYW1lLmxlbmd0aCAtIDJcbiAgICAgICAgICApKSxcbiAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgX3Byb3BOYW1lICsgXCI6IFwiICsgY2xpZW50T2JqZWN0ICsgXCJcXG5cIikpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudERpZmYodHlwZSwgY2xpZW50UHJvcHMsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIixcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChwcm9wTmFtZSRqc2NvbXAkMCBpbiBzZXJ2ZXJQcm9wcylcbiAgICAgICAgc2VydmVyUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgc2VydmVyUHJvcE5hbWVzLnNldChcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICBpZiAoMSA9PT0gc2VydmVyUHJvcE5hbWVzLnNpemUgJiYgc2VydmVyUHJvcE5hbWVzLmhhcyhcImNoaWxkcmVuXCIpKVxuICAgICAgICBjb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2xpZW50UHJvcHMsXG4gICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KVxuICAgICAgICApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZTIgaW4gY2xpZW50UHJvcHMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2xpZW50UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lMikgJiZcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIiAhPT0gX3Byb3BOYW1lMlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIF9wcm9wTmFtZTIubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wTmFtZXMuZ2V0KF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBzZXJ2ZXJQcm9wTmFtZSkge1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZGVsZXRlKF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIHZhciBwcm9wTmFtZSRqc2NvbXAkMCA9IGNsaWVudFByb3BzW19wcm9wTmFtZTJdO1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BzW3NlcnZlclByb3BOYW1lXTtcbiAgICAgICAgICAgICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHByb3BOYW1lJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHNlcnZlclByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAoMiA8IE9iamVjdC5rZXlzKHByb3BOYW1lJGpzY29tcCQwKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAyIDwgT2JqZWN0LmtleXMoc2VydmVyUHJvcE5hbWUpLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIC0xIDwgY2xpZW50UHJvcFZhbHVlLmluZGV4T2YoXCIuLi5cIikgfHxcbiAgICAgICAgICAgICAgICAtMSA8IG1heExlbmd0aCRqc2NvbXAkMC5pbmRleE9mKFwiLi4uXCIpKVxuICAgICAgICAgICAgICAgID8gKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9e3tcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICsgMlxuICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIn19XFxuXCIpXG4gICAgICAgICAgICAgICAgOiAoKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICAgIChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50UHJvcHNbX3Byb3BOYW1lMl0sIG1heExlbmd0aCRqc2NvbXAkMCkgK1xuICAgICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiAoaW5kZW50ICsgMSkgLSBwcm9wTmFtZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgIGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgXCJcIiA9PT0gY29udGVudFxuICAgICAgICAgICAgPyBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCJcbiAgICAgICAgICAgIDogaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICBjb250ZW50ICtcbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPlxcblwiO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHNlcnZlclByb3BzLmNoaWxkcmVuO1xuICAgICAgY2xpZW50UHJvcHMgPSBjbGllbnRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICkge1xuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICAgIClcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiICsgY2xpZW50UHJvcHM7XG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVUZXh0RGlmZihzZXJ2ZXJQcm9wTmFtZXMsIFwiXCIgKyB0eXBlLCBpbmRlbnQgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICApXG4gICAgICAgIGNvbnRlbnQgPVxuICAgICAgICAgIG51bGwgPT0gdHlwZVxuICAgICAgICAgICAgPyBjb250ZW50ICsgZGVzY3JpYmVUZXh0RGlmZihcIlwiICsgY2xpZW50UHJvcHMsIG51bGwsIGluZGVudCArIDEpXG4gICAgICAgICAgICA6IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgdm9pZCAwLCBpbmRlbnQgKyAxKTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKTtcbiAgICAgIGlmIChudWxsID09PSB0eXBlKSB7XG4gICAgICAgIHR5cGUgPSBcIlwiO1xuICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IGZpYmVyOyApXG4gICAgICAgICAgKHR5cGUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkpLFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgdmFyIHNraXBUb05vZGUgPSBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KTtcbiAgICAgIGlmIChcbiAgICAgICAgc2tpcFRvTm9kZSAhPT0gbm9kZSAmJlxuICAgICAgICAoMSAhPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggfHwgbm9kZS5jaGlsZHJlblswXSAhPT0gc2tpcFRvTm9kZSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCIuLi5cXG5cIiArIGRlc2NyaWJlTm9kZShza2lwVG9Ob2RlLCBpbmRlbnQgKyAxKVxuICAgICAgICApO1xuICAgICAgc2tpcFRvTm9kZSA9IFwiXCI7XG4gICAgICB2YXIgZGVidWdJbmZvID0gbm9kZS5maWJlci5fZGVidWdJbmZvO1xuICAgICAgaWYgKGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlYnVnSW5mb1tpXS5uYW1lO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAoKHNraXBUb05vZGUgKz1cbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgc2VydmVyQ29tcG9uZW50TmFtZSArIFwiPlxcblwiKSxcbiAgICAgICAgICAgIGluZGVudCsrKTtcbiAgICAgICAgfVxuICAgICAgZGVidWdJbmZvID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgIGlmICg2ID09PSBub2RlLmZpYmVyLnRhZylcbiAgICAgICAgKGRlYnVnSW5mbyA9IGRlc2NyaWJlVGV4dERpZmYoaSwgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KSksIGluZGVudCsrO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICgoc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlc2NyaWJlRmliZXJUeXBlKG5vZGUuZmliZXIpKSxcbiAgICAgICAgbnVsbCAhPT0gc2VydmVyQ29tcG9uZW50TmFtZSlcbiAgICAgIClcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcykge1xuICAgICAgICAgIGRlYnVnSW5mbyA9IGluZGVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGRlYnVnSW5mbyAtIHNlcnZlckNvbXBvbmVudE5hbWUubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gaSlcbiAgICAgICAgICAgIGlmIChpLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShpW3Byb3BOYW1lXSwgMTUpO1xuICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgICAgIGlmICgwID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBcIiAuLi5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIFwiICsgcHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1Z0luZm8gPVxuICAgICAgICAgICAgaW5kZW50YXRpb24oZGVidWdJbmZvKSArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lICtcbiAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgID8gKChkZWJ1Z0luZm8gPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaW5kZW50KyspXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlLnNlcnZlclByb3BzXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiU2hvdWxkIG5vdCBoYXZlIG1hdGNoZWQgYSBub24gSG9zdFRleHQgZmliZXIgdG8gYSBUZXh0IG5vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogKChkZWJ1Z0luZm8gPSBkZXNjcmliZUVsZW1lbnREaWZmKFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICBub2RlLnNlcnZlclByb3BzLFxuICAgICAgICAgICAgICAgICAgaW5kZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgdmFyIHByb3BOYW1lID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLmNoaWxkO1xuICAgICAgZm9yIChcbiAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSA9IDA7XG4gICAgICAgIGkgJiYgc2VydmVyQ29tcG9uZW50TmFtZSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICApXG4gICAgICAgIChtYXhMZW5ndGggPSBub2RlLmNoaWxkcmVuW3NlcnZlckNvbXBvbmVudE5hbWVdKSxcbiAgICAgICAgICBtYXhMZW5ndGguZmliZXIgPT09IGlcbiAgICAgICAgICAgID8gKChwcm9wTmFtZSArPSBkZXNjcmliZU5vZGUobWF4TGVuZ3RoLCBpbmRlbnQpKSxcbiAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSsrKVxuICAgICAgICAgICAgOiAocHJvcE5hbWUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoaSwgaW5kZW50KSksXG4gICAgICAgICAgKGkgPSBpLnNpYmxpbmcpO1xuICAgICAgaSAmJlxuICAgICAgICAwIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKHByb3BOYW1lICs9IGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiKTtcbiAgICAgIGkgPSBub2RlLnNlcnZlclRhaWw7XG4gICAgICBudWxsID09PSBub2RlLnNlcnZlclByb3BzICYmIGluZGVudC0tO1xuICAgICAgZm9yIChub2RlID0gMDsgbm9kZSA8IGkubGVuZ3RoOyBub2RlKyspXG4gICAgICAgIChzZXJ2ZXJDb21wb25lbnROYW1lID0gaVtub2RlXSksXG4gICAgICAgICAgKHByb3BOYW1lID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lXG4gICAgICAgICAgICAgID8gcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIChyZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJDb21wb25lbnROYW1lLCAxMjAgLSAyICogaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBcIlxcblwiKVxuICAgICAgICAgICAgICA6IHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUudHlwZSxcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUucHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIHJldHVybiBza2lwVG9Ob2RlICsgZGVidWdJbmZvICsgcHJvcE5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRGlmZihyb290Tm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFwiXFxuXFxuXCIgKyBkZXNjcmliZU5vZGUocm9vdE5vZGUsIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybikge1xuICAgICAgICBpZiAobnVsbCA9PT0gaHlkcmF0aW9uRGlmZlJvb3RERVYpXG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlNhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmICsgMVxuICAgICAgKS5jaGlsZHJlbjtcbiAgICAgIGlmICgwIDwgc2libGluZ3MubGVuZ3RoICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2libGluZ3MgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZiksXG4gICAgICAgICAgc2libGluZ3NcbiAgICAgICAgKTtcbiAgICAgIGRpc3RhbmNlRnJvbUxlYWYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzLnB1c2goZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIHJlamVjdGVkQ2FuZGlkYXRlKSB7XG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAoKGZpYmVyID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCkpLFxuICAgICAgICAoZmliZXIuc2VydmVyUHJvcHMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gcmVqZWN0ZWRDYW5kaWRhdGUgJiZcbiAgICAgICAgICAoKHJlamVjdGVkQ2FuZGlkYXRlID1cbiAgICAgICAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MocmVqZWN0ZWRDYW5kaWRhdGUpKSxcbiAgICAgICAgICBmaWJlci5zZXJ2ZXJUYWlsLnB1c2gocmVqZWN0ZWRDYW5kaWRhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICAgICAgdmFyIGRpZmYgPSBcIlwiLFxuICAgICAgICBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgbnVsbCAhPT0gZGlmZlJvb3QgJiZcbiAgICAgICAgKChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLCAoZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCkpKTtcbiAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG5odHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiICtcbiAgICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICksXG4gICAgICAgICAgZmliZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRocm93IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCBob3N0Q29udGV4dCkge1xuICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICBoeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgZmliZXIudHlwZSxcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaG9zdENvbnRleHQsXG4gICAgICAgIGZpYmVyXG4gICAgICApIHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgICAgIGZvciAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47IGh5ZHJhdGlvblBhcmVudEZpYmVyOyApXG4gICAgICAgIHN3aXRjaCAoaHlkcmF0aW9uUGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uIHx8IGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikgcmV0dXJuICExO1xuICAgICAgaWYgKCFpc0h5ZHJhdGluZylcbiAgICAgICAgcmV0dXJuIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpLCAoaXNIeWRyYXRpbmcgPSAhMCksICExO1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gITE7XG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgPyAzICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAyNyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKDUgIT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgKHNob3VsZENsZWFyID0gITApXG4gICAgICAgIDogMyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKDUgIT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgKHNob3VsZENsZWFyID0gITApO1xuICAgICAgaWYgKHNob3VsZENsZWFyICYmIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgZm9yIChzaG91bGRDbGVhciA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7IHNob3VsZENsZWFyOyApIHtcbiAgICAgICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhzaG91bGRDbGVhcik7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyVGFpbC5wdXNoKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBzaG91bGRDbGVhciA9XG4gICAgICAgICAgICBcIlN1c3BlbnNlXCIgPT09IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHNob3VsZENsZWFyKVxuICAgICAgICAgICAgICA6IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhzaG91bGRDbGVhcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICAgIH1cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgZmliZXIgPSBudWxsICE9PSBmaWJlciA/IGZpYmVyLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICBpZiAoIWZpYmVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXJcbiAgICAgICAgICA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsKSxcbiAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gaXNIeWRyYXRpbmcgPSAhMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICBudWxsID09PSBoeWRyYXRpb25FcnJvcnNcbiAgICAgICAgPyAoaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSB7XG4gICAgICB2YXIgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIG51bGwgIT09IGRpZmZSb290ICYmXG4gICAgICAgICgoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgKGRpZmZSb290ID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHRyZWUgaHlkcmF0ZWQgYnV0IHNvbWUgYXR0cmlidXRlcyBvZiB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQgcHJvcGVydGllcy4gVGhpcyB3b24ndCBiZSBwYXRjaGVkIHVwLiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG4lcyVzXCIsXG4gICAgICAgICAgXCJodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiLFxuICAgICAgICAgIGRpZmZSb290XG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29uY3VycmVudFF1ZXVlc0luZGV4LFxuICAgICAgICAgIGkgPSAoY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCk7XG4gICAgICAgIGkgPCBlbmRJbmRleDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBxdWV1ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgICAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgICAgICB2YXIgbGFuZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSAmJiBudWxsICE9PSB1cGRhdGUpIHtcbiAgICAgICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAwICE9PSBsYW5lICYmIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gZmliZXI7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHF1ZXVlO1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSB1cGRhdGU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGxhbmU7XG4gICAgICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gICAgICBmaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5sYW5lcyB8PSBsYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgbnVsbCwgbnVsbCwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIHNvdXJjZUZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gbGFuZSk7XG4gICAgICBmb3IgKHZhciBpc0hpZGRlbiA9ICExLCBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICAocGFyZW50LmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgKGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgMjIgPT09IHBhcmVudC50YWcgJiZcbiAgICAgICAgICAgICgoc291cmNlRmliZXIgPSBwYXJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyIHx8XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLl92aXNpYmlsaXR5ICYgMSB8fFxuICAgICAgICAgICAgICAoaXNIaWRkZW4gPSAhMCkpLFxuICAgICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudCksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5yZXR1cm4pO1xuICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgbnVsbCAhPT0gdXBkYXRlICYmXG4gICAgICAgIDMgPT09IHNvdXJjZUZpYmVyLnRhZyAmJlxuICAgICAgICAoKHBhcmVudCA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgIChpc0hpZGRlbiA9IDMxIC0gY2x6MzIobGFuZSkpLFxuICAgICAgICAocGFyZW50ID0gcGFyZW50LmhpZGRlblVwZGF0ZXMpLFxuICAgICAgICAoc291cmNlRmliZXIgPSBwYXJlbnRbaXNIaWRkZW5dKSxcbiAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICA/IChwYXJlbnRbaXNIaWRkZW5dID0gW3VwZGF0ZV0pXG4gICAgICAgICAgOiBzb3VyY2VGaWJlci5wdXNoKHVwZGF0ZSksXG4gICAgICAgICh1cGRhdGUubGFuZSA9IGxhbmUgfCA1MzY4NzA5MTIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihzb3VyY2VGaWJlcikge1xuICAgICAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gbmVzdGVkVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwpLFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXCJcbiAgICAgICAgICApKVxuICAgICAgICApO1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUICYmXG4gICAgICAgICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiBldmVyeSByZW5kZXIuXCJcbiAgICAgICAgKSk7XG4gICAgICBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgMCAhPT0gKHNvdXJjZUZpYmVyLmZsYWdzICYgNDA5OCkgJiZcbiAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgICBmb3IgKHZhciBub2RlID0gc291cmNlRmliZXIsIHBhcmVudCA9IG5vZGUucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgbnVsbCA9PT0gbm9kZS5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAwICE9PSAobm9kZS5mbGFncyAmIDQwOTgpICYmXG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlciksXG4gICAgICAgICAgKG5vZGUgPSBwYXJlbnQpLFxuICAgICAgICAgIChwYXJlbnQgPSBub2RlLnJldHVybik7XG4gICAgICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBub2RlLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgcmV0dXJuIHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgICByZXR1cm4gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IHByb2ZpbGVyRWZmZWN0RHVyYXRpb247XG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgMCA+IGZpYmVyLmFjdHVhbFN0YXJ0VGltZSAmJiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gcHJvZmlsZXJTdGFydFRpbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbihmaWJlcikge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29yZEVmZmVjdER1cmF0aW9uKCkge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRFZmZlY3RUaW1lcigpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGZvciAodmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IGNoaWxkOyApXG4gICAgICAgIChmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCkge1xuICAgICAgcm9vdCAhPT0gbGFzdFNjaGVkdWxlZFJvb3QgJiZcbiAgICAgICAgbnVsbCA9PT0gcm9vdC5uZXh0ICYmXG4gICAgICAgIChudWxsID09PSBsYXN0U2NoZWR1bGVkUm9vdFxuICAgICAgICAgID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdClcbiAgICAgICAgICA6IChsYXN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290KSk7XG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgID8gZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0IHx8XG4gICAgICAgICAgKChkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSAhMCksXG4gICAgICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpXG4gICAgICAgIDogZGlkU2NoZWR1bGVNaWNyb3Rhc2sgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrID0gITApLFxuICAgICAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgb25seUxlZ2FjeSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nV29yayAmJiBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBkaWRQZXJmb3JtU29tZVdvcmsgPSAhMTtcbiAgICAgICAgICBmb3IgKHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290OyBudWxsICE9PSByb290OyApIHtcbiAgICAgICAgICAgIGlmICghb25seUxlZ2FjeSlcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgdmFyIG5leHRMYW5lcyA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICAoMSA8PCAoMzEgLSBjbHozMig0MiB8IHN5bmNUcmFuc2l0aW9uTGFuZXMpICsgMSkpIC0gMTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmPSBwZW5kaW5nTGFuZXMgJiB+KHN1c3BlbmRlZExhbmVzICYgfnBpbmdlZExhbmVzKTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmIDIwMTMyNjY3N1xuICAgICAgICAgICAgICAgICAgICAgID8gKG5leHRMYW5lcyAmIDIwMTMyNjY3NykgfCAxXG4gICAgICAgICAgICAgICAgICAgICAgOiBuZXh0TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dExhbmVzIHwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAwICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gbmV4dExhbmVzIDogMFxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAwID09PSAobmV4dExhbmVzICYgMykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBuZXh0TGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbmV4dExhbmVzKSk7XG4gICAgICAgICAgICByb290ID0gcm9vdC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkUGVyZm9ybVNvbWVXb3JrKTtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPVxuICAgICAgICAgICExO1xuICAgICAgdmFyIHN5bmNUcmFuc2l0aW9uTGFuZXMgPSAwO1xuICAgICAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAgICAgKHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24oKSAmJlxuICAgICAgICAgIChzeW5jVHJhbnNpdGlvbkxhbmVzID0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpLFxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwKSk7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBub3ckMSgpLCBwcmV2ID0gbnVsbCwgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgbnVsbCAhPT0gcm9vdDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0LFxuICAgICAgICAgIG5leHRMYW5lcyA9IHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpO1xuICAgICAgICBpZiAoMCA9PT0gbmV4dExhbmVzKVxuICAgICAgICAgIChyb290Lm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgPT09IHByZXYgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dCkgOiAocHJldi5uZXh0ID0gbmV4dCksXG4gICAgICAgICAgICBudWxsID09PSBuZXh0ICYmIChsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXYpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoKHByZXYgPSByb290KSwgMCAhPT0gc3luY1RyYW5zaXRpb25MYW5lcyB8fCAwICE9PSAobmV4dExhbmVzICYgMykpXG4gICAgICAgIClcbiAgICAgICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICAgICAgcm9vdCA9IG5leHQ7XG4gICAgICB9XG4gICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChzeW5jVHJhbnNpdGlvbkxhbmVzLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgICAgIGxhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiAtNjI5MTQ1NjE7XG4gICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4LFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcbiAgICAgICAgaWYgKC0xID09PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIGlmICgwID09PSAobGFuZSAmIHN1c3BlbmRlZExhbmVzKSB8fCAwICE9PSAobGFuZSAmIHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2UgZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUgJiYgKHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmUpO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRUaW1lID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgc3VzcGVuZGVkTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSBjdXJyZW50VGltZSA/IHN1c3BlbmRlZExhbmVzIDogMFxuICAgICAgKTtcbiAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHN1c3BlbmRlZExhbmVzIHx8XG4gICAgICAgIChyb290ID09PSBjdXJyZW50VGltZSAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKHN1c3BlbmRlZExhbmVzICYgMykgfHxcbiAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBzdXNwZW5kZWRMYW5lcylcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50VGltZSA9IHN1c3BlbmRlZExhbmVzICYgLXN1c3BlbmRlZExhbmVzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudFRpbWUgIT09IHJvb3QuY2FsbGJhY2tQcmlvcml0eSB8fFxuICAgICAgICAgIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAgICAgcGluZ2VkTGFuZXMgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSlcbiAgICAgICAgKVxuICAgICAgICAgIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgICAgZWxzZSByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkoc3VzcGVuZGVkTGFuZXMpKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgIH1cbiAgICAgICAgcGluZ2VkTGFuZXMgPSBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgICA/IChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAgIChzdXNwZW5kZWRMYW5lcyA9IGZha2VBY3RDYWxsYmFja05vZGUkMSkpXG4gICAgICAgICAgOiAoc3VzcGVuZGVkTGFuZXMgPSBzY2hlZHVsZUNhbGxiYWNrJDMoc3VzcGVuZGVkTGFuZXMsIHBpbmdlZExhbmVzKSk7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyk7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAyO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayhyb290LCBkaWRUaW1lb3V0KSB7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMTtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICAgICAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSAmJiByb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgOiAwXG4gICAgICApO1xuICAgICAgaWYgKDAgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwKSByZXR1cm4gbnVsbDtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KFxuICAgICAgICByb290LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgZGlkVGltZW91dFxuICAgICAgKTtcbiAgICAgIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgbm93JDEoKSk7XG4gICAgICByZXR1cm4gbnVsbCAhPSByb290LmNhbGxiYWNrTm9kZSAmJlxuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGVcbiAgICAgICAgPyBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBsYW5lcykge1xuICAgICAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICAgICAgY2FsbGJhY2tOb2RlICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgJiZcbiAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJbW1lZGlhdGVUYXNrKGNiKSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIHN1cHBvcnRzTWljcm90YXNrc1xuICAgICAgICA/IHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dFxuICAgICAgICAgICAgICA/IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpXG4gICAgICAgICAgICAgIDogY2IoKTtcbiAgICAgICAgICB9KVxuICAgICAgICA6IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICAwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpKTtcbiAgICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICAgICAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgICAgICAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycztcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIGZvciAoZXJyb3IgPSAwOyBlcnJvciA8IGxpc3RlbmVycy5sZW5ndGg7IGVycm9yKyspXG4gICAgICAgICAgICAoMCwgbGlzdGVuZXJzW2Vycm9yXSkodm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gICAgICBmaWJlci51cGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgICAgICBzaGFyZWQ6IHsgcGVuZGluZzogbnVsbCwgbGFuZXM6IDAsIGhpZGRlbkNhbGxiYWNrczogbnVsbCB9LFxuICAgICAgICBjYWxsYmFja3M6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudC5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGxhbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhbmU6IGxhbmUsXG4gICAgICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgICAgIHBheWxvYWQ6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHVwZGF0ZVF1ZXVlKSByZXR1cm4gbnVsbDtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgICAgICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCB3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSBjYWxsYmFjay5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50OiAlc1wiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoY29tcG9uZW50TmFtZSA9IHVwZGF0ZVF1ZXVlLnBlbmRpbmcpLFxuICAgICAgICAgIG51bGwgPT09IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gY29tcG9uZW50TmFtZS5uZXh0KSxcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUubmV4dCA9IHVwZGF0ZSkpLFxuICAgICAgICAgICh1cGRhdGVRdWV1ZS5wZW5kaW5nID0gdXBkYXRlKSxcbiAgICAgICAgICAodXBkYXRlID0gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcikpLFxuICAgICAgICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBudWxsLCBsYW5lKSxcbiAgICAgICAgICB1cGRhdGVcbiAgICAgICAgKTtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgdXBkYXRlUXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIgJiYgKChmaWJlciA9IGZpYmVyLnNoYXJlZCksIDAgIT09IChsYW5lICYgNDE5NDE3NikpKSB7XG4gICAgICAgIHZhciBxdWV1ZUxhbmVzID0gZmliZXIubGFuZXM7XG4gICAgICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICAgICAgZmliZXIubGFuZXMgPSBsYW5lO1xuICAgICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsXG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksIHF1ZXVlID09PSBjdXJyZW50KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXdGaXJzdCA9IG51bGwsXG4gICAgICAgICAgbmV3TGFzdCA9IG51bGw7XG4gICAgICAgIHF1ZXVlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcXVldWUpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHF1ZXVlLmxhbmUsXG4gICAgICAgICAgICAgIHRhZzogcXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBxdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmUpXG4gICAgICAgICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjbG9uZSk7XG4gICAgICAgICAgICBxdWV1ZSA9IHF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gcXVldWUpO1xuICAgICAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgICAgID8gKG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICBxdWV1ZSA9IHtcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgICAgICBjYWxsYmFja3M6IGN1cnJlbnQuY2FsbGJhY2tzXG4gICAgICAgIH07XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICA/IChxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSB7XG4gICAgICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgICAgICB2YXIgZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICAgIGlmIChudWxsICE9PSBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSkgdGhyb3cgZW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcHJvcHMsXG4gICAgICBpbnN0YW5jZSRqc2NvbXAkMCxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWUsXG4gICAgICAgICAgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7XG4gICAgICAgIG51bGwgPT09IGxhc3RCYXNlVXBkYXRlXG4gICAgICAgICAgPyAoZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlKVxuICAgICAgICAgIDogKGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpO1xuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlKSxcbiAgICAgICAgICBwZW5kaW5nUXVldWUgIT09IGxhc3RCYXNlVXBkYXRlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlKVxuICAgICAgICAgICAgICA6IChwZW5kaW5nUXVldWUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSksXG4gICAgICAgICAgICAoY3VycmVudC5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IGZpcnN0QmFzZVVwZGF0ZSkge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gMDtcbiAgICAgICAgY3VycmVudCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gZmlyc3RCYXNlVXBkYXRlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUubGFuZSAmIC01MzY4NzA5MTMsXG4gICAgICAgICAgICBpc0hpZGRlblVwZGF0ZSA9IHVwZGF0ZUxhbmUgIT09IHBlbmRpbmdRdWV1ZS5sYW5lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgMCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICB1cGRhdGVMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICB1cGRhdGVMYW5lID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSBwcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlJGpzY29tcCQwO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnRpYWxTdGF0ZS50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXJ0aWFsU3RhdGUuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUxhbmUubW9kZSAmIDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZS5jYWxsKGluc3RhbmNlLCBuZXdTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITE7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBwYXJ0aWFsU3RhdGU7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUuZmxhZ3MgPSAodXBkYXRlTGFuZS5mbGFncyAmIC02NTUzNykgfCAxMjg7XG4gICAgICAgICAgICAgICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBwYXJ0aWFsU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcGFydGlhbFN0YXRlIHx8IHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlKSBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBhc3NpZ24oe30sIG5ld1N0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5jYWxsYmFjaztcbiAgICAgICAgICAgIG51bGwgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NCksXG4gICAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSxcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcXVldWUuY2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgICA/IChxdWV1ZS5jYWxsYmFja3MgPSBbdXBkYXRlTGFuZV0pXG4gICAgICAgICAgICAgICAgOiBpc0hpZGRlblVwZGF0ZS5wdXNoKHVwZGF0ZUxhbmUpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IHBlbmRpbmdRdWV1ZS5jYWxsYmFjayxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/ICgoZmlyc3RQZW5kaW5nVXBkYXRlID0gY3VycmVudCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgICAgIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKSlcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50ID0gY3VycmVudC5uZXh0ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAobGFzdEJhc2VVcGRhdGUgfD0gdXBkYXRlTGFuZSk7XG4gICAgICAgICAgcGVuZGluZ1F1ZXVlID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgICAgIGlmICgoKHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nKSwgbnVsbCA9PT0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHBlbmRpbmdRdWV1ZSksXG4gICAgICAgICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGlzSGlkZGVuVXBkYXRlLm5leHQpLFxuICAgICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZS5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgIChxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGwpO1xuICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSk7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY3VycmVudDtcbiAgICAgICAgbnVsbCA9PT0gZmlyc3RCYXNlVXBkYXRlICYmIChxdWV1ZS5zaGFyZWQubGFuZXMgPSAwKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGxhc3RCYXNlVXBkYXRlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhc3RCYXNlVXBkYXRlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gaGlkZGVuQ2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPCBoaWRkZW5DYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICAgICAgKVxuICAgICAgICAgIGNhbGxDYWxsYmFjayhoaWRkZW5DYWxsYmFja3NbdXBkYXRlUXVldWVdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gdXBkYXRlUXVldWUuY2FsbGJhY2tzO1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5jYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPCBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICAgICAgKVxuICAgICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFja3NbdXBkYXRlUXVldWVdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgICAgIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQSB8fFxuICAgICAgICBudWxsID09PSBvYmpBIHx8XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgICAgIG51bGwgPT09IG9iakJcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSksXG4gICAgICAgIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAoa2V5c0IgPSAwOyBrZXlzQiA8IGtleXNBLmxlbmd0aDsga2V5c0IrKykge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2tleXNCXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8XG4gICAgICAgICAgIW9iamVjdElzKG9iakFbY3VycmVudEtleV0sIG9iakJbY3VycmVudEtleV0pXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4geyBkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2U6ICExLCB0aGVuYWJsZXM6IFtdIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkge1xuICAgICAgdGhlbmFibGUgPSB0aGVuYWJsZS5zdGF0dXM7XG4gICAgICByZXR1cm4gXCJmdWxmaWxsZWRcIiA9PT0gdGhlbmFibGUgfHwgXCJyZWplY3RlZFwiID09PSB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITApO1xuICAgICAgdmFyIHRyYWNrZWRUaGVuYWJsZXMgPSB0aGVuYWJsZVN0YXRlLnRoZW5hYmxlcztcbiAgICAgIGluZGV4ID0gdHJhY2tlZFRoZW5hYmxlc1tpbmRleF07XG4gICAgICB2b2lkIDAgPT09IGluZGV4XG4gICAgICAgID8gdHJhY2tlZFRoZW5hYmxlcy5wdXNoKHRoZW5hYmxlKVxuICAgICAgICA6IGluZGV4ICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICh0aGVuYWJsZVN0YXRlLmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSB8fFxuICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlLmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnQgd2FzIHN1c3BlbmRlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLiBDcmVhdGluZyBwcm9taXNlcyBpbnNpZGUgYSBDbGllbnQgQ29tcG9uZW50IG9yIGhvb2sgaXMgbm90IHlldCBzdXBwb3J0ZWQsIGV4Y2VwdCB2aWEgYSBTdXNwZW5zZS1jb21wYXRpYmxlIGxpYnJhcnkgb3IgZnJhbWV3b3JrLlwiXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKSxcbiAgICAgICAgICAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHRoZW5hYmxlU3RhdGUpLFxuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIDEwMCA8IHRoZW5hYmxlU3RhdGUuc2hlbGxTdXNwZW5kQ291bnRlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImFzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5IFNlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCh0aGVuYWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITA7XG4gICAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZFJlYXNvbikge1xuICAgICAgaWYgKHJlamVjdGVkUmVhc29uID09PSBTdXNwZW5zZUV4Y2VwdGlvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJIb29rcyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUgYW4gYXN5bmMgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRGVidWdJbmZvKGRlYnVnSW5mbykge1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgIG51bGwgIT0gZGVidWdJbmZvICYmXG4gICAgICAgIChjdXJyZW50RGVidWdJbmZvID1cbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c0RlYnVnSW5mb1xuICAgICAgICAgICAgPyBkZWJ1Z0luZm9cbiAgICAgICAgICAgIDogcHJldmlvdXNEZWJ1Z0luZm8uY29uY2F0KGRlYnVnSW5mbykpO1xuICAgICAgcmV0dXJuIHByZXZpb3VzRGVidWdJbmZvO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgZmliZXIsIHJldHVybkZpYmVyKSB7XG4gICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5wcm9wcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKFwiY2hpbGRyZW5cIiAhPT0ga2V5ICYmIFwia2V5XCIgIT09IGtleSkge1xuICAgICAgICAgIG51bGwgPT09IGZpYmVyICYmXG4gICAgICAgICAgICAoKGZpYmVyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCAwKSksXG4gICAgICAgICAgICAoZmliZXIuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgKGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcmVkS2V5KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLFxuICAgICAgICAgICAgICAgIGVycm9yZWRLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlciQxO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSQxICYmICh0aGVuYWJsZVN0YXRlJDEgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUkMSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlUmVmKHdvcmtJblByb2dyZXNzLCBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wcm9wcy5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSB2b2lkIDAgIT09IGVsZW1lbnQgPyBlbGVtZW50IDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnQSBSZWFjdCBFbGVtZW50IGZyb20gYW4gb2xkZXIgdmVyc2lvbiBvZiBSZWFjdCB3YXMgcmVuZGVyZWQuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSXQgY2FuIGhhcHBlbiBpZjpcXG4tIE11bHRpcGxlIGNvcGllcyBvZiB0aGUgXCJyZWFjdFwiIHBhY2thZ2UgaXMgdXNlZC5cXG4tIEEgbGlicmFyeSBwcmUtYnVuZGxlZCBhbiBvbGQgY29weSBvZiBcInJlYWN0XCIgb3IgXCJyZWFjdC9qc3gtcnVudGltZVwiLlxcbi0gQSBjb21waWxlciB0cmllcyB0byBcImlubGluZVwiIEpTWCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBydW50aW1lLidcbiAgICAgICAgKTtcbiAgICAgIHJldHVybkZpYmVyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICA6IHJldHVybkZpYmVyKSArXG4gICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gfHxcbiAgICAgICAgKChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPVxuICAgICAgICAgIGludmFsaWRDaGlsZC5kaXNwbGF5TmFtZSB8fCBpbnZhbGlkQ2hpbGQubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgMyA9PT0gcmV0dXJuRmliZXIudGFnXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4gIDwlcz57JXN9PC8lcz5cIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPSBTdHJpbmcoaW52YWxpZENoaWxkKSksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICA8JXM+JXM8LyVzPlwiLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuICAgICAgICAgIG51bGwgPT09IGRlbGV0aW9uc1xuICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgICA6IGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgICAgIGZvciAodmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQua2V5XG4gICAgICAgICAgICA/IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmtleSwgY3VycmVudEZpcnN0Q2hpbGQpXG4gICAgICAgICAgICA6IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmluZGV4LCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICAgIGZpYmVyID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcyk7XG4gICAgICAgIGZpYmVyLmluZGV4ID0gMDtcbiAgICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICAgICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKVxuICAgICAgICAgIHJldHVybiAobmV3RmliZXIuZmxhZ3MgfD0gMTA0ODU3NiksIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgICAgbmV3SW5kZXggPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXdJbmRleClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5ld0luZGV4ID0gbmV3SW5kZXguaW5kZXgpLFxuICAgICAgICAgICAgbmV3SW5kZXggPCBsYXN0UGxhY2VkSW5kZXhcbiAgICAgICAgICAgICAgPyAoKG5ld0ZpYmVyLmZsYWdzIHw9IDMzNTU0NDM0KSwgbGFzdFBsYWNlZEluZGV4KVxuICAgICAgICAgICAgICA6IG5ld0luZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpO1xuICAgICAgICByZXR1cm4gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDYgIT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGVsZW1lbnQua2V5XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBjdXJyZW50LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoY3VycmVudC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHxcbiAgICAgICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSB8fFxuICAgICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIGNhbGxMYXp5SW5pdEluREVWKGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpKSxcbiAgICAgICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIDQgIT09IGN1cnJlbnQudGFnIHx8XG4gICAgICAgICAgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgICAgICBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcykpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA3ICE9PSBjdXJyZW50LnRhZylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgIFwiXCIgKyBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgX3ByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBjcmVhdGVDaGlsZChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBrZXkgPSBudWxsICE9PSBvbGRGaWJlciA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG51bGwgIT09IGtleVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgXCJcIiArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkLmtleSA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyAoKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkLmtleSA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBrZXkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAga2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBuZXdJZHgsXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsKSxcbiAgICAgICAgICAgIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3SWR4ID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBleGlzdGluZ0NoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbzc7XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChuZXdJZHggPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBleGlzdGluZ0NoaWxkcmVuKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoX3ByZXZEZWJ1Z0luZm83ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cykge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkIHx8IG51bGwgPT09IGNoaWxkKSByZXR1cm4ga25vd25LZXlzO1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2Yga2V5KSBicmVhaztcbiAgICAgICAgICAgIGlmIChudWxsID09PSBrbm93bktleXMpIHtcbiAgICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKHdvcmtJblByb2dyZXNzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuIEtleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCBcXHUyMDE0IHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uXCIsXG4gICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgKGNoaWxkID0gY2FsbExhenlJbml0SW5ERVYoY2hpbGQpKSxcbiAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZEtleShyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGwsXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBudWxsLFxuICAgICAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgbmV3SWR4KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKSxcbiAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KSxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gb2xkRmliZXIpIHtcbiAgICAgICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKylcbiAgICAgICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcykpLFxuICAgICAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJlxuICAgICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBvbGRGaWJlciksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG9sZEZpYmVyID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpO1xuICAgICAgICAgIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKG51bGwgPT0gbmV3Q2hpbGRyZW4pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuXCIpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBudWxsLFxuICAgICAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyID0gbnVsbCxcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG51bGwsXG4gICAgICAgICAgICBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmICFzdGVwLmRvbmU7XG4gICAgICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgICAgIG51bGwgPT09IG9sZEZpYmVyICYmIChvbGRGaWJlciA9IG5leHRPbGRGaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3RmliZXIsXG4gICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBvbGRGaWJlciAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChuZXdGaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCk7XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXIpO1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcC5kb25lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSlcbiAgICAgICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcykpLFxuICAgICAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJlxuICAgICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBvbGRGaWJlciksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG9sZEZpYmVyID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpO1xuICAgICAgICAgICFzdGVwLmRvbmU7XG4gICAgICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0T2xkRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dE9sZEZpYmVyLmtleSA/IG5ld0lkeCA6IG5leHRPbGRGaWJlci5rZXlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV4dE9sZEZpYmVyKVxuICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5leHRPbGRGaWJlciksXG4gICAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gbmV4dE9sZEZpYmVyKSk7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBvbGRGaWJlci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3Q2hpbGQgJiZcbiAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmXG4gICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ICYmXG4gICAgICAgICAgKHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbnVsbCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgIChuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5ID0gbmV3Q2hpbGQua2V5OyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV3Q2hpbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICg3ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMuX2RlYnVnT3duZXIgPSBuZXdDaGlsZC5fb3duZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbGFuZXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5lbGVtZW50VHlwZSA9PT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0ga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbExhenlJbml0SW5ERVYoa2V5KSA9PT0gY3VycmVudEZpcnN0Q2hpbGQudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgICAgICA6ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyID0gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IHByZXZEZWJ1Z0luZm8ua2V5O1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IG5ld0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgNCA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmNvbnRhaW5lckluZm8gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmNoaWxkcmVuIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGtleSA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGtleSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBrZXkuY2FsbChuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGRyZW4gPT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAwICE9PSByZXR1cm5GaWJlci50YWcgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0dXJuRmliZXIudHlwZSkgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkcmVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyB8fFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFlvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAhMCk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbmV3Q2hpbGQuZW50cmllcyAhPT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWFwcyB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzID0gITApKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IFwiXCIgKyBuZXdDaGlsZCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZCAmJiA2ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWdcbiAgICAgICAgICAgICAgPyAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCBwcmV2RGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgIDogKGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSksXG4gICAgICAgICAgICBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuICAgICAgICAgIHZhciBmaXJzdENoaWxkRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZEZpYmVyO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgaWYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB0aHJvdyB4O1xuICAgICAgICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKDI5LCB4LCBudWxsLCByZXR1cm5GaWJlci5tb2RlKTtcbiAgICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICAgICAgICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSAoZmliZXIuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pO1xuICAgICAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgaWYgKG51bGwgIT0gZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSlcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkZWJ1Z0luZm9baV0uc3RhY2spIHtcbiAgICAgICAgICAgICAgICBmaWJlci5fZGVidWdPd25lciA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhpZGRlbkNvbnRleHQoZmliZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgPSBlbnRhbmdsZWRSZW5kZXJMYW5lcztcbiAgICAgIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgfCBjb250ZXh0LmJhc2VMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayhmaWJlcikge1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gICAgICBwdXNoKFxuICAgICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLFxuICAgICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIaWRkZW5Db250ZXh0KGZpYmVyKSB7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50O1xuICAgICAgcG9wKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaGFuZGxlci5hbHRlcm5hdGU7XG4gICAgICBwdXNoKFxuICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLFxuICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayxcbiAgICAgICAgaGFuZGxlclxuICAgICAgKTtcbiAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGhhbmRsZXIsIGhhbmRsZXIpO1xuICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeSAmJlxuICAgICAgICAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICA/IChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcilcbiAgICAgICAgICA6IG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJiAoc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICAgICAgaWYgKDIyID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpLFxuICAgICAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoc2hlbGxCb3VuZGFyeSA9IGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcikge1xuICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLFxuICAgICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50LFxuICAgICAgICBmaWJlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBwb3Aoc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHNoZWxsQm91bmRhcnkgPT09IGZpYmVyICYmIChzaGVsbEJvdW5kYXJ5ID0gbnVsbCk7XG4gICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gcm93OyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgaWYgKDEzID09PSBub2RlLnRhZykge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBzdGF0ZSAmJlxuICAgICAgICAgICAgKChzdGF0ZSA9IHN0YXRlLmRlaHlkcmF0ZWQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc3RhdGUgfHxcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdGF0ZSkgfHxcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3RhdGUpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIDE5ID09PSBub2RlLnRhZyAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICgwICE9PSAobm9kZS5mbGFncyAmIDEyOCkpIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKG51bGwgIT09IG5vZGUuY2hpbGQpIHtcbiAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHJvdykgYnJlYWs7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gcm93KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG4gICAgICBudWxsID09PSBob29rVHlwZXNEZXZcbiAgICAgICAgPyAoaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXSlcbiAgICAgICAgOiBob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBob29rVHlwZXNEZXYgJiZcbiAgICAgICAgKGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2KyssXG4gICAgICAgIGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICAgIG51bGwgIT09IGhvb2tUeXBlc0RldilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yICh2YXIgdGFibGUgPSBcIlwiLCBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV0sXG4gICAgICAgICAgICAgIG5ld0hvb2tOYW1lID1cbiAgICAgICAgICAgICAgICBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBvbGRIb29rTmFtZSA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7XG4gICAgICAgICAgICAgIDMwID4gb2xkSG9va05hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIG9sZEhvb2tOYW1lICs9IFwiIFwiO1xuICAgICAgICAgICAgb2xkSG9va05hbWUgKz0gbmV3SG9va05hbWUgKyBcIlxcblwiO1xuICAgICAgICAgICAgdGFibGUgKz0gb2xkSG9va05hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiBUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4gICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiVzICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuXCIsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAgICAgIHZvaWQgMCA9PT0gZGVwcyB8fFxuICAgICAgICBudWxsID09PSBkZXBzIHx8XG4gICAgICAgIGlzQXJyYXlJbXBsKGRlcHMpIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiBzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LlwiLFxuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgIHR5cGVvZiBkZXBzXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgICAgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAoZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnVzZUZvcm1TdGF0ZSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlYWN0LnVzZUFjdGlvblN0YXRlLiBQbGVhc2UgdXBkYXRlICVzIHRvIHVzZSBSZWFjdC51c2VBY3Rpb25TdGF0ZS5cIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykgcmV0dXJuICExO1xuICAgICAgaWYgKG51bGwgPT09IHByZXZEZXBzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXZcbiAgICAgICAgICApLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICBuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG5QcmV2aW91czogJXNcXG5JbmNvbWluZzogJXNcIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICBcIltcIiArIHByZXZEZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiLFxuICAgICAgICAgIFwiW1wiICsgbmV4dERlcHMuam9pbihcIiwgXCIpICsgXCJdXCJcbiAgICAgICAgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgbmV4dFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgfHxcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudClcbiAgICAgIClcbiAgICAgICAgKG5leHRSZW5kZXJMYW5lcyA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgICApKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMobmV4dFJlbmRlckxhbmVzKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmFkZChuZXh0UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSBTZXJ2ZXIgQ29tcG9uZW50cy4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDA7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICA6IG51bGwgIT09IGhvb2tUeXBlc0RldlxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gbmV4dFJlbmRlckxhbmVzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSAhPT0gTm9Nb2RlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmXG4gICAgICAgIChjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgKSk7XG4gICAgICBpZiAobmV4dFJlbmRlckxhbmVzKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHNlY29uZEFyZ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgPyBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgICAgZmlyc3RDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgICAgIH0pXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcy5fZGVidWdUaGVuYWJsZVN0YXRlID0gdGhlbmFibGVTdGF0ZSk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiYgbnVsbCAhPT0gY3VycmVudEhvb2submV4dDtcbiAgICAgIHJlbmRlckxhbmVzID0gMDtcbiAgICAgIGhvb2tUeXBlc0RldiA9XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID1cbiAgICAgICAgICBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MCkgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDMxNDU3MjgwKSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2Ugbm90aWZ5IHRoZSBSZWFjdCB0ZWFtLlwiXG4gICAgICAgICk7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCBlYXJseSByZXR1cm4gc3RhdGVtZW50LlwiXG4gICAgICAgICk7XG4gICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQpICYmXG4gICAgICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVZcbiAgICAgICAgPyAoKG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITEpLCAoY3VycmVudCA9ICEwKSlcbiAgICAgICAgOiAoY3VycmVudCA9ICExKTtcbiAgICAgIGN1cnJlbnQgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImB1c2VgIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSB0cnkvY2F0Y2ggYmxvY2suIFRoaXMgaXMgbm90IGFsbG93ZWQgYW5kIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFRvIGhhbmRsZSBlcnJvcnMgdHJpZ2dlcmVkIGJ5IGB1c2VgLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGEgZXJyb3IgYm91bmRhcnkuXCJcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJiAodGhlbmFibGVTdGF0ZSA9IG51bGwpO1xuICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gITE7XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBjaGlsZHJlbi5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICBjaGlsZHJlbi5ldmVudHMgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLnN0b3JlcyA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZHJlbi5tZW1vQ2FjaGUgJiYgKGNoaWxkcmVuLm1lbW9DYWNoZS5pbmRleCA9IDApO1xuICAgICAgICB9XG4gICAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5ILFxuICAgICAgICBtYXliZVRoZW5hYmxlID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgbWF5YmVUaGVuYWJsZSA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlVGhlbmFibGUudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUobWF5YmVUaGVuYWJsZSlcbiAgICAgICAgICA6IG1heWJlVGhlbmFibGU7XG4gICAgICBkaXNwYXRjaGVyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgKG51bGwgIT09IGN1cnJlbnRIb29rID8gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGwpICE9PVxuICAgICAgICBkaXNwYXRjaGVyICYmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDEwMjQpO1xuICAgICAgcmV0dXJuIG1heWJlVGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAgICAgdmFyIGRpZFJlbmRlcklkSG9vayA9IDAgIT09IGxvY2FsSWRDb3VudGVyO1xuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPVxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlXG4gICAgICAgICAgPyB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC0yMDEzMjg2NDVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTIwNTM7XG4gICAgICBjdXJyZW50LmxhbmVzICY9IH5sYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy5xdWV1ZTtcbiAgICAgICAgICBudWxsICE9PSBxdWV1ZSAmJiAocXVldWUucGVuZGluZyA9IG51bGwpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB9XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBjdXJyZW50SG9vayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIHZhciBob29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgICAgICBiYXNlU3RhdGU6IG51bGwsXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50SG9vaykge1xuICAgICAgICB2YXIgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9XG4gICAgICAgICAgbnVsbCAhPT0gbmV4dEN1cnJlbnRIb29rID8gbmV4dEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgfSBlbHNlIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICAgIGlmIChudWxsICE9PSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKVxuICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vayksXG4gICAgICAgICAgKGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAobnVsbCA9PT0gbmV4dEN1cnJlbnRIb29rKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVXBkYXRlIGhvb2sgY2FsbGVkIG9uIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPSB7XG4gICAgICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICAgICAgICBuZXh0Q3VycmVudEhvb2spXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgdGhlbmFibGUgPSB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgICAgaW5kZXggPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgbnVsbCA9PT1cbiAgICAgICAgKG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQpICYmXG4gICAgICAgICgoaW5kZXggPSBpbmRleC5hbHRlcm5hdGUpLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICAgICAgbnVsbCAhPT0gaW5kZXggJiYgbnVsbCAhPT0gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVikpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gICAgICBpZiAobnVsbCAhPT0gdXNhYmxlICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1c2FibGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKSByZXR1cm4gdXNlVGhlbmFibGUodXNhYmxlKTtcbiAgICAgICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiBcIiArIFN0cmluZyh1c2FibGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgICAgIHZhciBtZW1vQ2FjaGUgPSBudWxsLFxuICAgICAgICB1cGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsICE9PSB1cGRhdGVRdWV1ZSAmJiAobWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlKTtcbiAgICAgIGlmIChudWxsID09IG1lbW9DYWNoZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vQ2FjaGUpLFxuICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIChtZW1vQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY3VycmVudC5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICBudWxsID09IG1lbW9DYWNoZSAmJiAobWVtb0NhY2hlID0geyBkYXRhOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgICBudWxsID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICAgICAoKHVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZSkpO1xuICAgICAgdXBkYXRlUXVldWUubWVtb0NhY2hlID0gbWVtb0NhY2hlO1xuICAgICAgdXBkYXRlUXVldWUgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdXBkYXRlUXVldWUgfHwgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdID0gQXJyYXkoc2l6ZSksXG4gICAgICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgICAgICBjdXJyZW50IDwgc2l6ZTtcbiAgICAgICAgICBjdXJyZW50KytcbiAgICAgICAgKVxuICAgICAgICAgIHVwZGF0ZVF1ZXVlW2N1cnJlbnRdID0gUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTDtcbiAgICAgIGVsc2VcbiAgICAgICAgdXBkYXRlUXVldWUubGVuZ3RoICE9PSBzaXplICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSBjb25zdGFudCBzaXplIGFyZ3VtZW50IGZvciBlYWNoIGludm9jYXRpb24gb2YgdXNlTWVtb0NhY2hlLiBUaGUgcHJldmlvdXMgY2FjaGUgd2FzIGFsbG9jYXRlZCB3aXRoIHNpemUgJXMgYnV0IHNpemUgJXMgd2FzIHJlcXVlc3RlZC5cIixcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgIHNpemVcbiAgICAgICAgICApO1xuICAgICAgbWVtb0NhY2hlLmluZGV4Kys7XG4gICAgICByZXR1cm4gdXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb24gPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gaW5pdCkge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaW5pdGlhbFN0YXRlID0gaW5pdGlhbEFyZztcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgcmVkdWNlciA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgICAgaG9vay5xdWV1ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gcmVkdWNlci5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICByZWR1Y2VyXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHJlZHVjZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50LCByZWR1Y2VyKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBiYXNlUXVldWUgPSBob29rLmJhc2VRdWV1ZSxcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcGVuZGluZ1F1ZXVlID0gaG9vay5iYXNlU3RhdGU7XG4gICAgICBpZiAobnVsbCA9PT0gYmFzZVF1ZXVlKSBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSAoYmFzZUZpcnN0ID0gbnVsbCksXG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGwsXG4gICAgICAgICAgdXBkYXRlID0gY3VycmVudCxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lICYgLTUzNjg3MDkxMztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZVxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcmV2ZXJ0TGFuZSlcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3QmFzZVF1ZXVlTGFzdCAmJlxuICAgICAgICAgICAgICAgIChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID1cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKChyZW5kZXJMYW5lcyAmIHJldmVydExhbmUpID09PSByZXZlcnRMYW5lKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgICByZXZlcnRMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodXBkYXRlTGFuZSA9IHtcbiAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSByZXZlcnRMYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgJiZcbiAgICAgICAgICAgICAgcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlID0gdXBkYXRlLmhhc0VhZ2VyU3RhdGVcbiAgICAgICAgICAgICAgPyB1cGRhdGUuZWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA6IHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChyZXZlcnRMYW5lID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdXBkYXRlICYmIHVwZGF0ZSAhPT0gY3VycmVudCk7XG4gICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICA/IChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpXG4gICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3QpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIW9iamVjdElzKHBlbmRpbmdRdWV1ZSwgaG9vay5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICgoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uICYmXG4gICAgICAgICAgICAoKHJlZHVjZXIgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUpLCBudWxsICE9PSByZWR1Y2VyKSlcbiAgICAgICAgKVxuICAgICAgICAgIHRocm93IHJlZHVjZXI7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgaG9vay5iYXNlU3RhdGUgPSBiYXNlRmlyc3Q7XG4gICAgICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICB9XG4gICAgICBudWxsID09PSBiYXNlUXVldWUgJiYgKHF1ZXVlLmxhbmVzID0gMCk7XG4gICAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcXVldWUuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoLFxuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nLFxuICAgICAgICBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGUgPSAobGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQpO1xuICAgICAgICBkb1xuICAgICAgICAgIChuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIHVwZGF0ZS5hY3Rpb24pKSwgKHVwZGF0ZSA9IHVwZGF0ZS5uZXh0KTtcbiAgICAgICAgd2hpbGUgKHVwZGF0ZSAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKTtcbiAgICAgICAgb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBudWxsID09PSBob29rLmJhc2VRdWV1ZSAmJiAoaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZSk7XG4gICAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICBuZXh0U25hcHNob3QgPT09IGdldFNlcnZlclNuYXBzaG90KCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IHx8XG4gICAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLFxuICAgICAgICAgIG9iamVjdElzKG5leHRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKSk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSB7IHZhbHVlOiBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9O1xuICAgICAgaG9vay5xdWV1ZSA9IGdldFNlcnZlclNuYXBzaG90O1xuICAgICAgbW91bnRFZmZlY3QoXG4gICAgICAgIHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgZ2V0U2VydmVyU25hcHNob3QsIHN1YnNjcmliZSksXG4gICAgICAgIFtzdWJzY3JpYmVdXG4gICAgICApO1xuICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgIG5leHRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgICApLFxuICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwID0gaXNIeWRyYXRpbmc7XG4gICAgICBpZiAoaXNIeWRyYXRpbmckanNjb21wJDApIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk1pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICgoZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpKSwgIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIG9iamVjdElzKGdldFNlcnZlclNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKGNhY2hlZFNuYXBzaG90ID0gIW9iamVjdElzKFxuICAgICAgICAgIChjdXJyZW50SG9vayB8fCBob29rKS5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkpXG4gICAgICApXG4gICAgICAgIChob29rLm1lbW9pemVkU3RhdGUgPSBnZXRTZXJ2ZXJTbmFwc2hvdCksIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgaG9vayA9IGhvb2sucXVldWU7XG4gICAgICB2YXIgY3JlYXRlID0gc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBob29rLCBzdWJzY3JpYmUpO1xuICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIFtzdWJzY3JpYmVdKTtcbiAgICAgIGlmIChcbiAgICAgICAgaG9vay5nZXRTbmFwc2hvdCAhPT0gZ2V0U25hcHNob3QgfHxcbiAgICAgICAgY2FjaGVkU25hcHNob3QgfHxcbiAgICAgICAgKG51bGwgIT09IHdvcmtJblByb2dyZXNzSG9vayAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdClcbiAgICAgICkge1xuICAgICAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgICAgICBwdXNoRWZmZWN0KFxuICAgICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgaG9vayxcbiAgICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgICApLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCB8fFxuICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gICAgICBmaWJlci5mbGFncyB8PSAxNjM4NDtcbiAgICAgIGZpYmVyID0geyBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90IH07XG4gICAgICBnZXRTbmFwc2hvdCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBnZXRTbmFwc2hvdFxuICAgICAgICA/ICgoZ2V0U25hcHNob3QgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gZ2V0U25hcHNob3QpLFxuICAgICAgICAgIChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKSlcbiAgICAgICAgOiAoKHJlbmRlcmVkU25hcHNob3QgPSBnZXRTbmFwc2hvdC5zdG9yZXMpLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlcmVkU25hcHNob3RcbiAgICAgICAgICAgID8gKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pXG4gICAgICAgICAgICA6IHJlbmRlcmVkU25hcHNob3QucHVzaChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gICAgICBpbnN0LnZhbHVlID0gbmV4dFNuYXBzaG90O1xuICAgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90O1xuICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICAgICAgaW5zdCA9IGluc3QudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIGhvb2sucXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSk7XG4gICAgICB2YXIgcXVldWUgPSBpbml0aWFsU3RhdGUucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgICBxdWV1ZVxuICAgICAgICApO1xuICAgICAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgdmFyIHF1ZXVlID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBudWxsXG4gICAgICB9O1xuICAgICAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgaG9vayA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICEwLFxuICAgICAgICBxdWV1ZVxuICAgICAgKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gaG9vaztcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnQsIHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vayxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVkdWNlciA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRIb29rKVxuICAgICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rLnF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHBheWxvYWRcbiAgICApIHtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGZvcm0gc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgIGZpYmVyID0gYWN0aW9uUXVldWUuYWN0aW9uO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgIHZhciBhY3Rpb25Ob2RlID0ge1xuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgYWN0aW9uOiBmaWJlcixcbiAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgIGlzVHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGFjdGlvbk5vZGUubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVFxuICAgICAgICAgID8gc2V0UGVuZGluZ1N0YXRlKCEwKVxuICAgICAgICAgIDogKGFjdGlvbk5vZGUuaXNUcmFuc2l0aW9uID0gITEpO1xuICAgICAgICBzZXRTdGF0ZShhY3Rpb25Ob2RlKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgICAgbnVsbCA9PT0gc2V0UGVuZGluZ1N0YXRlXG4gICAgICAgICAgPyAoKGFjdGlvbk5vZGUubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKSlcbiAgICAgICAgICA6ICgoYWN0aW9uTm9kZS5uZXh0ID0gc2V0UGVuZGluZ1N0YXRlLm5leHQpLFxuICAgICAgICAgICAgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCA9IGFjdGlvbk5vZGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5vZGUpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbixcbiAgICAgICAgcGF5bG9hZCA9IG5vZGUucGF5bG9hZCxcbiAgICAgICAgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGU7XG4gICAgICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQuX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCksXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblF1ZXVlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgICAgIDEwIDwgYWN0aW9uUXVldWUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIChjdXJyZW50VHJhbnNpdGlvbiA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpKSxcbiAgICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCBjdXJyZW50VHJhbnNpdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yJDIpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvciQyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgPyAocmV0dXJuVmFsdWUudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgbm9kZS5pc1RyYW5zaXRpb24gfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQW4gYXN5bmMgZnVuY3Rpb24gd2FzIHBhc3NlZCB0byB1c2VBY3Rpb25TdGF0ZSwgYnV0IGl0IHdhcyBkaXNwYXRjaGVkIG91dHNpZGUgb2YgYW4gYWN0aW9uIGNvbnRleHQuIFRoaXMgaXMgbGlrZWx5IG5vdCB3aGF0IHlvdSBpbnRlbmRlZC4gRWl0aGVyIHBhc3MgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIHRvIGFuIGBhY3Rpb25gIHByb3AsIG9yIGRpc3BhdGNoIG1hbnVhbGx5IGluc2lkZSBgc3RhcnRUcmFuc2l0aW9uYFwiXG4gICAgICAgICAgICApKVxuICAgICAgICA6IG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIG5leHRTdGF0ZSkge1xuICAgICAgYWN0aW9uTm9kZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKTtcbiAgICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsICE9PSBhY3Rpb25Ob2RlICYmXG4gICAgICAgICgobmV4dFN0YXRlID0gYWN0aW9uTm9kZS5uZXh0KSxcbiAgICAgICAgbmV4dFN0YXRlID09PSBhY3Rpb25Ob2RlXG4gICAgICAgICAgPyAoYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGwpXG4gICAgICAgICAgOiAoKG5leHRTdGF0ZSA9IG5leHRTdGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLm5leHQgPSBuZXh0U3RhdGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5leHRTdGF0ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgZXJyb3IpIHtcbiAgICAgIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3QpIHtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgZG9cbiAgICAgICAgICAoYWN0aW9uTm9kZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUucmVhc29uID0gZXJyb3IpLFxuICAgICAgICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLm5leHQpO1xuICAgICAgICB3aGlsZSAoYWN0aW9uTm9kZSAhPT0gbGFzdCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSkge1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubGlzdGVuZXJzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25Ob2RlLmxlbmd0aDsgaSsrKSAoMCwgYWN0aW9uTm9kZVtpXSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCkge1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciBzc3JGb3JtU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuZm9ybVN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3NyRm9ybVN0YXRlKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIGlzTWF0Y2hpbmcgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlckluc3RhbmNlID0gY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlcihcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobWFya2VySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgaXNNYXRjaGluZyA9IGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcobWFya2VySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGlzTWF0Y2hpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNNYXRjaGluZyA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hdGNoaW5nICYmIChpbml0aWFsU3RhdGVQcm9wID0gc3NyRm9ybVN0YXRlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3NyRm9ybVN0YXRlID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHNzckZvcm1TdGF0ZS5tZW1vaXplZFN0YXRlID0gc3NyRm9ybVN0YXRlLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZVByb3A7XG4gICAgICBpc01hdGNoaW5nID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgICAgIH07XG4gICAgICBzc3JGb3JtU3RhdGUucXVldWUgPSBpc01hdGNoaW5nO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBpc01hdGNoaW5nXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZy5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICB2YXIgc2V0UGVuZGluZ1N0YXRlID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgITEsXG4gICAgICAgIGlzTWF0Y2hpbmcucXVldWVcbiAgICAgICk7XG4gICAgICBpc01hdGNoaW5nID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIG1hcmtlckluc3RhbmNlID0ge1xuICAgICAgICBzdGF0ZTogaW5pdGlhbFN0YXRlUHJvcCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBwZW5kaW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgaXNNYXRjaGluZy5xdWV1ZSA9IG1hcmtlckluc3RhbmNlO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBtYXJrZXJJbnN0YW5jZSxcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlLFxuICAgICAgICBzc3JGb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBtYXJrZXJJbnN0YW5jZS5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlUHJvcCwgc3NyRm9ybVN0YXRlLCAhMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRIb29rLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgc3RhdGVIb29rLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rLFxuICAgICAgICBhY3Rpb25TdGF0ZVJlZHVjZXJcbiAgICAgIClbMF07XG4gICAgICBzdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPVxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUoY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgICA6IGN1cnJlbnRTdGF0ZUhvb2s7XG4gICAgICB2YXIgYWN0aW9uUXVldWVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoO1xuICAgICAgYWN0aW9uICE9PSBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKTtcbiAgICAgIHJldHVybiBbY3VycmVudFN0YXRlSG9vaywgZGlzcGF0Y2gsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGN1cnJlbnRTdGF0ZUhvb2sucXVldWUuZGlzcGF0Y2g7XG4gICAgICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gICAgICByZXR1cm4gW3N0YXRlSG9vaywgZGlzcGF0Y2gsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICAgICAgdGFnID0geyB0YWc6IHRhZywgY3JlYXRlOiBjcmVhdGUsIGluc3Q6IGluc3QsIGRlcHM6IGRlcHMsIG5leHQ6IG51bGwgfTtcbiAgICAgIGNyZWF0ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBjcmVhdGUgJiZcbiAgICAgICAgKChjcmVhdGUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNyZWF0ZSkpO1xuICAgICAgaW5zdCA9IGNyZWF0ZS5sYXN0RWZmZWN0O1xuICAgICAgbnVsbCA9PT0gaW5zdFxuICAgICAgICA/IChjcmVhdGUubGFzdEVmZmVjdCA9IHRhZy5uZXh0ID0gdGFnKVxuICAgICAgICA6ICgoZGVwcyA9IGluc3QubmV4dCksXG4gICAgICAgICAgKGluc3QubmV4dCA9IHRhZyksXG4gICAgICAgICAgKHRhZy5uZXh0ID0gZGVwcyksXG4gICAgICAgICAgKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnKSk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH07XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIGluc3QgPSBob29rLm1lbW9pemVkU3RhdGUuaW5zdDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmXG4gICAgICBudWxsICE9PSBkZXBzICYmXG4gICAgICBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgICAgICA/IChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBkZXBzKSlcbiAgICAgICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoXG4gICAgICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgICAgICBjcmVhdGUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZGVwc1xuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiA2NCkgPT09IE5vTW9kZVxuICAgICAgICA/IG1vdW50RWZmZWN0SW1wbCgxNDI2MDgzODQsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcylcbiAgICAgICAgOiBtb3VudEVmZmVjdEltcGwoODM5MDY1NiwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgIHZhciByZWZDbGVhbnVwID0gcmVmKGNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cCA/IHJlZkNsZWFudXAoKSA6IHJlZihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSByZWYgJiYgdm9pZCAwICE9PSByZWYpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgcmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICAgIFwiYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhyZWYpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjcmVhdGUgPSBjcmVhdGUoKSksXG4gICAgICAgICAgKHJlZi5jdXJyZW50ID0gY3JlYXRlKSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgbnVsbCAhPT0gY3JlYXRlID8gdHlwZW9mIGNyZWF0ZSA6IFwibnVsbFwiXG4gICAgICAgICk7XG4gICAgICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICAgICAgdmFyIGZpYmVyRmxhZ3MgPSA0MTk0MzA4O1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgIG1vdW50RWZmZWN0SW1wbChcbiAgICAgICAgZmliZXJGbGFncyxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoXG4gICAgICAgIDQsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgIF07XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBkZXBzXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgcHJldlN0YXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbcHJldlN0YXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50SG9va1xuICAgICAgICA/IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSlcbiAgICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGluaXRpYWxWYWx1ZSB8fCAwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSlcbiAgICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoaG9vayA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkpLFxuICAgICAgICAgIG9iamVjdElzKGhvb2ssIHByZXZWYWx1ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgaG9va1xuICAgICAgICApO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIDQyKSlcbiAgICAgICAgcmV0dXJuIChkaWRSZWNlaXZlVXBkYXRlID0gITApLCAoaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWUpO1xuICAgICAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShcbiAgICAgICAgMCAhPT0gcHJldmlvdXNQcmlvcml0eSAmJiA4ID4gcHJldmlvdXNQcmlvcml0eSA/IHByZXZpb3VzUHJpb3JpdHkgOiA4XG4gICAgICApO1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCAhMSwgcXVldWUsIHBlbmRpbmdTdGF0ZSk7XG4gICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCksXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSA9IGNoYWluVGhlbmFibGVWYWx1ZShcbiAgICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgICAgZmluaXNoZWRTdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICBmaW5pc2hlZFN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICB7IHRoZW46IGZ1bmN0aW9uICgpIHt9LCBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiBlcnJvciB9LFxuICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgIDEwIDwgZmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikge1xuICAgICAgdmFyIGV4aXN0aW5nU3RhdGVIb29rID0gZm9ybUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZXhpc3RpbmdTdGF0ZUhvb2spIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICB2YXIgaW5pdGlhbFJlc2V0U3RhdGUgPSB7fTtcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rLm5leHQgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgICBmb3JtRmliZXIgPSBmb3JtRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZm9ybUZpYmVyICYmIChmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rKTtcbiAgICAgIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBzdGF0ZUhvb2sucXVldWUsXG4gICAgICAgICEwLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgICAgIHJldHVybiBbITEsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF0sXG4gICAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICAgIHN0YXJ0XG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChIb3N0VHJhbnNpdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudElkKCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gd29ya0luUHJvZ3Jlc3NSb290LmlkZW50aWZpZXJQcmVmaXg7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHRyZWVJZCA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICAgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAoXG4gICAgICAgICAgICBpZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8ICgzMiAtIGNsejMyKGlkV2l0aExlYWRpbmdCaXQpIC0gMSkpXG4gICAgICAgICAgKS50b1N0cmluZygzMikgKyB0cmVlSWQ7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcIlJcIiArIHRyZWVJZDtcbiAgICAgICAgdHJlZUlkID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgMCA8IHRyZWVJZCAmJiAoaWRlbnRpZmllclByZWZpeCArPSBcIkhcIiArIHRyZWVJZC50b1N0cmluZygzMikpO1xuICAgICAgICBpZGVudGlmaWVyUHJlZml4ICs9IFwiOlwiO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlSWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKyksXG4gICAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggPVxuICAgICAgICAgICAgXCI6XCIgKyBpZGVudGlmaWVyUHJlZml4ICsgXCJyXCIgKyB0cmVlSWQudG9TdHJpbmcoMzIpICsgXCI6XCIpO1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWZyZXNoKCkge1xuICAgICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSkge1xuICAgICAgZm9yICh2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47IG51bGwgIT09IHByb3ZpZGVyOyApIHtcbiAgICAgICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgIG51bGwgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaWJlci5wYXlsb2FkID0geyBjYWNoZTogcHJvdmlkZXIgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgKTtcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgbGFuZTogSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwLFxuICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKVxuICAgICAgICA/IGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgYWN0aW9uKVxuICAgICAgICA6ICgoYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IGFjdGlvbiAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihcbiAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKFxuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICAgICkpKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb24sXG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICApIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICAgICk7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAgICAgKG51bGwgPT09IGFsdGVybmF0ZSB8fCAwID09PSBhbHRlcm5hdGUubGFuZXMpICYmXG4gICAgICAgICAgKChhbHRlcm5hdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyKSwgbnVsbCAhPT0gYWx0ZXJuYXRlKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlID0gYWx0ZXJuYXRlKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIDApLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICB0aHJvd0lmRHVyaW5nUmVuZGVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgMCA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIG9wdGltaXN0aWMgc3RhdGUgdXBkYXRlIG9jY3VycmVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRoZSB1cGRhdGUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBhY3Rpb24gPSB7XG4gICAgICAgIGxhbmU6IDIsXG4gICAgICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICAgICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBjYWxsIHN0YXJ0VHJhbnNpdGlvbiB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJvd0lmRHVyaW5nUmVuZGVyID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAyXG4gICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IHRocm93SWZEdXJpbmdSZW5kZXIgJiZcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcih0aHJvd0lmRHVyaW5nUmVuZGVyLCBmaWJlciwgMik7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHxcbiAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwO1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gICAgICBpZiAoMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIHF1ZXVlLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuICAgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkgfHxcbiAgICAgICAgICAoZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgIG5leHRQcm9wc1xuICAgICkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICAoKGN0b3IgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY3RvcikgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjdG9yKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICApKSk7XG4gICAgICBwcmV2U3RhdGUgPVxuICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICA/IHByZXZTdGF0ZVxuICAgICAgICAgIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBvbGRQcm9wcyA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICBuZXh0Q29udGV4dFxuICAgICAgICApO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZvaWQgMCA9PT0gb2xkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBvbGRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudFxuICAgICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkpLFxuICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuICAgICAgaWYgKFwicmVmXCIgaW4gYmFzZVByb3BzKSB7XG4gICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoKENvbXBvbmVudCA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHMpKSB7XG4gICAgICAgIG5ld1Byb3BzID09PSBiYXNlUHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcykpO1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gQ29tcG9uZW50KVxuICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBDb21wb25lbnRbX3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICAgICAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2VcbiAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSk7XG4gICAgICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgICAgICBvbkNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgICAgZXJyb3JCb3VuZGFyeTogMSA9PT0gYm91bmRhcnkudGFnID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgICAgIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBsYW5lLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gICAgICBsYW5lLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgICAgIGxhbmUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UsIGxvZ1VuY2F1Z2h0RXJyb3IsIHJvb3QsIGVycm9ySW5mbyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGluc3QgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAodXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWRcbiAgICAgICAgICAgICAgPyAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFt0aGlzXSkpXG4gICAgICAgICAgICAgIDogbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKHRoaXMpKTtcbiAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFVih0aGlzLCBlcnJvckluZm8pO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgKDAgPT09IChmaWJlci5sYW5lcyAmIDIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiBJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKFxuICAgICAgcm9vdCxcbiAgICAgIHJldHVybkZpYmVyLFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gMzI3Njg7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCk7XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgaWYgKG51bGwgIT09IHNvdXJjZUZpYmVyKSB7XG4gICAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgICAgICAgPyByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKClcbiAgICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiByZXR1cm5GaWJlci5hZGQodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySW5zdGFuY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt2YWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICA6ICgoc291cmNlRmliZXIgPSByZXR1cm5GaWJlci5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKHJldHVybkZpYmVyLnJldHJ5UXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNvdXJjZUZpYmVyLmFkZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0h5ZHJhdGluZylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCksXG4gICAgICAgICAgKHJldHVybkZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgID8gKDAgPT09IChyZXR1cm5GaWJlci5mbGFncyAmIDY1NTM2KSAmJiAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMjU2KSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgdmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIGZyb20gdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6ICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAocm9vdCA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICAocm9vdC5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgJj0gLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyb290LmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcikpLFxuICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHJvb3Quc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkKSksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHZhciBlcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICBFcnJvcihcbiAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgY29uY3VycmVudCByZW5kZXJpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBzeW5jaHJvbm91c2x5IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuXCIsXG4gICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICApLFxuICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgKTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl0pXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZCk7XG4gICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHJldHVybiAhMDtcbiAgICAgIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgIHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXI7XG4gICAgICBkbyB7XG4gICAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJvb3QgPSByb290UmVuZGVyTGFuZXMgJiAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3QpLFxuICAgICAgICAgICAgICAocm9vdCA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290KSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudHlwZSksXG4gICAgICAgICAgICAgIChlcnJvciA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIDAgPT09IChzb3VyY2VGaWJlci5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAobnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZXJyb3IuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhlcnJvcikpKSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gc291cmNlRmliZXIpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9XG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBpZiAoXCJyZWZcIiBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV4dFByb3BzKVxuICAgICAgICAgIFwicmVmXCIgIT09IGtleSAmJiAocHJvcHNXaXRob3V0UmVmW2tleV0gPSBuZXh0UHJvcHNba2V5XSk7XG4gICAgICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgICAgIHJlZixcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBrZXkgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYga2V5ICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gQ29tcG9uZW50LmNvbXBhcmVcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoQ29tcG9uZW50ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCksXG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHR5cGUpLFxuICAgICAgICAgICAgdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgQ29tcG9uZW50LnR5cGUsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBpZiAoIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSkge1xuICAgICAgICB2YXIgcHJldlByb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgICAgICBDb21wb25lbnQgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICAgICAgQ29tcG9uZW50ID0gbnVsbCAhPT0gQ29tcG9uZW50ID8gQ29tcG9uZW50IDogc2hhbGxvd0VxdWFsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgQ29tcG9uZW50KHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWZcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIGN1cnJlbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyh0eXBlLCBuZXh0UHJvcHMpO1xuICAgICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZVxuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcyksXG4gICAgICAgICAgICBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzEwNzIpICYmIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMiksXG4gICAgICAgIHByZXZTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAoXCJoaWRkZW5cIiA9PT0gbmV4dFByb3BzLm1vZGUgfHwgbmV4dElzRGV0YWNoZWQpIHtcbiAgICAgICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpIHtcbiAgICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgIDogcmVuZGVyTGFuZXM7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICAgICAgICAgIGZvciAobmV4dElzRGV0YWNoZWQgPSAwOyBudWxsICE9PSBuZXh0Q2hpbGRyZW47IClcbiAgICAgICAgICAgICAgKG5leHRJc0RldGFjaGVkID1cbiAgICAgICAgICAgICAgICBuZXh0SXNEZXRhY2hlZCB8IG5leHRDaGlsZHJlbi5sYW5lcyB8IG5leHRDaGlsZHJlbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgICAobmV4dENoaWxkcmVuID0gbmV4dENoaWxkcmVuLnNpYmxpbmcpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IG5leHRJc0RldGFjaGVkICYgfm5leHRQcm9wcztcbiAgICAgICAgICB9IGVsc2UgKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSwgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpKVxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0geyBiYXNlTGFuZXM6IDAsIGNhY2hlUG9vbDogbnVsbCB9KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgcHVzaFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICA/IHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpXG4gICAgICAgICAgICAgIDogcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgICAgIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgPyAocHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZS5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSlcbiAgICAgICAgICA6IChudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dEJhc2VMYW5lcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgICAgICAgICAgICBwb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsICEwKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKG51bGwgPT09IHJlZilcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQucmVmICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZWYgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgdW5kZWZpbmVkL251bGwuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIDggJiZcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAodmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKSkpKTtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIG5leHRQcm9wcyAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgc2Vjb25kQXJnXG4gICAgICApO1xuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgQ29tcG9uZW50ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIENvbXBvbmVudCAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAoc2hvdWxkRXJyb3JJbXBsKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICBjYXNlICExOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyB3b3JrSW5Qcm9ncmVzcy50eXBlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UuY29udGV4dFxuICAgICAgICAgICAgKS5zdGF0ZTtcbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgITA6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY1NTM2O1xuICAgICAgICAgIF9pbnN0YW5jZSA9IEVycm9yKFwiU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzXCIpO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgfD0gbGFuZTtcbiAgICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGFuZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSk7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGxhbmUpO1xuICAgICAgfVxuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBcImNvbnRleHRUeXBlXCIgaW4gQ29tcG9uZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gX2luc3RhbmNlIHx8IF9pbnN0YW5jZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gX2luc3RhbmNlXG4gICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gdHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLlwiXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiAhPT0gdHlwZW9mIF9pbnN0YW5jZVxuICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgXCIgKyB0eXBlb2YgX2luc3RhbmNlICsgXCIuXCJcbiAgICAgICAgICAgICAgICA6IF9pbnN0YW5jZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRVxuICAgICAgICAgICAgICAgICAgPyBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/XCJcbiAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2luc3RhbmNlKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIn0uXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICBsYW5lXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfaW5zdGFuY2UgJiZcbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChfaW5zdGFuY2UpKTtcbiAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgc3RhdGUpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlLnN0YXRlICYmIHZvaWQgMCAhPT0gX2luc3RhbmNlLnN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBfaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIF9pbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBzdGF0ZSAmJlxuICAgICAgICAgICgoc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiBUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBudWxsID09PSBfaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gKGxhbmUgPSBzdGF0ZSA9IG51bGwpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChzdGF0ZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIChzdGF0ZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAobGFuZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAobGFuZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZSB8fCBudWxsICE9PSBsYW5lIHx8IG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUpIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfaW5zdGFuY2UpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfaW5zdGFuY2UpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gc3RhdGUgPyBcIlxcbiAgXCIgKyBzdGF0ZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbGFuZSA/IFwiXFxuICBcIiArIGxhbmUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogXCJcIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgIF9pbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAoQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLlwiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAhX2luc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgIF9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgfHxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICFfaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICkpO1xuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiBQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgdXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgcnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIGxhbmUgPSBfaW5zdGFuY2UucHJvcHMgIT09IG5leHRQcm9wcztcbiAgICAgICAgdm9pZCAwICE9PSBfaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICBsYW5lICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgdXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoQ29tcG9uZW50KSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KVxuICAgICAgICAgICkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgKGxhbmUgPSBfaW5zdGFuY2Uuc3RhdGUpICYmXG4gICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBsYW5lIHx8IGlzQXJyYXlJbXBsKGxhbmUpKSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgc3RhdGUpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnJlZnMgPSB7fTtcbiAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygc3RhdGUgJiYgbnVsbCAhPT0gc3RhdGVcbiAgICAgICAgICAgID8gcmVhZENvbnRleHQoc3RhdGUpXG4gICAgICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID09PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChzdGF0ZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiA4ICYmXG4gICAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN0YXRlICYmXG4gICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICksXG4gICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAoKHN0YXRlID0gX2luc3RhbmNlLnN0YXRlKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgc3RhdGUgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KTtcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCk7XG4gICAgICAgIF9pbnN0YW5jZSA9ICEwO1xuICAgICAgfSBlbHNlIGlmIChudWxsID09PSBjdXJyZW50JGpzY29tcCQwKSB7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGxhbmUgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGxhbmU7XG4gICAgICAgIHZhciBvbGRDb250ZXh0ID0gX2luc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIHN0YXRlID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZm91bmRXaWxsVXBkYXRlTmFtZSAmJlxuICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChmb3VuZFdpbGxVcGRhdGVOYW1lKSk7XG4gICAgICAgIG5ld0FwaU5hbWUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID1cbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdBcGlOYW1lIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgIT09IHVucmVzb2x2ZWRPbGRQcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB8fFxuICAgICAgICAgICgodW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZENvbnRleHQgIT09IHN0YXRlKSAmJlxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkU3RhdGUgIT09IG9sZENvbnRleHQgfHwgaGFzRm9yY2VVcGRhdGVcbiAgICAgICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdBcGlOYW1lICYmXG4gICAgICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgICAgICAobGFuZSA9XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvbGRDb250ZXh0KSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBvbGRDb250ZXh0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IHN0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBsYW5lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9ICExKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCRqc2NvbXAkMCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHN0YXRlKTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gZm91bmRXaWxsVXBkYXRlTmFtZTtcbiAgICAgICAgbmV3QXBpTmFtZSA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgb2xkU3RhdGUgPSBfaW5zdGFuY2UuY29udGV4dDtcbiAgICAgICAgb2xkQ29udGV4dCA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgbGFuZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9sZENvbnRleHQgJiZcbiAgICAgICAgICBudWxsICE9PSBvbGRDb250ZXh0ICYmXG4gICAgICAgICAgKGxhbmUgPSByZWFkQ29udGV4dChvbGRDb250ZXh0KSk7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIChvbGRDb250ZXh0ID1cbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAgICAgKChzdGF0ZSAhPT0gbmV3QXBpTmFtZSB8fCBvbGRTdGF0ZSAhPT0gbGFuZSkgJiZcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgICBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc3RhdGUgIT09IG5ld0FwaU5hbWUgfHxcbiAgICAgICAgb2xkU3RhdGUgIT09IG5ld1N0YXRlIHx8XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgIChudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMpKVxuICAgICAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyAmJlxuICAgICAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPVxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMpKSlcbiAgICAgICAgICAgICAgPyAob2xkQ29udGV4dCB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5ld1N0YXRlLCBsYW5lKSxcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpKVxuICAgICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZSkpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gbmV3U3RhdGUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5jb250ZXh0ID0gbGFuZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gZm91bmRXaWxsVXBkYXRlTmFtZSkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSAhMSkpO1xuICAgICAgfVxuICAgICAgbGFuZSA9IF9pbnN0YW5jZTtcbiAgICAgIG1hcmtSZWYoY3VycmVudCRqc2NvbXAkMCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3RhdGUgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgaWYgKGxhbmUgfHwgc3RhdGUpIHtcbiAgICAgICAgbGFuZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID1cbiAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcyA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGlmIChzdGF0ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKVxuICAgICAgICAgIChDb21wb25lbnQgPSBudWxsKSwgKHByb2ZpbGVyU3RhcnRUaW1lID0gLTEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgQ29tcG9uZW50ID0gY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiYgc3RhdGVcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAuY2hpbGQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSkpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBsYW5lLnN0YXRlO1xuICAgICAgICBjdXJyZW50JGpzY29tcCQwID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY3VycmVudCRqc2NvbXAkMCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBfaW5zdGFuY2UgJiZcbiAgICAgICAgcmVuZGVyTGFuZXMucHJvcHMgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJhIGNvbXBvbmVudFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQkanNjb21wJDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI1NjtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAgICAgIENvbXBvbmVudCAmJlxuICAgICAgICBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbiAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi5cIixcbiAgICAgICAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W3dvcmtJblByb2dyZXNzXSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdID1cbiAgICAgICAgICAgICEwKSkpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICBudWxsICE9PSBDb21wb25lbnQuY29udGV4dFR5cGUgJiZcbiAgICAgICAgKChDb21wb25lbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtDb21wb25lbnRdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgQ29tcG9uZW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gPSAhMCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4geyBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLCBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICBjdXJyZW50LFxuICAgICAgcHJpbWFyeVRyZWVEaWREZWZlcixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuY2hpbGRMYW5lcyAmIH5yZW5kZXJMYW5lcyA6IDA7XG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyICYmIChjdXJyZW50IHw9IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCh3b3JrSW5Qcm9ncmVzcykgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICB2YXIgc2hvd0ZhbGxiYWNrID0gITEsXG4gICAgICAgIGRpZFN1c3BlbmQgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpLFxuICAgICAgICBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAoSlNDb21waWxlcl90ZW1wID0gZGlkU3VzcGVuZCkgfHxcbiAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gITFcbiAgICAgICAgICAgIDogMCAhPT0gKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpO1xuICAgICAgSlNDb21waWxlcl90ZW1wICYmICgoc2hvd0ZhbGxiYWNrID0gITApLCAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTEyOSkpO1xuICAgICAgSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzIpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTMzO1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICA/IHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gIW5leHRJbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICB0cmVlQ29udGV4dDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB0cmVlQ29udGV4dFByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IHRyZWVDb250ZXh0SWQsIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlMYW5lOiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQgPSBjcmVhdGVGaWJlcigxOCwgbnVsbCwgbnVsbCwgTm9Nb2RlKSksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZC5zdGF0ZU5vZGUgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gZGlkU3VzcGVuZCksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICEwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhMSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSk7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgKHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICgobmV4dEluc3RhbmNlID0gbmV4dEluc3RhbmNlLmRlaHlkcmF0ZWQpLCBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sobmV4dEluc3RhbmNlKVxuICAgICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMTYpXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluc3RhbmNlID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgICBuZXh0UHJvcHMgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICAgIGlmIChzaG93RmFsbGJhY2spXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgICAgICB7IG1vZGU6IFwiaGlkZGVuXCIsIGNoaWxkcmVuOiBuZXh0SW5zdGFuY2UgfSxcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlLnNpYmxpbmcgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwICYmXG4gICAgICAgICgobmV4dEluc3RhbmNlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLmRlaHlkcmF0ZWQpLFxuICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRpZFN1c3BlbmQpXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTZcbiAgICAgICAgICAgID8gKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICAgICAgICA6IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgICAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbiB9LFxuICAgICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBzaG93RmFsbGJhY2spKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sobmV4dEluc3RhbmNlKSlcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPVxuICAgICAgICAgICAgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKG5leHRJbnN0YW5jZSkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IG5leHRJbnN0YW5jZS5kaWdlc3QpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRJbnN0YW5jZS5tZXNzYWdlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBuZXh0SW5zdGFuY2Uuc3RhY2spLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZS5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICAgID8gRXJyb3Ioc2hvd0ZhbGxiYWNrKVxuICAgICAgICAgICAgICA6IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5IGR1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5zdGFjayA9IG5leHRQcm9wcyB8fCBcIlwiKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSB2b2lkIDAgPT09IG5leHRJbnN0YW5jZSA/IG51bGwgOiBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgICBzdGFjazogSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KHNob3dGYWxsYmFjaywgbmV4dFByb3BzKSxcbiAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IobmV4dFByb3BzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IDAgIT09IChyZW5kZXJMYW5lcyAmIGN1cnJlbnQuY2hpbGRMYW5lcykpLFxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHwgSlNDb21waWxlcl90ZW1wKVxuICAgICAgICApIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCkge1xuICAgICAgICAgICAgbmV4dFByb3BzID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIDQyKSkgbmV4dFByb3BzID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3dpdGNoIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgICAgIGNhc2UgMjU2OlxuICAgICAgICAgICAgICAgIGNhc2UgNTEyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICAgICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICAgICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgICAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgICAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgICAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gNjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDEzNDIxNzcyODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgICAgICAwICE9PSAobmV4dFByb3BzICYgKEpTQ29tcGlsZXJfdGVtcC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IG5leHRQcm9wcztcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgMCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgIG5leHRQcm9wcyAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnJldHJ5TGFuZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0cnlMYW5lID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCwgbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoSlNDb21waWxlcl90ZW1wLCBjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0SW5zdGFuY2UpIHx8XG4gICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KG5leHRJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgICAgIDogKChjdXJyZW50ID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnRyZWVDb250ZXh0KSxcbiAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSkpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkKSxcbiAgICAgICAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlciksXG4gICAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGN1cnJlbnQuaWQpLFxuICAgICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBjdXJyZW50Lm92ZXJmbG93KSxcbiAgICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5NikpO1xuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAoZGlkU3VzcGVuZCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zaWJsaW5nKSxcbiAgICAgICAgICAobmV4dFByb3BzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLCB7XG4gICAgICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICAobmV4dFByb3BzLnN1YnRyZWVGbGFncyA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRcbiAgICAgICAgICAgID8gKHNob3dGYWxsYmFjayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGRpZFN1c3BlbmQsIHNob3dGYWxsYmFjaykpXG4gICAgICAgICAgICA6ICgoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgKG5leHRQcm9wcyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICBudWxsID09PSBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgID8gKG5leHRJbnN0YW5jZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA6ICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gbmV4dEluc3RhbmNlLmNhY2hlUG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgID8gKChkaWRTdXNwZW5kID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnBhcmVudCAhPT0gZGlkU3VzcGVuZFxuICAgICAgICAgICAgICAgICAgICAgID8geyBwYXJlbnQ6IGRpZFN1c3BlbmQsIHBvb2w6IGRpZFN1c3BlbmQgfVxuICAgICAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBnZXRTdXNwZW5kZWRDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBiYXNlTGFuZXM6IG5leHRJbnN0YW5jZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgKHNob3dGYWxsYmFjay5tZW1vaXplZFN0YXRlID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICk7XG4gICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVuZGVyTGFuZXMgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzLnNpYmxpbmc7XG4gICAgICByZW5kZXJMYW5lcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCB7XG4gICAgICAgIG1vZGU6IFwidmlzaWJsZVwiLFxuICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICB9KTtcbiAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoSlNDb21waWxlcl90ZW1wID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zKSxcbiAgICAgICAgbnVsbCA9PT0gSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wLnB1c2goY3VycmVudCkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlbmRlckxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pIHtcbiAgICAgIHByaW1hcnlDaGlsZHJlbiA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlbiB9LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlXG4gICAgICApO1xuICAgICAgcHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBjdXJyZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICAgIGN1cnJlbnQuZmxhZ3MgfD0gMjtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5SW1wbChjaGlsZFNsb3QpO1xuICAgICAgY2hpbGRTbG90ID0gIWlzQW5BcnJheSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCk7XG4gICAgICByZXR1cm4gaXNBbkFycmF5IHx8IGNoaWxkU2xvdFxuICAgICAgICA/ICgoaXNBbkFycmF5ID0gaXNBbkFycmF5ID8gXCJhcnJheVwiIDogXCJpdGVyYWJsZVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiBhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uIDwvU3VzcGVuc2VMaXN0PlwiLFxuICAgICAgICAgICAgaXNBbkFycmF5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpc0FuQXJyYXlcbiAgICAgICAgICApLFxuICAgICAgICAgICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGlzQmFja3dhcmRzLFxuICAgICAgdGFpbCxcbiAgICAgIGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbE1vZGVcbiAgICApIHtcbiAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZVxuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAoKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzID0gaXNCYWNrd2FyZHMpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMCksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLmxhc3QgPSBsYXN0Q29udGVudFJvdyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcixcbiAgICAgICAgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgdm9pZCAwICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcImZvcndhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwidG9nZXRoZXJcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXVxuICAgICAgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSAhMCksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJldmVhbE9yZGVyKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkc1wiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFVzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZFwiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFJlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICB2b2lkIDAgPT09IHRhaWxNb2RlIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSB8fFxuICAgICAgICAoXCJjb2xsYXBzZWRcIiAhPT0gdGFpbE1vZGUgJiYgXCJoaWRkZW5cIiAhPT0gdGFpbE1vZGVcbiAgICAgICAgICA/ICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICA6IFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICAgICAoKGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuIERpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgYTogaWYgKFxuICAgICAgICAoXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fCBcImJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlcikgJiZcbiAgICAgICAgdm9pZCAwICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICExICE9PSBuZXh0UHJvcHNcbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5leHRQcm9wcykpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChuZXh0UHJvcHNbaV0sIGkpKSBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChpID0gZ2V0SXRlcmF0b3JGbihuZXh0UHJvcHMpKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpIHtcbiAgICAgICAgICBpZiAoKGkgPSBpLmNhbGwobmV4dFByb3BzKSkpXG4gICAgICAgICAgICBmb3IgKHZhciBzdGVwID0gaS5uZXh0KCksIF9pID0gMDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGkubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuIERpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICBuZXh0UHJvcHMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpXG4gICAgICAgIChuZXh0UHJvcHMgPVxuICAgICAgICAgIChuZXh0UHJvcHMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIGlmICgxOSA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLnJldHVybiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgIGZvciAoOyBudWxsID09PSBjdXJyZW50LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudC5yZXR1cm4gfHwgY3VycmVudC5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuc2libGluZy5yZXR1cm4gPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICBuZXh0UHJvcHMgJj0gU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG4gICAgICB9XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIGZvciAocmV2ZWFsT3JkZXIgPSBudWxsOyBudWxsICE9PSByZW5kZXJMYW5lczsgKVxuICAgICAgICAgICAgKGN1cnJlbnQgPSByZW5kZXJMYW5lcy5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpICYmXG4gICAgICAgICAgICAgICAgKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICA/ICgocmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpKVxuICAgICAgICAgICAgOiAoKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMuc2libGluZyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbCkpO1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSBudWxsO1xuICAgICAgICAgIHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7IG51bGwgIT09IHJldmVhbE9yZGVyOyApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuc2libGluZztcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgICByZXZlYWxPcmRlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITAsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgITEsIG51bGwsIG51bGwsIHZvaWQgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcztcbiAgICAgIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgIHRocm93IEVycm9yKFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBmb3IgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzOyBudWxsICE9PSBjdXJyZW50LnNpYmxpbmc7IClcbiAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nID1cbiAgICAgICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpKSByZXR1cm4gITA7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCAmJiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgPyAhMCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4O1xuICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkLmNoaWxkTGFuZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG4gICAgICAgICAgc3RhdGVOb2RlIHx8XG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpKTtcbiAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpZFN1c3BlbmRCZWZvcmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRCZWZvcmUgJiZcbiAgICAgICAgICAgICgoZGlkU3VzcGVuZEJlZm9yZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLnRhaWwgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLmxhc3RFZmZlY3QgPSBudWxsKSk7XG4gICAgICAgICAgcHVzaChcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN0YXRlTm9kZSkgYnJlYWs7XG4gICAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMCksXG4gICAgICAgICAgICB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDYWNoZUNvbnRleHQsXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Mua2V5LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHRocm93IEVycm9yKFwiQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuXCIpO1xuICAgICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHJlbmRlckxhbmVzLmluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIHJlbmRlckxhbmVzLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgcmVuZGVyTGFuZXMuX2RlYnVnSW5mbyA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpXG4gICAgICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLlwiKTtcbiAgICAgICAgICBmb3IgKDsgcHJldlNpYmxpbmcuc2libGluZyAhPT0gd29ya0luUHJvZ3Jlc3M7IClcbiAgICAgICAgICAgIGlmICgoKHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZyksIG51bGwgPT09IHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLlwiKTtcbiAgICAgICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICByZW5kZXJMYW5lcy5mbGFncyB8PSAyO1xuICAgICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzIHx8XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgPyAhMCA6ICExO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgICAgICBpZiAoKHJldHVybkZpYmVyID0gaXNIeWRyYXRpbmcpKVxuICAgICAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTA0ODU3NikpO1xuICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICgocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5pbmRleCksXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdHJlZUZvcmtDb3VudCwgcmV0dXJuRmliZXIpKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgYTogaWYgKFxuICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgICBzaG91bGRDb25zdHJ1Y3QoY3VycmVudClcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IGN1cnJlbnQuJCR0eXBlb2YpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U2libGluZyA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgXCIgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT9cIik7XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN1cnJlbnQpIHx8IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICtcbiAgICAgICAgICAgICAgICBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgK1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICBwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHByZXZTaWJsaW5nLmVsZW1lbnQ7XG4gICAgICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgbmV4dFByb3BzICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNIeWRyYXRpb24gJiYgcHJldlNpYmxpbmcuaXNEZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGlzRGVoeWRyYXRlZDogITEsXG4gICAgICAgICAgICAgICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyAhPT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlIGh5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICgobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwKSksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoY3VycmVudC5mbGFncyA9IChjdXJyZW50LmZsYWdzICYgLTMpIHwgNDA5NiksXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChuZXh0UHJvcHMgPT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKGN1cnJlbnQgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICA6IGlzSHlkcmF0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0UmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gcmVxdWlyZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyKSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHByZXZTaWJsaW5nKSkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50IHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgICAgICAgPyByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKG5leHRQcm9wcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIXByZXZTaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAgICgobmV4dFN0YXRlID0gY2FuSHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKChuZXh0UHJvcHMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRTdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9ICEwKSlcbiAgICAgICAgICAgICAgICAgIDogKG5leHRQcm9wcyA9ICExKSxcbiAgICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIW5leHRQcm9wcykpLFxuICAgICAgICAgICAgICBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGwpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbmV4dFByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0UHJvcHMpXG4gICAgICAgICAgICAgID8gKHJldHVybkZpYmVyID0gbnVsbClcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChwcmV2U2libGluZywgbmV4dFN0YXRlKSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAzMiksXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgICAgIDogKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChyZXR1cm5GaWJlciA9ICExKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIuZWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gcHJldlNpYmxpbmcudmFsdWUpLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiIGluIHByZXZTaWJsaW5nIHx8XG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIHx8XG4gICAgICAgICAgICAgICgoaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/XCJcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHJldHVybkZpYmVyLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBwcmV2U2libGluZy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZWFkQ29udGV4dChwcmV2U2libGluZykpLFxuICAgICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gY2FsbENvbXBvbmVudEluREVWKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHBlZWtDYWNoZUZyb21Qb29sKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3NSb290KSxcbiAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZSA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgOiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgICAgICAgIChjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpKSxcbiAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZy5wYXJlbnQgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jYWNoZSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdGhyb3cgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyAocHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlKSxcbiAgICAgICAgICBwdXNoKHJlbmRlcmVyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gY29udGV4dC5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbCkpXG4gICAgICAgIDogKHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlKSxcbiAgICAgICAgICBwdXNoKHJlbmRlcmVyMkN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgdm9pZCAwICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0LCBwcm92aWRlckZpYmVyKSB7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gKChjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWUpLFxuICAgICAgICAgIChjdXJyZW50VmFsdWUgPSByZW5kZXJlckN1cnNvckRFVi5jdXJyZW50KSxcbiAgICAgICAgICBwb3AocmVuZGVyZXJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBjdXJyZW50VmFsdWUpKVxuICAgICAgICA6ICgoY29udGV4dC5fY3VycmVudFZhbHVlMiA9IGN1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9IHJlbmRlcmVyMkN1cnNvckRFVi5jdXJyZW50KSxcbiAgICAgICAgICBwb3AocmVuZGVyZXIyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgIHBhcmVudCxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICA/ICgocGFyZW50LmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcykpXG4gICAgICAgICAgOiBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHByb3BhZ2F0aW9uUm9vdCkgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJlbnQgIT09IHByb3BhZ2F0aW9uUm9vdCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJvcGFnYXRpb24gcm9vdCB3aGVuIHNjaGVkdWxpbmcgY29udGV4dCB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjb250ZXh0cyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gZmliZXI7ICkge1xuICAgICAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcbiAgICAgICAgaWYgKG51bGwgIT09IGxpc3QpIHtcbiAgICAgICAgICB2YXIgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgbGlzdCA9IGxpc3QuZmlyc3RDb250ZXh0O1xuICAgICAgICAgIGE6IGZvciAoOyBudWxsICE9PSBsaXN0OyApIHtcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdDtcbiAgICAgICAgICAgIGxpc3QgPSBmaWJlcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gbGlzdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gZGVwZW5kZW5jeSAmJiAoZGVwZW5kZW5jeS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgICAgICAgICAgIGxpc3QucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIHx8IChuZXh0RmliZXIgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgxOCA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXh0RmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJXZSBqdXN0IGNhbWUgZnJvbSBhIHBhcmVudCBzbyB3ZSBtdXN0IGhhdmUgaGFkIGEgcGFyZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG5leHRGaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgICAgICBsaXN0ID0gbmV4dEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBsaXN0ICYmIChsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgbmV4dEZpYmVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV4dEZpYmVyKSBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG5leHRGaWJlciA9IGZpYmVyOyBudWxsICE9PSBuZXh0RmliZXI7ICkge1xuICAgICAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWJlciA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgICAgICAgIGZpYmVyLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICkge1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgcGFyZW50ID0gd29ya0luUHJvZ3Jlc3MsIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITE7XG4gICAgICAgIG51bGwgIT09IHBhcmVudDtcblxuICAgICAgKSB7XG4gICAgICAgIGlmICghaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQpXG4gICAgICAgICAgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiA1MjQyODgpKSBpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCA9ICEwO1xuICAgICAgICAgIGVsc2UgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiAyNjIxNDQpKSBicmVhaztcbiAgICAgICAgaWYgKDEwID09PSBwYXJlbnQudGFnKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50LnR5cGU7XG4gICAgICAgICAgICBvYmplY3RJcyhwYXJlbnQucGVuZGluZ1Byb3BzLnZhbHVlLCBjdXJyZW50UGFyZW50LnZhbHVlKSB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gY3VycmVudC5wdXNoKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiAoY3VycmVudCA9IFtjb250ZXh0XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgPT09IGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCkge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRTdGF0ZS5tZW1vaXplZFN0YXRlICE9PVxuICAgICAgICAgICAgcGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyBjdXJyZW50LnB1c2goSG9zdFRyYW5zaXRpb25Db250ZXh0KVxuICAgICAgICAgICAgICA6IChjdXJyZW50ID0gW0hvc3RUcmFuc2l0aW9uQ29udGV4dF0pKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjYyMTQ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudERlcGVuZGVuY2llcykge1xuICAgICAgZm9yIChcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RGVwZW5kZW5jaWVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMoXG4gICAgICAgICAgICBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLm1lbW9pemVkVmFsdWVcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgKHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dCA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gICAgICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAmJiBwcmVwYXJlVG9SZWFkQ29udGV4dChjb25zdW1lcik7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gY29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgIDogY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgIGNvbnRleHQgPSB7IGNvbnRleHQ6IGNvbnRleHQsIG1lbW9pemVkVmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsIH07XG4gICAgICBpZiAobnVsbCA9PT0gbGFzdENvbnRleHREZXBlbmRlbmN5KSB7XG4gICAgICAgIGlmIChudWxsID09PSBjb25zdW1lcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgICApO1xuICAgICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0O1xuICAgICAgICBjb25zdW1lci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3VtZXIuZmxhZ3MgfD0gNTI0Mjg4O1xuICAgICAgfSBlbHNlIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyTG9jYWwoKSxcbiAgICAgICAgZGF0YTogbmV3IE1hcCgpLFxuICAgICAgICByZWZDb3VudDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0YWluQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmV0YWluZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgY2FjaGUucmVmQ291bnQrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZUNhY2hlKGNhY2hlKSB7XG4gICAgICBjYWNoZS5yZWZDb3VudC0tO1xuICAgICAgMCA+IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkEgY2FjaGUgaW5zdGFuY2Ugd2FzIHJlbGVhc2VkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiBUaGlzIGxpa2VseSBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIDAgPT09IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICAgICAgdmFyIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciA9IHJlc3VtZWRDYWNoZS5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgIT09IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA/IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdC5wb29sZWRDYWNoZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpIHtcbiAgICAgIG51bGwgPT09IHByZXZDYWNoZVBvb2xcbiAgICAgICAgPyBwdXNoKHJlc3VtZWRDYWNoZSwgcmVzdW1lZENhY2hlLmN1cnJlbnQsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKVxuICAgICAgICA6IHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gICAgICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY2FjaGVGcm9tUG9vbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB7XG4gICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gICAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkKSByZXR1cm4gITE7XG4gICAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAxNikpIHJldHVybiAhMDtcbiAgICAgIGZvciAoY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzg3OCkgfHxcbiAgICAgICAgICAwICE9PSAoY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4oXG4gICAgICBwYXJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbilcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGU7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgNSA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgNiA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZ1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgNCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnKVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGQucmV0dXJuID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuIHx8XG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zaWJsaW5nLnJldHVybiA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpXG4gICAgICAgIGZvciAodmFyIF9ub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IF9ub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gX25vZGUudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBfbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIF9ub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBfbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBfbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBfbm9kZS50YWcpXG4gICAgICAgICAgICBpZiAoMjIgPT09IF9ub2RlLnRhZyAmJiBudWxsICE9PSBfbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5jaGlsZCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiYgKGluc3RhbmNlLnJldHVybiA9IF9ub2RlKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIF9ub2RlLCAhMCwgITApO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gX25vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgX25vZGUuY2hpbGQucmV0dXJuID0gX25vZGU7XG4gICAgICAgICAgICAgIF9ub2RlID0gX25vZGUuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChfbm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBfbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBfbm9kZS5yZXR1cm4gfHwgX25vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgX25vZGUgPSBfbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ub2RlLnNpYmxpbmcucmV0dXJuID0gX25vZGUucmV0dXJuO1xuICAgICAgICAgIF9ub2RlID0gX25vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKFxuICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSlcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gbm9kZS50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIG5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBub2RlLnRhZylcbiAgICAgICAgICAgIGlmICgyMiA9PT0gbm9kZS50YWcgJiYgbnVsbCAhPT0gbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBub2RlLmNoaWxkKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJiAoaW5zdGFuY2UucmV0dXJuID0gbm9kZSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5vZGUubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBcIm1hbnVhbFwiID09PSBub2RlLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT09IG5vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHJldHVybjtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiYgZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGN1cnJlbnQuY29udGFpbmVySW5mbyxcbiAgICAgICAgICBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7XG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLCAhMSwgITEpO1xuICAgICAgICBjdXJyZW50LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpIHtcbiAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGUsXG4gICAgICAgICAgX29sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGN1cnJlbnQgPSBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSkgfHxcbiAgICAgICAgICBfb2xkUHJvcHMgIT09IG5ld1Byb3BzXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIF9vbGRQcm9wcyA9IGNsb25lSW5zdGFuY2UoXG4gICAgICAgICAgICBjdXJyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgX29sZFByb3BzLFxuICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAhY3VycmVudCxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICAgIF9vbGRQcm9wcyA9PT0gY3VycmVudEluc3RhbmNlXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2UpXG4gICAgICAgICAgICA6IChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihcbiAgICAgICAgICAgICAgICBfb2xkUHJvcHMsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHRcbiAgICAgICAgICAgICAgKSAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9vbGRQcm9wcyksXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGFwcGVuZEFsbENoaWxkcmVuKF9vbGRQcm9wcywgd29ya0luUHJvZ3Jlc3MsICExLCAhMSlcbiAgICAgICAgICAgICAgICA6IG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKG1heVN1c3BlbmRDb21taXQodHlwZSwgcHJvcHMpKSB7XG4gICAgICAgIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcykpKVxuICAgICAgICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UpIHtcbiAgICAgIGlmIChtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQocmVzb3VyY2UpKSB7XG4gICAgICAgIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkpKVxuICAgICAgICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpIHtcbiAgICAgIG51bGwgIT09IHJldHJ5UXVldWUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgICAoKHJldHJ5UXVldWUgPVxuICAgICAgICAgIDIyICE9PSB3b3JrSW5Qcm9ncmVzcy50YWcgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IDUzNjg3MDkxMiksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSByZXRyeVF1ZXVlKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyB8PSByZXRyeVF1ZXVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjazsgKVxuICAgICAgICAgICAgICBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZVxuICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgOiAobGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2xsYXBzZWRcIjpcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gbGFzdFRhaWxOb2RlOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGxhc3RUYWlsTm9kZS5hbHRlcm5hdGUgJiYgKF9sYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUpLFxuICAgICAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUuc2libGluZyk7XG4gICAgICAgICAgICBudWxsID09PSBfbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIHx8IG51bGwgPT09IHJlbmRlclN0YXRlLnRhaWxcbiAgICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsKVxuICAgICAgICAgICAgICA6IChfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIHZhciBkaWRCYWlsb3V0ID1cbiAgICAgICAgICBudWxsICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkLFxuICAgICAgICBuZXdDaGlsZExhbmVzID0gMCxcbiAgICAgICAgc3VidHJlZUZsYWdzID0gMDtcbiAgICAgIGlmIChkaWRCYWlsb3V0KVxuICAgICAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uLFxuICAgICAgICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICAgIG51bGwgIT09IF9jaGlsZDI7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PSBfY2hpbGQyLmxhbmVzIHwgX2NoaWxkMi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgKF9jaGlsZDIgPSBfY2hpbGQyLnNpYmxpbmcpO1xuICAgICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PVxuICAgICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uLnJldHVybiA9IGNvbXBsZXRlZFdvcmspLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGVsc2UgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgX2NoaWxkMiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgICAgZm9yICh2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZDsgKVxuICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9IGNoaWxkLmxhbmVzIHwgY2hpbGQuY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksXG4gICAgICAgICAgICAoX2NoaWxkMiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF9jaGlsZDI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9XG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5zdWJ0cmVlRmxhZ3MpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24ucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgICAgIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG4gICAgICByZXR1cm4gZGlkQmFpbG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChuZXdQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KTtcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCAmJlxuICAgICAgICAgICAgKChyZW5kZXJMYW5lcy5jb250ZXh0ID0gcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ID0gbnVsbCkpO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgPT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgPyAoZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpLCBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgOiBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NikpIHx8XG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpKTtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICAgIHZhciBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgID8gKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6IG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgID8gbmV4dFJlc291cmNlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICAgID8gKG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKVxuICAgICAgICAgICAgICAgIDogKHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgID8gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudClcbiAgICAgICAgICAgICAgICA6ICgoY3VycmVudCA9IHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCBuZXdQcm9wcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgIDogKChuZXh0UmVzb3VyY2UgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IGNyZWF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5leHRSZXNvdXJjZSwgd29ya0luUHJvZ3Jlc3MsICExLCAhMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRSZXNvdXJjZSksXG4gICAgICAgICAgICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgICkgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uXG4gICAgICAgICAgICAgICAgPyByZW5kZXJMYW5lcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA6IHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyAhPT0gbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gICAgICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKS5zZXJ2ZXJQcm9wcyA9IG5leHRSZXNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICkgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBuZXdQcm9wcyAmJiBudWxsICE9PSBuZXdQcm9wcy5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgPyBuZXh0UmVzb3VyY2UuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dFJlc291cmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksXG4gICAgICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9ICExO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSxcbiAgICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gITApO1xuICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLCB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGwgIT09IG5ld1Byb3BzO1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBuZXh0UmVzb3VyY2UgJiYgKG5ld1Byb3BzLmZsYWdzIHw9IDIwNDgpKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZC5mbGFncyB8PSA4MTkyKTtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICBuZXdQcm9wcyA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSBuZXh0UmVzb3VyY2UucmVuZGVyaW5nO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgIGlmIChuZXdQcm9wcykgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcmV0dXJuRmliZXIudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzO1xuXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmXG4gICAgICAgICAgICAgICAgICAgICAgICBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UudGFpbCAmJlxuICAgICAgICAgICAgICAgIG5vdyQxKCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyZXR1cm5GaWJlcikpLCBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICEwKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRSZXNvdXJjZS50YWlsICYmXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZGVuXCIgPT09IG5leHRSZXNvdXJjZS50YWlsTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmV0dXJuRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0h5ZHJhdGluZylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIDIgKiBub3ckMSgpIC0gbmV4dFJlc291cmNlLnJlbmRlcmluZ1N0YXJ0VGltZSA+XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgICA1MzY4NzA5MTIgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UuaXNCYWNrd2FyZHNcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICA6ICgoY3VycmVudCA9IG5leHRSZXNvdXJjZS5sYXN0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICA/IChjdXJyZW50LnNpYmxpbmcgPSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UubGFzdCA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9PSBuZXh0UmVzb3VyY2UudGFpbClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gbmV4dFJlc291cmNlLnRhaWwpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnJlbmRlcmluZyA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnRhaWwgPSBjdXJyZW50LnNpYmxpbmcpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdyQxKCkpLFxuICAgICAgICAgICAgICAoY3VycmVudC5zaWJsaW5nID0gbnVsbCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgPyAocmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSxcbiAgICAgICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MilcbiAgICAgICAgICAgICAgOiBuZXdQcm9wcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICA/IDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgJiZcbiAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyAmIDYgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSlcbiAgICAgICAgICAgICAgOiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICBuZXdQcm9wcyAhPT0gcmVuZGVyTGFuZXMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgK1xuICAgICAgICAgIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQgJiA2NTUzNikgJiYgMCA9PT0gKGN1cnJlbnQgJiAxMjgpXG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaykge1xuICAgICAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrLnR5cGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wSGlkZGVuQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFByb2ZpbGUoY3VycmVudCkge1xuICAgICAgcmV0dXJuIChjdXJyZW50Lm1vZGUgJiAyKSAhPT0gTm9Nb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaG9va0ZsYWdzXG4gICAgKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChsYXN0RWZmZWN0ID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMCksXG4gICAgICAgICAgICAgIChsYXN0RWZmZWN0ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNhbGxDcmVhdGVJbkRFVixcbiAgICAgICAgICAgICAgICB1cGRhdGVRdWV1ZVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSksXG4gICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKClcbiAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gbGFzdEVmZmVjdCAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBsYXN0RWZmZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBob29rTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaG9va05hbWUgPVxuICAgICAgICAgICAgICAgIDAgIT09ICh1cGRhdGVRdWV1ZS50YWcgJiBMYXlvdXQpXG4gICAgICAgICAgICAgICAgICA/IFwidXNlTGF5b3V0RWZmZWN0XCJcbiAgICAgICAgICAgICAgICAgIDogMCAhPT0gKHVwZGF0ZVF1ZXVlLnRhZyAmIEluc2VydGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBcInVzZUluc2VydGlvbkVmZmVjdFwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbGFzdEVmZmVjdFxuICAgICAgICAgICAgICAgICAgPyBcIiBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiB1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuXCJcbiAgICAgICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbGFzdEVmZmVjdC50aGVuXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgaG9va05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiBJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0IGFuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBob29rTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIoKCkgPT4ge1xcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbiAgICAvLyBZb3UgY2FuIGF3YWl0IGhlcmVcXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuICAgIC8vIC4uLlxcbiAgfVxcbiAgZmV0Y2hEYXRhKCk7XFxufSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZ1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgWW91IHJldHVybmVkOiBcIiArIGxhc3RFZmZlY3Q7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAobiwgYSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCIlcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCB3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lc1wiLFxuICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaG9va05hbWUsXG4gICAgICAgICAgICAgICAgYWRkZW5kdW1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgZmxhZ3MsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgICAgICAgIHZhciBpbnN0ID0gdXBkYXRlUXVldWUuaW5zdCxcbiAgICAgICAgICAgICAgICBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IGRlc3Ryb3kgJiZcbiAgICAgICAgICAgICAgICAoKGluc3QuZGVzdHJveSA9IHZvaWQgMCksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICEwKSxcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNhbGxEZXN0cm95SW5ERVYsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgZGVzdHJveVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpXG4gICAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSB1cGRhdGVRdWV1ZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyhpbnN0YW5jZSwgcHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzU25hcHNob3QoZmluaXNoZWRXb3JrLCBjdXJyZW50KSB7XG4gICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgKGN1cnJlbnQucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgKSxcbiAgICAgICAgY3VycmVudC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXNvbHZlZFByZXZQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcmVzb2x2ZWRQcmV2UHJvcHMsXG4gICAgICAgICAgcHJldlN0YXRlXG4gICAgICAgICk7XG4gICAgICAgIHByZXZQcm9wcyA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICB2b2lkIDAgIT09IHNuYXBzaG90IHx8XG4gICAgICAgICAgcHJldlByb3BzLmhhcyhmaW5pc2hlZFdvcmsudHlwZSkgfHxcbiAgICAgICAgICAocHJldlByb3BzLmFkZChmaW5pc2hlZFdvcmsudHlwZSksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgY3VycmVudC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgIGN1cnJlbnQudHlwZSxcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICApO1xuICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBzaG91bGRQcm9maWxlKGN1cnJlbnQpXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFVixcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgICBpZiAobnVsbCAhPT0gcmVmKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIChmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZSkpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZWZcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcIlN0cmluZyByZWZzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLlwiKVxuICAgICAgICAgICAgOiByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiBVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZWYuY3VycmVudCA9IGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIGNvbW1pdEF0dGFjaFJlZiwgY3VycmVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gICAgICB2YXIgcmVmID0gY3VycmVudC5yZWYsXG4gICAgICAgIHJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gICAgICBpZiAobnVsbCAhPT0gcmVmKVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWZDbGVhbnVwKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWZDbGVhbnVwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSlcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZiwgbnVsbCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmLCBudWxsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvciQzKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQcm9maWxlcihcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBlZmZlY3REdXJhdGlvblxuICAgICkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgb25Db21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Db21taXQ7XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25SZW5kZXI7XG4gICAgICBjdXJyZW50ID0gbnVsbCA9PT0gY3VycmVudCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCI7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgJiYgKGN1cnJlbnQgPSBcIm5lc3RlZC11cGRhdGVcIik7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfZmluaXNoZWRXb3JrJG1lbW9pemUgJiZcbiAgICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplKFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvbkNvbW1pdCAmJlxuICAgICAgICBvbkNvbW1pdChcbiAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvblxuICAgICkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgIGZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIuaWQ7XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblBvc3RDb21taXQ7XG4gICAgICBjdXJyZW50ID0gbnVsbCA9PT0gY3VycmVudCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCI7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgJiYgKGN1cnJlbnQgPSBcIm5lc3RlZC11cGRhdGVcIik7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfZmluaXNoZWRXb3JrJG1lbW9pemUyICYmXG4gICAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0TW91bnQsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0VXBkYXRlKGZpbmlzaGVkV29yaywgbmV3UHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0VXBkYXRlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA1ID09PSBmaWJlci50YWcgfHxcbiAgICAgICAgMyA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIChzdXBwb3J0c1Jlc291cmNlcyA/IDI2ID09PSBmaWJlci50YWcgOiAhMSkgfHxcbiAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyA/IDI3ID09PSBmaWJlci50YWcgOiAhMSkgfHxcbiAgICAgICAgNCA9PT0gZmliZXIudGFnXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgICAgYTogZm9yICg7Oykge1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gZmliZXIuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybiB8fCBpc0hvc3RQYXJlbnQoZmliZXIucmV0dXJuKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmliZXIuc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgICAgICAgIDUgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDYgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgPyAyNyAhPT0gZmliZXIudGFnIDogMSkgJiZcbiAgICAgICAgICAxOCAhPT0gZmliZXIudGFnO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChmaWJlci5mbGFncyAmIDIpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLmNoaWxkIHx8IDQgPT09IGZpYmVyLnRhZykgY29udGludWUgYTtcbiAgICAgICAgICBlbHNlIChmaWJlci5jaGlsZC5yZXR1cm4gPSBmaWJlciksIChmaWJlciA9IGZpYmVyLmNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmaWJlci5mbGFncyAmIDIpKSByZXR1cm4gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgICAgICA/IGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlKVxuICAgICAgICAgICAgOiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZSk7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgISg0ID09PSB0YWcgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gdGFnKSkgJiZcbiAgICAgICAgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpXG4gICAgICApXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICBiZWZvcmVcbiAgICAgICAgICAgID8gaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlKVxuICAgICAgICAgICAgOiBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICEoNCA9PT0gdGFnIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IHRhZykpICYmXG4gICAgICAgICgobm9kZSA9IG5vZGUuY2hpbGQpLCBudWxsICE9PSBub2RlKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAoIXN1cHBvcnRzU2luZ2xldG9ucyB8fCAyNyAhPT0gZmluaXNoZWRXb3JrLnRhZylcbiAgICAgICkge1xuICAgICAgICBhOiB7XG4gICAgICAgICAgZm9yICh2YXIgcGFyZW50ID0gZmluaXNoZWRXb3JrLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcGFyZW50RmliZXIuZmxhZ3MgJiAzMiAmJlxuICAgICAgICAgICAgICAocmVzZXRUZXh0Q29udGVudChwYXJlbnQpLCAocGFyZW50RmliZXIuZmxhZ3MgJj0gLTMzKSk7XG4gICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgIHBvcnRhbCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIHBlbmRpbmdDaGlsZHJlblxuICAgICkge1xuICAgICAgcG9ydGFsID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICBwZW5kaW5nQ2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmlyc3RDaGlsZCkge1xuICAgICAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgZm9yIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChyb290ID0gbmV4dEVmZmVjdCksXG4gICAgICAgICAgKGZpcnN0Q2hpbGQgPSByb290LmNoaWxkKSxcbiAgICAgICAgICAwICE9PSAocm9vdC5zdWJ0cmVlRmxhZ3MgJiAxMDI4KSAmJiBudWxsICE9PSBmaXJzdENoaWxkKVxuICAgICAgICApXG4gICAgICAgICAgKGZpcnN0Q2hpbGQucmV0dXJuID0gcm9vdCksIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkID0gcm9vdCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmbGFncyA9IGZpcnN0Q2hpbGQuZmxhZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpcnN0Q2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIDAgIT09IChmbGFncyAmIDEwMjQpICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICBjb21taXRDbGFzc1NuYXBzaG90KGZpcnN0Q2hpbGQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgMCAhPT0gKGZsYWdzICYgMTAyNCkgJiZcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKGZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICgwICE9PSAoZmxhZ3MgJiAxMDI0KSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RDaGlsZCA9IHJvb3Quc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIGZpcnN0Q2hpbGQucmV0dXJuID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSByb290LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICByb290ID0gc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITE7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNClcbiAgICAgICAgICAgIGlmICgoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLCBudWxsID09PSBjdXJyZW50KSlcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkTW91bnQuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkUm9vdC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY3VycmVudCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJldlByb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFdvcmsuY2hpbGQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgcHJldlByb3BzID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvbiArPSBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMoY3VycmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIGZsYWdzICYgNCAmJiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb24gKz0gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2UHJvcHMgPVxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgfHwgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZQcm9wcztcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gY3VycmVudCkgJiZcbiAgICAgICAgICAgICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlblxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAoXCJtYW51YWxcIiA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgICAgICA/IHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pXG4gICAgICAgICAgICAgIDogc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgKChmaWJlci5hbHRlcm5hdGUgPSBudWxsKSwgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKSk7XG4gICAgICBmaWJlci5jaGlsZCA9IG51bGw7XG4gICAgICBmaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICA1ID09PSBmaWJlci50YWcgJiZcbiAgICAgICAgKChhbHRlcm5hdGUgPSBmaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIHBhcmVudFxuICAgICkge1xuICAgICAgZm9yIChwYXJlbnQgPSBwYXJlbnQuY2hpbGQ7IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZGVsZXRlZEZpYmVyXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnRcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgc3dpdGNoIChkZWxldGVkRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IHJlbGVhc2VSZXNvdXJjZShkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgOiBkZWxldGVkRmliZXIuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGhvc3RQYXJlbnQgJiZcbiAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICAgICAgPyBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgID8gKChwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAocHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lciksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSlcbiAgICAgICAgICAgIDogKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24sXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgTGF5b3V0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIChzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSxcbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJldkhvc3RQYXJlbnQuY29tcG9uZW50V2lsbFVubW91bnQgJiZcbiAgICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIHByZXZIb3N0UGFyZW50XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB8fFxuICAgICAgICAgICAgbnVsbCAhPT0gZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICAgICAgcmV0cnlDYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCB3YWtlYWJsZXMpIHtcbiAgICAgIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICAgICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG4gICAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBpblByb2dyZXNzTGFuZXMgJiYgbnVsbCAhPT0gaW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsIGluUHJvZ3Jlc3NMYW5lcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QkanNjb21wJDAsIHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgfSBlbHNlIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgcm9vdCA9IGRlbGV0ZWRGaWJlcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJvb3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmIChyZXR1cm5GaWJlci5yZXR1cm4gPSBudWxsKTtcbiAgICAgICAgICByb290LnJldHVybiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIocGFyZW50RmliZXIsIHJvb3QkanNjb21wJDApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24gfCBIYXNFZmZlY3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVyblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIExheW91dCB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IGZsYWdzIDogY3VycmVudC5jb25jYXQoZmxhZ3MpKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAgICgoZmxhZ3MgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbCksXG4gICAgICAgICAgICAgIChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBudWxsID09PSByb290XG4gICAgICAgICAgICAgICAgICA/IG51bGwgPT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGh5ZHJhdGVIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIDogbW91bnRIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGFjcXVpcmVSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6IGZsYWdzICE9PSByb290XG4gICAgICAgICAgICAgICAgICA/IChudWxsID09PSBmbGFnc1xuICAgICAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gY3VycmVudC5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoY3VycmVudC5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiByZWxlYXNlUmVzb3VyY2UoZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByb290XG4gICAgICAgICAgICAgICAgICAgICAgPyBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IGFjcXVpcmVSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IG51bGwgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjbGVhclNpbmdsZXRvbihob2lzdGFibGVSb290KSxcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIDMyKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgcmVzZXRUZXh0Q29udGVudCwgcm9vdCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcm9vdFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGZsYWdzICYgMTAyNCAmJlxuICAgICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITApLFxuICAgICAgICAgICAgICBcImZvcm1cIiAhPT0gZmluaXNoZWRXb3JrLnR5cGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGhvc3QgY29tcG9uZW50IHR5cGUuIEV4cGVjdGVkIGEgZm9ybS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0ICYmIHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IGZsYWdzO1xuICAgICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZmxhZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMoKSxcbiAgICAgICAgICAgICAgKHByb3BzID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbykpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByb3BzKSlcbiAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdC5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICAgIGZsYWdzID0gcm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gcm9vdC5wZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZWVkc0Zvcm1SZXNldCAmJlxuICAgICAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICExKSwgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKGhvaXN0YWJsZVJvb3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKChjdXJyZW50ID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gY3VycmVudCkpXG4gICAgICAgICAgICA6IChyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBlbmRpbmdDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3ckMSgpKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuLFxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCB3YXNIaWRkZW47XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuX2N1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgcm9vdC5fdmlzaWJpbGl0eSAmPSAtMztcbiAgICAgICAgICByb290Ll92aXNpYmlsaXR5IHw9IHJvb3QuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDgxOTIgJiZcbiAgICAgICAgICAgICgocm9vdC5fdmlzaWJpbGl0eSA9IGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgLTJcbiAgICAgICAgICAgICAgOiByb290Ll92aXNpYmlsaXR5IHwgMSksXG4gICAgICAgICAgICBob2lzdGFibGVSb290ICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICAgIHJvb3QgfHxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspKSxcbiAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgKG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJtYW51YWxcIiAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYTogaWYgKCgoY3VycmVudCA9IG51bGwpLCBzdXBwb3J0c011dGF0aW9uKSlcbiAgICAgICAgICAgICAgZm9yIChyb290ID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDUgPT09IHJvb3QudGFnIHx8XG4gICAgICAgICAgICAgICAgICAoc3VwcG9ydHNSZXNvdXJjZXMgJiYgMjYgPT09IHJvb3QudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gcm9vdC50YWcpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4gPSBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAocHJvcHMgPSB3YXNIaWRkZW4uc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVih3YXNIaWRkZW4sIGhpZGVJbnN0YW5jZSwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICg2ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3YXNIaWRkZW4uc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcm9vdC5tZW1vaXplZFN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPT09IGZpbmlzaGVkV29yaykgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJvb3QuY2hpbGQucmV0dXJuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IHJvb3Quc2libGluZzsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdC5yZXR1cm4gfHwgcm9vdC5yZXR1cm4gPT09IGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICAgIHJvb3Quc2libGluZy5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IGZsYWdzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgKChmbGFncy5yZXRyeVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGN1cnJlbnQpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCBjb21taXRQbGFjZW1lbnQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IC0zO1xuICAgICAgfVxuICAgICAgZmxhZ3MgJiA0MDk2ICYmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTQwOTcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVJlc2V0Rm9ybXMocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI0KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmliZXIgPSBwYXJlbnRGaWJlcjtcbiAgICAgICAgICByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmliZXIpO1xuICAgICAgICAgIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgICAgZmliZXIuZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICByZXNldEZvcm1JbnN0YW5jZShmaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIHBhcmVudEZpYmVyLmFsdGVybmF0ZSwgcGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMuZWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIHBhcmVudEZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCAhPT0gcHJldmlvdXNDYWNoZSAmJlxuICAgICAgICAobnVsbCAhPSBjdXJyZW50ICYmIHJldGFpbkNhY2hlKGN1cnJlbnQpLFxuICAgICAgICBudWxsICE9IHByZXZpb3VzQ2FjaGUgJiYgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICBmaW5pc2hlZFdvcmsgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHJldGFpbkNhY2hlKGZpbmlzaGVkV29yayksIG51bGwgIT0gY3VycmVudCAmJiByZWxlYXNlQ2FjaGUoY3VycmVudCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICgoY29tbWl0dGVkTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgKGNvbW1pdHRlZExhbmVzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgIT09IGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBudWxsICE9IGNvbW1pdHRlZExhbmVzICYmIHJlbGVhc2VDYWNoZShjb21taXR0ZWRMYW5lcykpKTtcbiAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSB8PSA0KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBfaW5zdGFuY2UyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogKChfaW5zdGFuY2UyLl92aXNpYmlsaXR5IHw9IDQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBwYXJlbnRGaWJlclxuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IHN1c3BlbmRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogc3VzcGVuZEluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICBzdXNwZW5kSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBzdXNwZW5zZXlDb21taXRGbGFnKSxcbiAgICAgICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDE2Nzc3MjE2KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldmlvdXNIb2lzdGFibGVSb290KSlcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzRmliZXIgJiZcbiAgICAgICAgKChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIuY2hpbGQpLCBudWxsICE9PSBwYXJlbnRGaWJlcilcbiAgICAgICkge1xuICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgICAgZG9cbiAgICAgICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIpO1xuICAgICAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5mbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgUGFzc2l2ZSB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNCAmJlxuICAgICAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgICAgID8gKChwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJj0gLTUpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBQYXNzaXZlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDQgJiZcbiAgICAgICAgICAgICgoaW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gLTUpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICBkZWxldGVkU3VidHJlZVJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3QsXG4gICAgICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIHJlbGVhc2VDYWNoZShjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIChjdXJyZW50LnJldHVybiA9IGZpYmVyKSwgKG5leHRFZmZlY3QgPSBjdXJyZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGE6IGZvciAoZmliZXIgPSBkZWxldGVkU3VidHJlZVJvb3Q7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICB2YXIgc2libGluZyA9IGN1cnJlbnQuc2libGluZyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGZpYmVyKSB7XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgICAgIHZhciBtYXliZUZpYmVyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShob3N0Um9vdCk7XG4gICAgICBpZiAobnVsbCAhPSBtYXliZUZpYmVyKSB7XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgbWF5YmVGaWJlci5tZW1vaXplZFByb3BzW1wiZGF0YS10ZXN0bmFtZVwiXSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1heWJlRmliZXI7XG4gICAgICB9XG4gICAgICBob3N0Um9vdCA9IGZpbmRGaWJlclJvb3QoaG9zdFJvb3QpO1xuICAgICAgaWYgKG51bGwgPT09IGhvc3RSb290KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNvdWxkIG5vdCBmaW5kIFJlYWN0IGNvbnRhaW5lciB3aXRoaW4gc3BlY2lmaWVkIGhvc3Qgc3VidHJlZS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGhvc3RSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaFNlbGVjdG9yKGZpYmVyJGpzY29tcCQwLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHRhZyA9IGZpYmVyJGpzY29tcCQwLnRhZztcbiAgICAgIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgICAgICBpZiAoZmliZXIkanNjb21wJDAudHlwZSA9PT0gc2VsZWN0b3IudmFsdWUpIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci52YWx1ZTtcbiAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwID0gW2ZpYmVyJGpzY29tcCQwLCAwXTtcbiAgICAgICAgICAgIGZvciAodGFnID0gMDsgdGFnIDwgZmliZXIkanNjb21wJDAubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgdmFyIGZpYmVyID0gZmliZXIkanNjb21wJDBbdGFnKytdLFxuICAgICAgICAgICAgICAgIHRhZyRqc2NvbXAkMCA9IGZpYmVyLnRhZyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckluZGV4ID0gZmliZXIkanNjb21wJDBbdGFnKytdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yJGpzY29tcCQwID0gc2VsZWN0b3Jbc2VsZWN0b3JJbmRleF07XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoNSAhPT0gdGFnJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAyNiAhPT0gdGFnJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAyNyAhPT0gdGFnJGpzY29tcCQwKSB8fFxuICAgICAgICAgICAgICAgICFpc0hpZGRlblN1YnRyZWUoZmliZXIpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICBudWxsICE9IHNlbGVjdG9yJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvciRqc2NvbXAkMCk7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3RvciRqc2NvbXAkMCA9IHNlbGVjdG9yW3NlbGVjdG9ySW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgICAgICAgZmliZXIkanNjb21wJDAucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdG9yID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpICYmXG4gICAgICAgICAgICBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlKGZpYmVyJGpzY29tcCQwLnN0YXRlTm9kZSwgc2VsZWN0b3IudmFsdWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoZmliZXIkanNjb21wJDAgPSBnZXRUZXh0Q29udGVudChmaWJlciRqc2NvbXAkMCkpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmaWJlciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIDAgPD0gZmliZXIkanNjb21wJDAuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChmaWJlciRqc2NvbXAkMCA9IGZpYmVyJGpzY29tcCQwLm1lbW9pemVkUHJvcHNbXCJkYXRhLXRlc3RuYW1lXCJdKSxcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGZpYmVyJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgZmliZXIkanNjb21wJDAudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IudmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgICAgIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHNlbGVjdG9yLnZhbHVlKSB8fCBcIlVua25vd25cIikgKyBcIj5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgXCJcIikgKyBcIilcIjtcbiAgICAgICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdbcm9sZT1cIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIl0nO1xuICAgICAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1wiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiJztcbiAgICAgICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1tkYXRhLXRlc3RuYW1lPVwiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiXSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgdmFyIG1hdGNoaW5nRmliZXJzID0gW107XG4gICAgICByb290ID0gW3Jvb3QsIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gcm9vdFtpbmRleCsrXSxcbiAgICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgICAgc2VsZWN0b3JJbmRleCA9IHJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHxcbiAgICAgICAgICAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPSBzZWxlY3RvciAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3Rvcik7IClcbiAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKywgKHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdKTtcbiAgICAgICAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgICByb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoaW5nRmliZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIGhvc3RSb290ID0gZmluZFBhdGhzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgc2VsZWN0b3JzID0gW107XG4gICAgICBob3N0Um9vdCA9IEFycmF5LmZyb20oaG9zdFJvb3QpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBub2RlID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgIGlzSGlkZGVuU3VidHJlZShub2RlKSB8fCBzZWxlY3RvcnMucHVzaChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApXG4gICAgICAgICAgICBob3N0Um9vdC5wdXNoKG5vZGUpLCAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0b3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbW1pdFJvb3QoKSB7XG4gICAgICBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgJiZcbiAgICAgICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAgICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCB8fFxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0IGFjdCguLi4pXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJlxuICAgICAgICAwICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgKVxuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiAtd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gdHJhbnNpdGlvblxuICAgICAgICA/ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzIHx8ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpKSxcbiAgICAgICAgICB0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmFkZChmaWJlciksXG4gICAgICAgICAgKGZpYmVyID0gY3VycmVudEVudGFuZ2xlZExhbmUpLFxuICAgICAgICAgIDAgIT09IGZpYmVyID8gZmliZXIgOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSlcbiAgICAgICAgOiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICAgICAgPyBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpXG4gICAgICAgICAgICA6IDUzNjg3MDkxMik7XG4gICAgICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlciAmJiAoc3VzcGVuc2VIYW5kbGVyLmZsYWdzIHw9IDMyKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUluc2VydGlvbkVmZmVjdCBtdXN0IG5vdCBzY2hlZHVsZSB1cGRhdGVzLlwiKTtcbiAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyAmJiAoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICEwKTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKSxcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgbGFuZSk7XG4gICAgICBpZiAoXG4gICAgICAgIDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgJiZcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290XG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzUmVuZGVyaW5nKVxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcm9vdCA9XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpKSB8fFxuICAgICAgICAgICAgICAgIFwiVW5rbm93blwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKHJvb3QpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQocm9vdCksXG4gICAgICAgICAgICAgICAgKGZpYmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhIGRpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsIGZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyXCIsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpLFxuICAgICAgICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlciksXG4gICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgICAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCBmb3JjZVN5bmMpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIpO1xuICAgICAgdmFyIHNob3VsZFRpbWVTbGljZSA9XG4gICAgICAgICAgKCFmb3JjZVN5bmMgJiZcbiAgICAgICAgICAgIDAgPT09IChsYW5lcyAmIDYwKSAmJlxuICAgICAgICAgICAgMCA9PT0gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpKSB8fFxuICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpLFxuICAgICAgICBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlXG4gICAgICAgICAgPyByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcylcbiAgICAgICAgICA6IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCAhMCksXG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBzaG91bGRUaW1lU2xpY2U7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAhc2hvdWxkVGltZVNsaWNlICYmXG4gICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgMCwgITEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSlcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yY2VTeW5jID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICAgICAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZvcmNlU3luYylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgITEpO1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGxhbmVzO1xuICAgICAgICAgICAgaWYgKHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJiByZW5kZXJXYXNDb25jdXJyZW50KVxuICAgICAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTUzNjg3MDkxMyksXG4gICAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAwICE9PSBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvclJldHJ5TGFuZXMgJiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA/IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgICAgIDogMCk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gZXJyb3JSZXRyeUxhbmVzKSB7XG4gICAgICAgICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICAgICAgICAgICAgICAgIHZhciB3YXNSb290RGVoeWRyYXRlZCA9XG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkO1xuICAgICAgICAgICAgICAgIHdhc1Jvb3REZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgICAocHJlcGFyZUZyZXNoU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKS5mbGFncyB8PSAyNTYpO1xuICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IHJlbmRlclJvb3RTeW5jKFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdhc1Jvb3REZWh5ZHJhdGVkXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyB8PVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGV4aXRTdGF0dXMgJiYgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhleGl0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICAgIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKTtcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlID0gcm9vdDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFJvb3RJblByb2dyZXNzOlxuICAgICAgICAgICAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICAgICAgICAgICAgaWYgKChsYW5lcyAmIDQxOTQxNzYpID09PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UuZmluaXNoZWRXb3JrID0gZm9yY2VTeW5jO1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICBJTU1FRElBVEVfQ09NTUlULFxuICAgICAgICAgICAgICAgIC0wLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGxhbmVzICYgNjI5MTQ1NjApID09PSBsYW5lcyAmJlxuICAgICAgICAgICAgICAgICgoZXhpdFN0YXR1cyA9XG4gICAgICAgICAgICAgICAgICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICtcbiAgICAgICAgICAgICAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TIC1cbiAgICAgICAgICAgICAgICAgIG5vdyQxKCkpLFxuICAgICAgICAgICAgICAgIDEwIDwgZXhpdFN0YXR1cylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IGdldE5leHRMYW5lcyhzaG91bGRUaW1lU2xpY2UsIDApKSBicmVhayBhO1xuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZS50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeS5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgICAgICBUSFJPVFRMRURfQ09NTUlULFxuICAgICAgICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgIElNTUVESUFURV9DT01NSVQsXG4gICAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnMpXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgbGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcbiAgICAgIGlmIChzdWJ0cmVlRmxhZ3MgJiA4MTkyIHx8IDE2Nzg1NDA4ID09PSAoc3VidHJlZUZsYWdzICYgMTY3ODU0MDgpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpLFxuICAgICAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgKGZpbmlzaGVkV29yayA9IHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKSksXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrKVxuICAgICAgICApIHtcbiAgICAgICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBmaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICBjb21taXRSb290LmJpbmQoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICBTVVNQRU5ERURfQ09NTUlULFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICAhZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDAgPT09IHRhZyB8fCAxMSA9PT0gdGFnIHx8IDE1ID09PSB0YWcpICYmXG4gICAgICAgICAgbm9kZS5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICAgKCh0YWcgPSBub2RlLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICBudWxsICE9PSB0YWcgJiYgKCh0YWcgPSB0YWcuc3RvcmVzKSwgbnVsbCAhPT0gdGFnKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWdbaV0sXG4gICAgICAgICAgICAgIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICBjaGVjayA9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLCBjaGVjaykpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHRhZyA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIDE2Mzg0ICYmIG51bGwgIT09IHRhZylcbiAgICAgICAgICAodGFnLnJldHVybiA9IG5vZGUpLCAobm9kZSA9IHRhZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHJldHVybiAhMDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICByb290LFxuICAgICAgc3VzcGVuZGVkTGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSAmJiAocm9vdC53YXJtTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgICAgIGZvciAodmFyIGxhbmVzID0gc3VzcGVuZGVkTGFuZXM7IDAgPCBsYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVtpbmRleF0gPSAtMTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJlxuICAgICAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgc3VzcGVuZGVkTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN5bmNXb3JrKCkge1xuICAgICAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dFxuICAgICAgICA/IChmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSksICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKSB7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBOb3RTdXNwZW5kZWQpXG4gICAgICAgICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSxcbiAgICAgICAgICAgIHJlc2V0SG9va3NPblVud2luZChpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAgICAgKHRoZW5hYmxlU3RhdGUkMSA9IG51bGwpLFxuICAgICAgICAgICAgKHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwKSxcbiAgICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBpbnRlcnJ1cHRlZFdvcms7IClcbiAgICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZSwgaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgdGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0ICYmXG4gICAgICAgICgocm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0KSwgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKSk7XG4gICAgICB0aW1lb3V0SGFuZGxlID0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0O1xuICAgICAgbnVsbCAhPT0gdGltZW91dEhhbmRsZSAmJlxuICAgICAgICAoKHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGwpLCB0aW1lb3V0SGFuZGxlKCkpO1xuICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0aW1lb3V0SGFuZGxlID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPVxuICAgICAgICAgIDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPVxuICAgICAgICBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExO1xuICAgICAgMCAhPT0gKGxhbmVzICYgOCkgJiYgKGxhbmVzIHw9IGxhbmVzICYgMzIpO1xuICAgICAgdmFyIGFsbEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcbiAgICAgIGlmICgwICE9PSBhbGxFbnRhbmdsZWRMYW5lcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzLCBhbGxFbnRhbmdsZWRMYW5lcyAmPSBsYW5lcztcbiAgICAgICAgICAwIDwgYWxsRW50YW5nbGVkTGFuZXM7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihhbGxFbnRhbmdsZWRMYW5lcyksXG4gICAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgICBsYW5lcyB8PSByb290W2luZGV4XTtcbiAgICAgICAgICBhbGxFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBsYW5lcztcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MoKTtcbiAgICAgIHJldHVybiB0aW1lb3V0SGFuZGxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkltbWVkaWF0ZSkpXG4gICAgICAgIDogdGhyb3duVmFsdWUgPT09IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvblxuICAgICAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbnN0YW5jZSkpXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBTdXNwZW5kZWRPbkh5ZHJhdGlvblxuICAgICAgICAgICAgICAgIDogbnVsbCAhPT0gdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHRocm93blZhbHVlLnRoZW5cbiAgICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgICA6IFN1c3BlbmRlZE9uRXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICAgICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBpZiAobnVsbCA9PT0gZXJyb3JlZFdvcmspXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZCksXG4gICAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKGVycm9yZWRXb3JrLm1vZGUgJiAyICYmXG4gICAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKGVycm9yZWRXb3JrKSxcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKFxuICAgICAgICAgICAgICAgIGVycm9yZWRXb3JrLFxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgPT09IGhhbmRsZXJcbiAgICAgICAgPyAhMFxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICA/IG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgID8gITBcbiAgICAgICAgICAgIDogITFcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSA9PT1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyB8fFxuICAgICAgICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgICAgICAgICA/IGhhbmRsZXIgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gcHJldkRpc3BhdGNoZXIgPyBDb250ZXh0T25seURpc3BhdGNoZXIgOiBwcmV2RGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgIT09XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSB8fFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMCk7XG4gICAgICAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyAmIDEzNDIxNzcyNykgJiZcbiAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzICYgMTM0MjE3NzI3KSkgfHxcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290IHx8XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgICBsYW5lcyA9ICExO1xuICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICBhOiBkb1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAocmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkNCkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDQpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICBsYW5lcyAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCksXG4gICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRVcGRhdGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICBiOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAoKGxhbmVzID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAobWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUpO1xuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycylcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBob3N0RmliZXIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGhvc3RGaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBob3N0RmliZXIuc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaG9zdEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVuaXRPZldvcmsocmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdHlwZSBvZiBmaWJlciB0cmlnZ2VyZWQgYSBzdXNwZW5zZXkgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuZGVkUmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICAgICAgPyB3b3JrTG9vcFN5bmMoKVxuICAgICAgICAgICAgOiB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkNSkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDUpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQoKSxcbiAgICAgICAgICBSb290SW5Qcm9ncmVzc1xuICAgICAgICApO1xuICAgICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDA7XG4gICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICFzaG91bGRZaWVsZCgpOyApXG4gICAgICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZTtcbiAgICAgICh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlXG4gICAgICAgID8gKHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKSxcbiAgICAgICAgICAoY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGJlZ2luV29yayxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKHVuaXRPZldvcmspKVxuICAgICAgICA6IChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpO1xuICAgICAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzID0gY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVih1bml0T2ZXb3JrLCByZXBsYXlCZWdpbldvcmssIHVuaXRPZldvcmspO1xuICAgICAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICBudWxsID09PSBuZXh0ID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIDogKHdvcmtJblByb2dyZXNzID0gbmV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUJlZ2luV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlLFxuICAgICAgICBpc1Byb2ZpbGluZ01vZGUgPSAodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZTtcbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJiBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUucmVuZGVyLFxuICAgICAgICAgICAgdW5pdE9mV29yay5yZWYsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspLFxuICAgICAgICAgICAgKHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSk7XG4gICAgICB9XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiZcbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgcm9vdCxcbiAgICAgIHVuaXRPZldvcmssXG4gICAgICB0aHJvd25WYWx1ZSxcbiAgICAgIHN1c3BlbmRlZFJlYXNvblxuICAgICkge1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHRocm93ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksIGVycm9yKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgMzI3NjgpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nIHx8IHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25FcnJvcikgcm9vdCA9ICEwO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyB8fFxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgKVxuICAgICAgICAgIHJvb3QgPSAhMTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uSW1tZWRpYXRlIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSlcbiAgICAgICAgKVxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24gPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHN1c3BlbmRlZFJlYXNvbiAmJlxuICAgICAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uLmZsYWdzIHw9IDE2Mzg0KTtcbiAgICAgICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCByb290KTtcbiAgICAgIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDMyNzY4KSkge1xuICAgICAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7XG4gICAgICAgIGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGNvbXBsZXRlV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBsZXRlZFdvcmsgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG4gICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gY29tcGxldGVkV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHNraXBTaWJsaW5ncykge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsodW5pdE9mV29yay5hbHRlcm5hdGUsIHVuaXRPZldvcmspO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV4dCkge1xuICAgICAgICAgIG5leHQuZmxhZ3MgJj0gMzI3Njc7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgICAgICBuZXh0ID0gdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBmb3IgKHZhciBjaGlsZCA9IHVuaXRPZldvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgICAobmV4dCArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHVuaXRPZldvcmsuYWN0dWFsRHVyYXRpb24gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgICAgbnVsbCAhPT0gbmV4dCAmJlxuICAgICAgICAgICgobmV4dC5mbGFncyB8PSAzMjc2OCksXG4gICAgICAgICAgKG5leHQuc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKG5leHQuZGVsZXRpb25zID0gbnVsbCkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXNraXBTaWJsaW5ncyAmJlxuICAgICAgICAgICgodW5pdE9mV29yayA9IHVuaXRPZldvcmsuc2libGluZyksIG51bGwgIT09IHVuaXRPZldvcmspXG4gICAgICAgICkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdW5pdE9mV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrID0gbmV4dDtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHVuaXRPZldvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdChcbiAgICAgIHJvb3QsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIGNvbW1pdFJvb3RJbXBsKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSxcbiAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdEltcGwoXG4gICAgICByb290LFxuICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICB0cmFuc2l0aW9ucyxcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXNcbiAgICApIHtcbiAgICAgIGRvIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHdoaWxlIChudWxsICE9PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIik7XG4gICAgICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgPSByb290LmZpbmlzaGVkTGFuZXM7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yaykgcmV0dXJuIG1hcmtDb21taXRTdG9wcGVkKCksIG51bGw7XG4gICAgICAwID09PSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInJvb3QuZmluaXNoZWRMYW5lcyBzaG91bGQgbm90IGJlIGVtcHR5IGR1cmluZyBhIGNvbW1pdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgICAgIHZhciByZW1haW5pbmdMYW5lcyA9IGZpbmlzaGVkV29yay5sYW5lcyB8IGZpbmlzaGVkV29yay5jaGlsZExhbmVzO1xuICAgICAgcmVtYWluaW5nTGFuZXMgfD0gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xuICAgICAgbWFya1Jvb3RGaW5pc2hlZChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICAgKTtcbiAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDApKTtcbiAgICAgICgwID09PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KSAmJlxuICAgICAgICAwID09PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTAyNTYpKSB8fFxuICAgICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyB8fFxuICAgICAgICAoKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITApLFxuICAgICAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcyksXG4gICAgICAgIChwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnMpLFxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCEwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpO1xuICAgICAgY29tbWl0U3RhcnRUaW1lID0gbm93KCk7XG4gICAgICB0cmFuc2l0aW9ucyA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxNTk5MCk7XG4gICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDE1OTkwKSB8fCB0cmFuc2l0aW9uc1xuICAgICAgICA/ICgodHJhbnNpdGlvbnMgPSBSZWFjdFNoYXJlZEludGVybmFscy5UKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIChzcGF3bmVkTGFuZSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKHVwZGF0ZWRMYW5lcyA9IGV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQpLFxuICAgICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGVcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQoXG4gICAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKSxcbiAgICAgICAgICByZXF1ZXN0UGFpbnQoKSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCA9IHVwZGF0ZWRMYW5lcyksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHNwYXduZWRMYW5lKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHRyYW5zaXRpb25zKSlcbiAgICAgICAgOiAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKTtcbiAgICAgICh0cmFuc2l0aW9ucyA9IHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKVxuICAgICAgICA/ICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMSksXG4gICAgICAgICAgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdCksXG4gICAgICAgICAgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSlcbiAgICAgICAgOiAocmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyksXG4gICAgICAgICAgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCkpO1xuICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIDAgPT09IHJlbWFpbmluZ0xhbmVzICYmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwpO1xuICAgICAgdHJhbnNpdGlvbnMgfHwgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpO1xuICAgICAgb25Db21taXRSb290JDEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByb290Lm1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgIG9uQ29tbWl0Um9vdCgpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgaWYgKG51bGwgIT09IHJlY292ZXJhYmxlRXJyb3JzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvciwgZmluaXNoZWRXb3JrID0gMDtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsgPCByZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7XG4gICAgICAgICAgZmluaXNoZWRXb3JrKytcbiAgICAgICAgKVxuICAgICAgICAgIChyZW1haW5pbmdMYW5lcyA9IHJlY292ZXJhYmxlRXJyb3JzW2ZpbmlzaGVkV29ya10pLFxuICAgICAgICAgICAgKHRyYW5zaXRpb25zID0gbWFrZUVycm9ySW5mbyhyZW1haW5pbmdMYW5lcy5zdGFjaykpLFxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIHJlbWFpbmluZ0xhbmVzLnNvdXJjZSxcbiAgICAgICAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGFuZXMudmFsdWUsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgMCAhPT0gKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzICYgMykgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIDAgIT09IChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgJiA0MTk0MjE4KSAmJlxuICAgICAgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgICAgID8gKChuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgcm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzXG4gICAgICAgICAgICA/IG5lc3RlZFVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgIDogKChuZXN0ZWRVcGRhdGVDb3VudCA9IDApLCAocm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdCkpKVxuICAgICAgICA6IChuZXN0ZWRVcGRhdGVDb3VudCA9IDApO1xuICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlRXJyb3JJbmZvKGNvbXBvbmVudFN0YWNrKSB7XG4gICAgICBjb21wb25lbnRTdGFjayA9IHsgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcG9uZW50U3RhY2ssIFwiZGlnZXN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdZb3UgYXJlIGFjY2Vzc2luZyBcImRpZ2VzdFwiIGZyb20gdGhlIGVycm9ySW5mbyBvYmplY3QgcGFzc2VkIHRvIG9uUmVjb3ZlcmFibGVFcnJvci4gVGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgcHJvdmlkZWQgYXMgcGFydCBvZiBlcnJvckluZm8gYnV0IGNhbiBiZSBhY2Nlc3NlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBFcnJvciBpbnN0YW5jZSBpdHNlbGYuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gICAgICAwID09PSAocm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzKSAmJlxuICAgICAgICAoKHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wb29sZWRDYWNoZSksXG4gICAgICAgIG51bGwgIT0gcmVtYWluaW5nTGFuZXMgJiZcbiAgICAgICAgICAoKHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsKSwgcmVsZWFzZUNhY2hlKHJlbWFpbmluZ0xhbmVzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAgICAgaWYgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICAgIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICAgICAgcmVtYWluaW5nTGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcztcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwO1xuICAgICAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyksXG4gICAgICAgICAgcHJpb3JpdHkgPSAzMiA+IHJlbmRlclByaW9yaXR5ID8gMzIgOiByZW5kZXJQcmlvcml0eTtcbiAgICAgICAgcmVuZGVyUHJpb3JpdHkgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICAgICAgICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcm9vdCRqc2NvbXAkMCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgICAgICAgICBsYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO1xuICAgICAgICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xuICAgICAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PVxuICAgICAgICAgICAgICBOb0NvbnRleHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMDtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMTtcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICAgICAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocm9vdCRqc2NvbXAkMC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICAgIHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICAgIHJvb3QkanNjb21wJDAuY3VycmVudCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICAgICAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290JGpzY29tcCQwKTtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHNcbiAgICAgICAgICAgICAgPyByb290JGpzY29tcCQwID09PSByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzXG4gICAgICAgICAgICAgICAgPyBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgICAgIDogKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdCRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgIDogKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSByb290JGpzY29tcCQwLmN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByZW5kZXJQcmlvcml0eSksXG4gICAgICAgICAgICByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgc291cmNlRmliZXIsIDIpO1xuICAgICAgcm9vdEZpYmVyID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHNvdXJjZUZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3RGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEocm9vdEZpYmVyLCAyKSwgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3RGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGVycm9yXG4gICAgKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMTtcbiAgICAgIGlmICgzID09PSBzb3VyY2VGaWJlci50YWcpXG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yOyApIHtcbiAgICAgICAgICBpZiAoMyA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgICAgIGVycm9yID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSgyKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbnF1ZXVlVXBkYXRlKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yLCAyKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbnN0YW5jZSwgMiksXG4gICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIFBvdGVudGlhbCBjYXVzZXMgaW5jbHVkZSBkZWxldGluZyB0aGUgc2FtZSBmaWJlciBtb3JlIHRoYW4gb25jZSwgY29tbWl0dGluZyBhbiBhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG5FcnJvciBtZXNzYWdlOlxcblxcbiVzXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAgICAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICAgICAgaWYgKG51bGwgPT09IHBpbmdDYWNoZSkge1xuICAgICAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gdGhyZWFkSURzICYmXG4gICAgICAgICAgICAoKHRocmVhZElEcyA9IG5ldyBTZXQoKSksIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcykpO1xuICAgICAgdGhyZWFkSURzLmhhcyhsYW5lcykgfHxcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMCksXG4gICAgICAgIHRocmVhZElEcy5hZGQobGFuZXMpLFxuICAgICAgICAocGluZ0NhY2hlID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpKSxcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyksXG4gICAgICAgIHdha2VhYmxlLnRoZW4ocGluZ0NhY2hlLCBwaW5nQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBudWxsICE9PSBwaW5nQ2FjaGUgJiYgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gICAgICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbiAgICAgIHJvb3Qud2FybUxhbmVzICY9IH5waW5nZWRMYW5lcztcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCJcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiBwaW5nZWRMYW5lcykgPT09IHBpbmdlZExhbmVzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBub3ckMSgpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA8IEZBTExCQUNLX1RIUk9UVExFX01TKVxuICAgICAgICAgID8gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIHw9IHBpbmdlZExhbmVzKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwKSk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIDAgPT09IHJldHJ5TGFuZSAmJiAocmV0cnlMYW5lID0gY2xhaW1OZXh0UmV0cnlMYW5lKCkpO1xuICAgICAgYm91bmRhcnlGaWJlciA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgbnVsbCAhPT0gYm91bmRhcnlGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSxcbiAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGJvdW5kYXJ5RmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKSB7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcmV0cnlMYW5lID0gMDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICAgICAgdmFyIHJldHJ5TGFuZSA9IDA7XG4gICAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZVN0YXRlICYmIChyZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZS5fcmV0cnlDYWNoZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBudWxsICE9PSByZXRyeUNhY2hlICYmIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaXNJblN0cmljdE1vZGVcbiAgICApIHtcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMzM1NjI2MjQpKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICBmaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBmaWJlci50eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyID0gaXNJblN0cmljdE1vZGUgfHwgaXNTdHJpY3RNb2RlRmliZXI7XG4gICAgICAgICAgMjIgIT09IGZpYmVyLnRhZ1xuICAgICAgICAgICAgPyBmaWJlci5mbGFncyAmIDMzNTU0NDMyXG4gICAgICAgICAgICAgID8gaXNTdHJpY3RNb2RlRmliZXIgJiZcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAoZmliZXIubW9kZSAmIDY0KSA9PT0gTm9Nb2RlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAoaXNTdHJpY3RNb2RlRmliZXIgJiYgZmliZXIuZmxhZ3MgJiA4MTkyXG4gICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogZmliZXIuc3VidHJlZUZsYWdzICYgMzM1NTQ0MzIgJiZcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIpIHtcbiAgICAgIHZhciBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogITA7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpYmVyKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaWJlciksXG4gICAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKHJvb3QsIGZpYmVyLmFsdGVybmF0ZSwgZmliZXIsICExKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJlxuICAgICAgICAgICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMocm9vdCwgZmliZXIsIDAsIG51bGwsICExKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpIHtcbiAgICAgIHZhciBkb3VibGVJbnZva2VFZmZlY3RzID0gITA7XG4gICAgICByb290LmN1cnJlbnQubW9kZSAmIDI0IHx8IChkb3VibGVJbnZva2VFZmZlY3RzID0gITEpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdC5jdXJyZW50LFxuICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAzID09PSB0YWcgfHxcbiAgICAgICAgICAxID09PSB0YWcgfHxcbiAgICAgICAgICAwID09PSB0YWcgfHxcbiAgICAgICAgICAxMSA9PT0gdGFnIHx8XG4gICAgICAgICAgMTQgPT09IHRhZyB8fFxuICAgICAgICAgIDE1ID09PSB0YWdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGFnID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJSZWFjdENvbXBvbmVudFwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXModGFnKSkgcmV0dXJuO1xuICAgICAgICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQodGFnKTtcbiAgICAgICAgICB9IGVsc2UgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW3RhZ10pO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFRoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0IGFzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byB1c2VFZmZlY3QgaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJlxuICAgICAgICByb290Lm1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIHNjaGVkdWxpbmdGaWJlciwgbGFuZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWU7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gYWN0UXVldWVcbiAgICAgICAgPyAoYWN0UXVldWUucHVzaChjYWxsYmFjayksIGZha2VBY3RDYWxsYmFja05vZGUpXG4gICAgICAgIDogc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gICAgICBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmXG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbldoZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSB3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuYWN0KCgpID0+IHtcXG4gIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxufSk7XFxuLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG5UaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIGluIHRoZSBicm93c2VyLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdFwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5ID8gdHlwZSA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSkgcmV0dXJuIHR5cGU7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGZhbWlseVxuICAgICAgICA/IG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IHR5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnJlbmRlciAmJlxuICAgICAgICAgICgoZmFtaWx5ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKSksXG4gICAgICAgICAgdHlwZS5yZW5kZXIgIT09IGZhbWlseSlcbiAgICAgICAgICA/ICgoZmFtaWx5ID0geyAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSwgcmVuZGVyOiBmYW1pbHkgfSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgKGZhbWlseS5kaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWUpLFxuICAgICAgICAgICAgZmFtaWx5KVxuICAgICAgICAgIDogdHlwZVxuICAgICAgICA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gITE7XG4gICAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnR5cGU7XG4gICAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMSxcbiAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnQgJiYgbnVsbCAhPT0gZWxlbWVudFxuICAgICAgICAgICAgPyBlbGVtZW50LiQkdHlwZW9mXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudCAmJiAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50XG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZWVkc0NvbXBhcmVGYW1pbGllcyAmJlxuICAgICAgICAoKGZpYmVyID0gcmVzb2x2ZUZhbWlseShwcmV2VHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGZpYmVyICYmIGZpYmVyID09PSByZXNvbHZlRmFtaWx5KGVsZW1lbnQpKVxuICAgICAgICA/ICEwXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSByZXNvbHZlRmFtaWx5ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgJiZcbiAgICAgICAgKG51bGwgPT09IGZhaWxlZEJvdW5kYXJpZXMgJiYgKGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgV2Vha1NldCgpKSxcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgIGZpYmVyLFxuICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgc3RhbGVGYW1pbGllc1xuICAgICkge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpXG4gICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuXCIpO1xuICAgICAgdmFyIG5lZWRzUmVuZGVyID0gITE7XG4gICAgICB0eXBlID0gITE7XG4gICAgICBudWxsICE9PSBjYW5kaWRhdGVUeXBlICYmXG4gICAgICAgICgoY2FuZGlkYXRlVHlwZSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgICAoc3RhbGVGYW1pbGllcy5oYXMoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgICAgID8gKHR5cGUgPSAhMClcbiAgICAgICAgICAgIDogdXBkYXRlZEZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKSAmJlxuICAgICAgICAgICAgICAoMSA9PT0gdGFnID8gKHR5cGUgPSAhMCkgOiAobmVlZHNSZW5kZXIgPSAhMCkpKSk7XG4gICAgICBudWxsICE9PSBmYWlsZWRCb3VuZGFyaWVzICYmXG4gICAgICAgIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHxcbiAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpKSAmJlxuICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgIHR5cGUgJiYgKGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICEwKTtcbiAgICAgIGlmICh0eXBlIHx8IG5lZWRzUmVuZGVyKVxuICAgICAgICAoYWx0ZXJuYXRlID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhbHRlcm5hdGUsIGZpYmVyLCAyKTtcbiAgICAgIG51bGwgPT09IGNoaWxkIHx8XG4gICAgICAgIHR5cGUgfHxcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgbnVsbCAhPT0gc2libGluZyAmJlxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHNpYmxpbmcsXG4gICAgICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnNpYmxpbmcgPVxuICAgICAgICB0aGlzLmNoaWxkID1cbiAgICAgICAgdGhpcy5yZXR1cm4gPVxuICAgICAgICB0aGlzLnN0YXRlTm9kZSA9XG4gICAgICAgIHRoaXMudHlwZSA9XG4gICAgICAgIHRoaXMuZWxlbWVudFR5cGUgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVmQ2xlYW51cCA9IHRoaXMucmVmID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICB0aGlzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXVlID1cbiAgICAgICAgdGhpcy5tZW1vaXplZFByb3BzID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc3VidHJlZUZsYWdzID0gdGhpcy5mbGFncyA9IDA7XG4gICAgICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkTGFuZXMgPSB0aGlzLmxhbmVzID0gMDtcbiAgICAgIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTEuMTtcbiAgICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5fZGVidWdPd25lciA9IHRoaXMuX2RlYnVnSW5mbyA9IG51bGw7XG4gICAgICB0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICExO1xuICAgICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuICAgICAgaGFzQmFkTWFwUG9seWZpbGwgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8XG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhKCFDb21wb25lbnQgfHwgIUNvbXBvbmVudC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICAgICAgY3VycmVudC50YWcsXG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICBjdXJyZW50LmtleSxcbiAgICAgICAgICAgIGN1cnJlbnQubW9kZVxuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXIpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQpLFxuICAgICAgICAgIChjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xKSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1Byb3BzXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxhbmVzOiBwZW5kaW5nUHJvcHMubGFuZXMsXG4gICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcGVuZGluZ1Byb3BzLmZpcnN0Q29udGV4dCxcbiAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcGVuZGluZ1Byb3BzLl9kZWJ1Z1RoZW5hYmxlU3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvID0gY3VycmVudC5fZGVidWdJbmZvO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gMzE0NTcyODI7XG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgbGFuZXM6IHJlbmRlckxhbmVzLmxhbmVzLFxuICAgICAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiByZW5kZXJMYW5lcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiByZW5kZXJMYW5lcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICBvd25lcixcbiAgICAgIG1vZGUsXG4gICAgICBsYW5lc1xuICAgICkge1xuICAgICAgdmFyIGZpYmVyVGFnID0gMCxcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gdHlwZTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgKGZpYmVyVGFnID0gMSksXG4gICAgICAgICAgKHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpKTtcbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzdXBwb3J0c1Jlc291cmNlcyAmJiBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICA/ICgoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgIChmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBmaWJlclRhZylcbiAgICAgICAgICAgICAgPyAyNlxuICAgICAgICAgICAgICA6IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSlcbiAgICAgICAgICAgICAgICA/IDI3XG4gICAgICAgICAgICAgICAgOiA1KSlcbiAgICAgICAgICA6IHN1cHBvcnRzUmVzb3VyY2VzXG4gICAgICAgICAgICA/ICgoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGZpYmVyVGFnKVxuICAgICAgICAgICAgICAgID8gMjZcbiAgICAgICAgICAgICAgICA6IDUpKVxuICAgICAgICAgICAgOiAoZmliZXJUYWcgPSBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICAgICAgICA/IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSlcbiAgICAgICAgICAgICAgICAgID8gMjdcbiAgICAgICAgICAgICAgICAgIDogNVxuICAgICAgICAgICAgICAgIDogNSk7XG4gICAgICBlbHNlXG4gICAgICAgIGE6IHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgICAgIG1vZGUgfD0gMjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodHlwZSA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChvd25lciA9IG1vZGUpLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdHlwZS5pZCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZS5pZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMiwgdHlwZSwga2V5LCBvd25lciB8IDIpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICAoa2V5LnN0YXRlTm9kZSA9IHsgZWZmZWN0RHVyYXRpb246IDAsIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMCB9KSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTksIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmIG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE2O1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwibnVsbFwiKVxuICAgICAgICAgICAgICA6IGlzQXJyYXlJbXBsKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlID1cbiAgICAgICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgICAgIDogKHBlbmRpbmdQcm9wcyA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gb3duZXJcbiAgICAgICAgICAgICAgPyBcIm51bWJlclwiID09PSB0eXBlb2Ygb3duZXIudGFnXG4gICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG93bmVyLm5hbWVcbiAgICAgICAgICAgICAgICAgID8gb3duZXIubmFtZVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZpYmVyVGFnICYmXG4gICAgICAgICAgICAgIChyZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGZpYmVyVGFnICsgXCJgLlwiKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gMjk7XG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMgPSBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAocGVuZGluZ1Byb3BzICsgXCIuXCIgKyByZXNvbHZlZFR5cGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAga2V5ID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICAgIGtleS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICBrZXkudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgICAgIGtleS5sYW5lcyA9IGxhbmVzO1xuICAgICAga2V5Ll9kZWJ1Z093bmVyID0gb3duZXI7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICBlbGVtZW50LnR5cGUsXG4gICAgICAgIGVsZW1lbnQua2V5LFxuICAgICAgICBlbGVtZW50LnByb3BzLFxuICAgICAgICBlbGVtZW50Ll9vd25lcixcbiAgICAgICAgbW9kZSxcbiAgICAgICAgbGFuZXNcbiAgICAgICk7XG4gICAgICBtb2RlLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIGVsZW1lbnRzID0gY3JlYXRlRmliZXIoNywgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gICAgICBlbGVtZW50cy5sYW5lcyA9IGxhbmVzO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gICAgICBwZW5kaW5nUHJvcHMgPSBjcmVhdGVGaWJlcigyMiwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgICAgcGVuZGluZ1Byb3BzLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gICAgICBwZW5kaW5nUHJvcHMubGFuZXMgPSBsYW5lcztcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICAgICAgX3Zpc2liaWxpdHk6IDEsXG4gICAgICAgIF9wZW5kaW5nVmlzaWJpbGl0eTogMSxcbiAgICAgICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgICAgICBfcmV0cnlDYWNoZTogbnVsbCxcbiAgICAgICAgX3RyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICBfY3VycmVudDogbnVsbCxcbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UsXG4gICAgICAgICAgICBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkNhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMCA9PT0gKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IDIpLFxuICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlLFxuICAgICAgICAgICAgZmliZXIgPSBpbnN0YW5jZS5fY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDAgIT09IChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmPSAtMyksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBlbmRpbmdQcm9wcy5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgICAgIHJldHVybiBwZW5kaW5nUHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIGNvbnRlbnQgPSBjcmVhdGVGaWJlcig2LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgICAgIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICAgICAgbW9kZSA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICA0LFxuICAgICAgICBudWxsICE9PSBwb3J0YWwuY2hpbGRyZW4gPyBwb3J0YWwuY2hpbGRyZW4gOiBbXSxcbiAgICAgICAgcG9ydGFsLmtleSxcbiAgICAgICAgbW9kZVxuICAgICAgKTtcbiAgICAgIG1vZGUubGFuZXMgPSBsYW5lcztcbiAgICAgIG1vZGUuc3RhdGVOb2RlID0ge1xuICAgICAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB0aGlzLnRhZyA9IDE7XG4gICAgICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICAgICAgdGhpcy5maW5pc2hlZFdvcmsgPVxuICAgICAgICB0aGlzLnBpbmdDYWNoZSA9XG4gICAgICAgIHRoaXMuY3VycmVudCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkcmVuID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgdGhpcy5jYWxsYmFja05vZGUgPVxuICAgICAgICB0aGlzLm5leHQgPVxuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICAgICAgdGhpcy5jb250ZXh0ID1cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcCgtMSk7XG4gICAgICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICAgICAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID1cbiAgICAgICAgdGhpcy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZmluaXNoZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZXhwaXJlZExhbmVzID1cbiAgICAgICAgdGhpcy53YXJtTGFuZXMgPVxuICAgICAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICAgICAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9XG4gICAgICAgIHRoaXMucGVuZGluZ0xhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcCgwKTtcbiAgICAgIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gICAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICAgICAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gICAgICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGVMYW5lcyA9IDA7XG4gICAgICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgICAgIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSB0aGlzLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBjb250YWluZXJJbmZvID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG4gICAgICBmb3IgKHRhZyA9IDA7IDMxID4gdGFnOyB0YWcrKykgY29udGFpbmVySW5mby5wdXNoKG5ldyBTZXQoKSk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/IFwiaHlkcmF0ZVJvb3QoKVwiIDogXCJjcmVhdGVSb290KClcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgdGFnID0gMTtcbiAgICAgICEwID09PSBpc1N0cmljdE1vZGUgJiYgKHRhZyB8PSAyNCk7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiAodGFnIHw9IDIpO1xuICAgICAgaXNTdHJpY3RNb2RlID0gY3JlYXRlRmliZXIoMywgbnVsbCwgbnVsbCwgdGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8uY3VycmVudCA9IGlzU3RyaWN0TW9kZTtcbiAgICAgIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICAgICAgdGFnID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgIHJldGFpbkNhY2hlKHRhZyk7XG4gICAgICBjb250YWluZXJJbmZvLnBvb2xlZENhY2hlID0gdGFnO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgICAgY2FjaGU6IHRhZ1xuICAgICAgfTtcbiAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZShpc1N0cmljdE1vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBpZiAoIXBhcmVudENvbXBvbmVudCkgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgIHBhcmVudENvbXBvbmVudCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lclN5bmMoXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIDAgPT09IGNvbnRhaW5lci50YWcgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgIDIsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgcm9vdEZpYmVyLFxuICAgICAgbGFuZSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3RcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCBjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICAgICAgPyAoY29udGFpbmVyLmNvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpXG4gICAgICAgIDogKGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpc1JlbmRlcmluZyAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzICYmXG4gICAgICAgICgoZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy5cIixcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICkpO1xuICAgICAgY29udGFpbmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgY29udGFpbmVyLnBheWxvYWQgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjayAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICksXG4gICAgICAgIChjb250YWluZXIuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICAgICAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSksXG4gICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiBudWxsICE9PSBmaWJlci5kZWh5ZHJhdGVkKSB7XG4gICAgICAgIHZhciBhID0gZmliZXIucmV0cnlMYW5lO1xuICAgICAgICBmaWJlci5yZXRyeUxhbmUgPSAwICE9PSBhICYmIGEgPCByZXRyeUxhbmUgPyBhIDogcmV0cnlMYW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSkgJiYgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpIHtcbiAgICAgIGZvciAodmFyIG1hcCA9IG5ldyBNYXAoKSwgbGFuZSA9IDEsIGluZGV4ID0gMDsgMzEgPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICAgIG1hcC5zZXQobGFuZSwgbGFiZWwpO1xuICAgICAgICBsYW5lICo9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIChcInVzZSBzdHJpY3RcIik7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgU2NoZWR1bGVyID0gcmVxdWlyZShcInNjaGVkdWxlclwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO1xuICAgIHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnRyYWNpbmdfbWFya2VyXCIpO1xuICAgIHZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY3VycmVudCA9IG51bGwsXG4gICAgICBpc1JlbmRlcmluZyA9ICExLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgcmVuZGVyZXJWZXJzaW9uID0gJCQkY29uZmlnLnJlbmRlcmVyVmVyc2lvbixcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWUgPSAkJCRjb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgIGV4dHJhRGV2VG9vbHNDb25maWcgPSAkJCRjb25maWcuZXh0cmFEZXZUb29sc0NvbmZpZyxcbiAgICAgIGdldFB1YmxpY0luc3RhbmNlID0gJCQkY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dCxcbiAgICAgIGdldENoaWxkSG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSAkJCRjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRjb25maWcucmVzZXRBZnRlckNvbW1pdCxcbiAgICAgIGNyZWF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gJCQkY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgc2NoZWR1bGVUaW1lb3V0ID0gJCQkY29uZmlnLnNjaGVkdWxlVGltZW91dCxcbiAgICAgIGNhbmNlbFRpbWVvdXQgPSAkJCRjb25maWcuY2FuY2VsVGltZW91dCxcbiAgICAgIG5vVGltZW91dCA9ICQkJGNvbmZpZy5ub1RpbWVvdXQsXG4gICAgICBpc1ByaW1hcnlSZW5kZXJlciA9ICQkJGNvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbiAgICAkJCRjb25maWcud2FybnNJZk5vdEFjdGluZztcbiAgICB2YXIgc3VwcG9ydHNNdXRhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c011dGF0aW9uLFxuICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGNvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlLFxuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNIeWRyYXRpb24sXG4gICAgICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgJCQkY29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICAkJCRjb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gICAgdmFyIHByZXBhcmVQb3J0YWxNb3VudCA9ICQkJGNvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG4gICAgJCQkY29uZmlnLnByZXBhcmVTY29wZVVwZGF0ZTtcbiAgICAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tU2NvcGU7XG4gICAgdmFyIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5zZXRDdXJyZW50VXBkYXRlUHJpb3JpdHksXG4gICAgICBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5LFxuICAgICAgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnJlc29sdmVVcGRhdGVQcmlvcml0eTtcbiAgICAkJCRjb25maWcucmVzb2x2ZUV2ZW50VHlwZTtcbiAgICAkJCRjb25maWcucmVzb2x2ZUV2ZW50VGltZVN0YW1wO1xuICAgIHZhciBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uID0gJCQkY29uZmlnLnNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24sXG4gICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRjb25maWcuZGV0YWNoRGVsZXRlZEluc3RhbmNlO1xuICAgICQkJGNvbmZpZy5yZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2s7XG4gICAgdmFyIG1heVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5U3VzcGVuZENvbW1pdCxcbiAgICAgIHByZWxvYWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5wcmVsb2FkSW5zdGFuY2UsXG4gICAgICBzdGFydFN1c3BlbmRpbmdDb21taXQgPSAkJCRjb25maWcuc3RhcnRTdXNwZW5kaW5nQ29tbWl0LFxuICAgICAgc3VzcGVuZEluc3RhbmNlID0gJCQkY29uZmlnLnN1c3BlbmRJbnN0YW5jZSxcbiAgICAgIHdhaXRGb3JDb21taXRUb0JlUmVhZHkgPSAkJCRjb25maWcud2FpdEZvckNvbW1pdFRvQmVSZWFkeSxcbiAgICAgIE5vdFBlbmRpbmdUcmFuc2l0aW9uID0gJCQkY29uZmlnLk5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0gJCQkY29uZmlnLkhvc3RUcmFuc2l0aW9uQ29udGV4dCxcbiAgICAgIHJlc2V0Rm9ybUluc3RhbmNlID0gJCQkY29uZmlnLnJlc2V0Rm9ybUluc3RhbmNlLFxuICAgICAgYmluZFRvQ29uc29sZSA9ICQkJGNvbmZpZy5iaW5kVG9Db25zb2xlLFxuICAgICAgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkY29uZmlnLnN1cHBvcnRzTWljcm90YXNrcyxcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrID0gJCQkY29uZmlnLnNjaGVkdWxlTWljcm90YXNrLFxuICAgICAgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkY29uZmlnLnN1cHBvcnRzVGVzdFNlbGVjdG9ycyxcbiAgICAgIGZpbmRGaWJlclJvb3QgPSAkJCRjb25maWcuZmluZEZpYmVyUm9vdCxcbiAgICAgIGdldEJvdW5kaW5nUmVjdCA9ICQkJGNvbmZpZy5nZXRCb3VuZGluZ1JlY3QsXG4gICAgICBnZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5nZXRUZXh0Q29udGVudCxcbiAgICAgIGlzSGlkZGVuU3VidHJlZSA9ICQkJGNvbmZpZy5pc0hpZGRlblN1YnRyZWUsXG4gICAgICBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlID0gJCQkY29uZmlnLm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUsXG4gICAgICBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkY29uZmlnLnNldEZvY3VzSWZGb2N1c2FibGUsXG4gICAgICBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyID0gJCQkY29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsXG4gICAgICBhcHBlbmRDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZCxcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGNvbW1pdFRleHRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGNvbW1pdE1vdW50ID0gJCQkY29uZmlnLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFVwZGF0ZSxcbiAgICAgIGluc2VydEJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbiAgICAgIHJlbW92ZUNoaWxkID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcixcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcucmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlSW5zdGFuY2UsXG4gICAgICBoaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICB1bmhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVJbnN0YW5jZSxcbiAgICAgIHVuaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICBjbGVhckNvbnRhaW5lciA9ICQkJGNvbmZpZy5jbGVhckNvbnRhaW5lcixcbiAgICAgIGNsb25lSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVDb250YWluZXJDaGlsZHJlbixcbiAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5yZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICBjbG9uZUhpZGRlbkluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2UsXG4gICAgICBjbG9uZUhpZGRlblRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUhpZGRlblRleHRJbnN0YW5jZSxcbiAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyxcbiAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrLFxuICAgICAgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzID1cbiAgICAgICAgJCQkY29uZmlnLmdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyxcbiAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5ID0gJCQkY29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5LFxuICAgICAgY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlciA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyLFxuICAgICAgaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyA9ICQkJGNvbmZpZy5pc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPVxuICAgICAgICAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9XG4gICAgICAgICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXIsXG4gICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkY29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeSxcbiAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcixcbiAgICAgIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzID1cbiAgICAgICAgJCQkY29uZmlnLnNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzLFxuICAgICAgZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyA9XG4gICAgICAgICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzLFxuICAgICAgZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyxcbiAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MgPVxuICAgICAgICAkJCRjb25maWcuZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyxcbiAgICAgIHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSxcbiAgICAgIHN1cHBvcnRzUmVzb3VyY2VzID0gJCQkY29uZmlnLnN1cHBvcnRzUmVzb3VyY2VzLFxuICAgICAgaXNIb3N0SG9pc3RhYmxlVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RIb2lzdGFibGVUeXBlLFxuICAgICAgZ2V0SG9pc3RhYmxlUm9vdCA9ICQkJGNvbmZpZy5nZXRIb2lzdGFibGVSb290LFxuICAgICAgZ2V0UmVzb3VyY2UgPSAkJCRjb25maWcuZ2V0UmVzb3VyY2UsXG4gICAgICBhY3F1aXJlUmVzb3VyY2UgPSAkJCRjb25maWcuYWNxdWlyZVJlc291cmNlLFxuICAgICAgcmVsZWFzZVJlc291cmNlID0gJCQkY29uZmlnLnJlbGVhc2VSZXNvdXJjZSxcbiAgICAgIGh5ZHJhdGVIb2lzdGFibGUgPSAkJCRjb25maWcuaHlkcmF0ZUhvaXN0YWJsZSxcbiAgICAgIG1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLm1vdW50SG9pc3RhYmxlLFxuICAgICAgdW5tb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy51bm1vdW50SG9pc3RhYmxlLFxuICAgICAgY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UsXG4gICAgICBwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzID0gJCQkY29uZmlnLnByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMsXG4gICAgICBtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0LFxuICAgICAgcHJlbG9hZFJlc291cmNlID0gJCQkY29uZmlnLnByZWxvYWRSZXNvdXJjZSxcbiAgICAgIHN1c3BlbmRSZXNvdXJjZSA9ICQkJGNvbmZpZy5zdXNwZW5kUmVzb3VyY2UsXG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgPSAkJCRjb25maWcuc3VwcG9ydHNTaW5nbGV0b25zLFxuICAgICAgcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIGNsZWFyU2luZ2xldG9uID0gJCQkY29uZmlnLmNsZWFyU2luZ2xldG9uLFxuICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLmFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICBpc0hvc3RTaW5nbGV0b25UeXBlID0gJCQkY29uZmlnLmlzSG9zdFNpbmdsZXRvblR5cGUsXG4gICAgICB2YWx1ZVN0YWNrID0gW107XG4gICAgdmFyIGZpYmVyU3RhY2sgPSBbXTtcbiAgICB2YXIgaW5kZXgkanNjb21wJDAgPSAtMSxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2ssXG4gICAgICBsb2ckMSA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgsXG4gICAgICBuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCxcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMyA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgICAgY2FuY2VsQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxcbiAgICAgIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgICAgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludCxcbiAgICAgIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgICBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxcbiAgICAgIGxvZyA9IFNjaGVkdWxlci5sb2csXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSxcbiAgICAgIHJlbmRlcmVySUQgPSBudWxsLFxuICAgICAgaW5qZWN0ZWRIb29rID0gbnVsbCxcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBudWxsLFxuICAgICAgaGFzTG9nZ2VkRXJyb3IgPSAhMSxcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBmb3JrU3RhY2sgPSBbXSxcbiAgICAgIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUZvcmtDb3VudCA9IDAsXG4gICAgICBpZFN0YWNrID0gW10sXG4gICAgICBpZFN0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlQ29udGV4dElkID0gMSxcbiAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBcIlwiLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBuZWVkc0VzY2FwaW5nID0gL1tcIicmPD5cXG5cXHRdfF5cXHN8XFxzJC8sXG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwsXG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCxcbiAgICAgIGlzSHlkcmF0aW5nID0gITEsXG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExLFxuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsLFxuICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSxcbiAgICAgIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiSHlkcmF0aW9uIE1pc21hdGNoIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgTm9Nb2RlID0gMCxcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBbXSxcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDAsXG4gICAgICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSAwLFxuICAgICAgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IC0wLFxuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMS4xLFxuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IC0wLFxuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gITEsXG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gITEsXG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMSxcbiAgICAgIGlzRmx1c2hpbmdXb3JrID0gITEsXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IDAsXG4gICAgICBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgPSB7fSxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsLFxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsLFxuICAgICAgVXBkYXRlU3RhdGUgPSAwLFxuICAgICAgUmVwbGFjZVN0YXRlID0gMSxcbiAgICAgIEZvcmNlVXBkYXRlID0gMixcbiAgICAgIENhcHR1cmVVcGRhdGUgPSAzLFxuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICExO1xuICAgIHZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIHZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITEsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgICAgICAgcmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9LFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSxcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSB8fFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgITAgIT09XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIDggJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIGlmICgwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUpIHtcbiAgICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgIH07XG4gICAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKSxcbiAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICB2YXIgc3RyaWN0Um9vdCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmliZXI7IG51bGwgIT09IG5vZGU7IClcbiAgICAgICAgbm9kZS5tb2RlICYgOCAmJiAoc3RyaWN0Um9vdCA9IG5vZGUpLCAobm9kZSA9IG5vZGUucmV0dXJuKTtcbiAgICAgIG51bGwgPT09IHN0cmljdFJvb3RcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKVxuICAgICAgICA6ICFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICgobm9kZSA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCkpLFxuICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCkpICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gbm9kZSAmJlxuICAgICAgICAgICAgKChub2RlID0gW10pLCBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIG5vZGUpKSxcbiAgICAgICAgICBub2RlLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSkge1xuICAgICAgICBpZiAoMCAhPT0gZmliZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF0sXG4gICAgICAgICAgICB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmlyc3RGaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS5cXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyB1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dFwiLFxuICAgICAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIHZhciBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWBcIlxuICAgICAgKSxcbiAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQSBsaXN0ZW5lciB3YXMgdW5leHBlY3RlZGx5IGF0dGFjaGVkIHRvIGEgXCJub29wXCIgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsLFxuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSxcbiAgICAgIGNhbGxDb21wb25lbnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudEluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxDb21wb25lbnQpLFxuICAgICAgY2FsbFJlbmRlciA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHdhc1JlbmRlcmluZyA9IGlzUmVuZGVyaW5nO1xuICAgICAgICAgIGlzUmVuZGVyaW5nID0gITA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbFJlbmRlckluREVWID0gY2FsbFJlbmRlcltcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxSZW5kZXIpLFxuICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrLCBpbnN0YW5jZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFViA9IGNhbGxDb21wb25lbnREaWRNb3VudFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRNb3VudCksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgc25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgc25hcHNob3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkVXBkYXRlW1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZFVwZGF0ZSksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2ggPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZXJyb3JJbmZvKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2s6IG51bGwgIT09IHN0YWNrID8gc3RhY2sgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViA9IGNhbGxDb21wb25lbnREaWRDYXRjaFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRDYXRjaCksXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViA9IGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnRXaWxsVW5tb3VudCksXG4gICAgICBjYWxsQ3JlYXRlID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lmluc3Q7XG4gICAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIChlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ3JlYXRlSW5ERVYgPSBjYWxsQ3JlYXRlW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENyZWF0ZSksXG4gICAgICBjYWxsRGVzdHJveSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBkZXN0cm95XG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsRGVzdHJveUluREVWID1cbiAgICAgICAgY2FsbERlc3Ryb3lbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsRGVzdHJveSksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbCxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwLFxuICAgICAgY3VycmVudERlYnVnSW5mbyA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gKGRpZFdhcm5BYm91dE1hcHMgPSAhMSk7XG4gICAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcbiAgICB2YXIgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyA9IHt9O1xuICAgIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY2hpbGQgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNoaWxkICYmXG4gICAgICAgIGNoaWxkLl9zdG9yZSAmJlxuICAgICAgICAoKCFjaGlsZC5fc3RvcmUudmFsaWRhdGVkICYmIG51bGwgPT0gY2hpbGQua2V5KSB8fFxuICAgICAgICAgIDIgPT09IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBjaGlsZC5fc3RvcmUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSAxO1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpLFxuICAgICAgICAgIGNvbXBvbmVudEtleSA9IGNvbXBvbmVudE5hbWUgfHwgXCJudWxsXCI7XG4gICAgICAgIGlmICghb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0pIHtcbiAgICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSA9ICEwO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX293bmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBcIlwiO1xuICAgICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIudGFnICYmXG4gICAgICAgICAgICAoY29tcG9uZW50S2V5ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikpICYmXG4gICAgICAgICAgICAoY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9XG4gICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgY29tcG9uZW50S2V5ICsgXCJgLlwiKTtcbiAgICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIHx8XG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAoY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICAgICAgXCI+LlwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkT3duZXJBcHBlbmRpeCA9IFwiXCI7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZCAmJlxuICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IGNoaWxkICYmXG4gICAgICAgICAgICAoKGNvbXBvbmVudE5hbWUgPSBudWxsKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZC50YWdcbiAgICAgICAgICAgICAgPyAoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY2hpbGQpKVxuICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZC5uYW1lICYmIChjb21wb25lbnROYW1lID0gY2hpbGQubmFtZSksXG4gICAgICAgICAgICBjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChjaGlsZE93bmVyQXBwZW5kaXggPVxuICAgICAgICAgICAgICAgIFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY29tcG9uZW50TmFtZSArIFwiLlwiKSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyxcbiAgICAgICAgICAgICAgY2hpbGRPd25lckFwcGVuZGl4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITApLFxuICAgICAgbW91bnRDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMSksXG4gICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBzaGVsbEJvdW5kYXJ5ID0gbnVsbCxcbiAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMSxcbiAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDIsXG4gICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgTm9GbGFncyA9IDAsXG4gICAgICBIYXNFZmZlY3QgPSAxLFxuICAgICAgSW5zZXJ0aW9uID0gMixcbiAgICAgIExheW91dCA9IDQsXG4gICAgICBQYXNzaXZlID0gOCxcbiAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xuICAgIHZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciByZW5kZXJMYW5lcyA9IDAsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMSxcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGdsb2JhbENsaWVudElkQ291bnRlciA9IDAsXG4gICAgICBSRV9SRU5ERVJfTElNSVQgPSAyNSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwsXG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xLFxuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICB2YXIgY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGxhc3RFZmZlY3Q6IG51bGwsIGV2ZW50czogbnVsbCwgc3RvcmVzOiBudWxsLCBtZW1vQ2FjaGU6IG51bGwgfTtcbiAgICB9O1xuICAgIHZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSWQ6IHRocm93SW52YWxpZEhvb2tFcnJvclxuICAgIH07XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlTWVtb0NhY2hlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICB2YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgdmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgdmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gb3duZXIgJiYgaXNSZW5kZXJpbmcgJiYgMSA9PT0gb3duZXIudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBvd25lci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gcmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCBuZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyByZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKSB8fCBcIkEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKGNvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHMpXG4gICAgICAgICAgICA/IGdldE5lYXJlc3RNb3VudGVkRmliZXIoY29tcG9uZW50KSA9PT0gY29tcG9uZW50XG4gICAgICAgICAgICA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICAgICAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoY2FsbGJhY2ssIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhjYWxsYmFjaywgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgY29tcG9uZW50TmFtZSA9IG51bGwsXG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGwsXG4gICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIFJlYWN0J3Mgc2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKSxcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbiAgICB2YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgICAgICAgZGVoeWRyYXRlZDogbnVsbCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IG51bGwsXG4gICAgICAgIHJldHJ5TGFuZTogMFxuICAgICAgfSxcbiAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITEsXG4gICAgICB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyMkN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGwsXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsLFxuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExLFxuICAgICAgQWJvcnRDb250cm9sbGVyTG9jYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgPyBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICh0aGlzLnNpZ25hbCA9IHtcbiAgICAgICAgICAgICAgICAgIGFib3J0ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWJvcnRlZCA9ICEwO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgc2NoZWR1bGVDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgIENhY2hlQ29udGV4dCA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyMjogbnVsbFxuICAgICAgfSxcbiAgICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICBudWxsICE9PSBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICB9O1xuICAgIHZhciByZXN1bWVkQ2FjaGUgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG4gICAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9ICExLFxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9ICExLFxuICAgICAgbmVlZHNGb3JtUmVzZXQgPSAhMSxcbiAgICAgIFBvc3NpYmx5V2Vha1NldCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgPyBXZWFrU2V0IDogU2V0LFxuICAgICAgbmV4dEVmZmVjdCA9IG51bGwsXG4gICAgICBpblByb2dyZXNzTGFuZXMgPSBudWxsLFxuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITEsXG4gICAgICBob3N0UGFyZW50ID0gbnVsbCxcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExLFxuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsLFxuICAgICAgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDgxOTIsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uIChyZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpLFxuICAgICAgICAgICAgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcbiAgICAgICAgICB2b2lkIDAgPT09IGNhY2hlRm9yVHlwZSAmJlxuICAgICAgICAgICAgKChjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKSksXG4gICAgICAgICAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSkpO1xuICAgICAgICAgIHJldHVybiBjYWNoZUZvclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDT01QT05FTlRfVFlQRSA9IDAsXG4gICAgICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSAxLFxuICAgICAgUk9MRV9UWVBFID0gMixcbiAgICAgIFRFU1RfTkFNRV9UWVBFID0gMyxcbiAgICAgIFRFWFRfVFlQRSA9IDQ7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gICAgICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgICAgIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IuY29tcG9uZW50XCIpO1xuICAgICAgSEFTX1BTRVVET19DTEFTU19UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzc1wiKTtcbiAgICAgIFJPTEVfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnJvbGVcIik7XG4gICAgICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnRlc3RfaWRcIik7XG4gICAgICBURVhUX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci50ZXh0XCIpO1xuICAgIH1cbiAgICB2YXIgY29tbWl0SG9va3MgPSBbXSxcbiAgICAgIFBvc3NpYmx5V2Vha01hcCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwLFxuICAgICAgTm9Db250ZXh0ID0gMCxcbiAgICAgIFJlbmRlckNvbnRleHQgPSAyLFxuICAgICAgQ29tbWl0Q29udGV4dCA9IDQsXG4gICAgICBSb290SW5Qcm9ncmVzcyA9IDAsXG4gICAgICBSb290RmF0YWxFcnJvcmVkID0gMSxcbiAgICAgIFJvb3RFcnJvcmVkID0gMixcbiAgICAgIFJvb3RTdXNwZW5kZWQgPSAzLFxuICAgICAgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQsXG4gICAgICBSb290Q29tcGxldGVkID0gNSxcbiAgICAgIFJvb3REaWROb3RDb21wbGV0ZSA9IDYsXG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0LFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCxcbiAgICAgIE5vdFN1c3BlbmRlZCA9IDAsXG4gICAgICBTdXNwZW5kZWRPbkVycm9yID0gMSxcbiAgICAgIFN1c3BlbmRlZE9uRGF0YSA9IDIsXG4gICAgICBTdXNwZW5kZWRPbkltbWVkaWF0ZSA9IDMsXG4gICAgICBTdXNwZW5kZWRPbkluc3RhbmNlID0gNCxcbiAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUgPSA1LFxuICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlID0gNixcbiAgICAgIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSA9IDcsXG4gICAgICBTdXNwZW5kZWRPbkh5ZHJhdGlvbiA9IDgsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCxcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITEsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICExLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITEsXG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3MsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExLFxuICAgICAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDAsXG4gICAgICBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDMwMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eSxcbiAgICAgIFJFTkRFUl9USU1FT1VUX01TID0gNTAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGwsXG4gICAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwsXG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExLFxuICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGwsXG4gICAgICBORVNURURfVVBEQVRFX0xJTUlUID0gNTAsXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCxcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExLFxuICAgICAgSU1NRURJQVRFX0NPTU1JVCA9IDAsXG4gICAgICBTVVNQRU5ERURfQ09NTUlUID0gMSxcbiAgICAgIFRIUk9UVExFRF9DT01NSVQgPSAyLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGZha2VBY3RDYWxsYmFja05vZGUgPSB7fSxcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBudWxsLFxuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgdmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gITA7XG4gICAgfVxuICAgIHZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG4gICAgdmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wcyA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBzY2hlZHVsZVVwZGF0ZSA9IG51bGwsXG4gICAgICBzZXRFcnJvckhhbmRsZXIgPSBudWxsLFxuICAgICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aFNldEltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCwgdmFsdWUpKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAocGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChwYXRoID0gY29weVdpdGhEZWxldGVJbXBsKGlkLm1lbW9pemVkU3RhdGUsIHBhdGgsIDApKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAocGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChvbGRQYXRoID0gY29weVdpdGhSZW5hbWUoaWQubWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IG9sZFBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXRJbXBsKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIDAsIHZhbHVlKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZUltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgcGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoXG4gICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIG9sZFBhdGgsXG4gICAgICAgIG5ld1BhdGhcbiAgICAgICk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgb2xkUGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBvbGRQYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihvbGRQYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZEVycm9ySW1wbCkge1xuICAgICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICAgIH07XG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICAgIH07XG4gICAgZXhwb3J0cy5hdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSxcbiAgICAgICAgICByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZpYmVyID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaWJlci5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhmaWJlci5wZW5kaW5nTGFuZXMpO1xuICAgICAgICAgICAgaWYgKDAgIT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgIGZpYmVyLnBlbmRpbmdMYW5lcyB8PSAyO1xuICAgICAgICAgICAgICBmb3IgKGZpYmVyLmVudGFuZ2xlZExhbmVzIHw9IDI7IGxhbmVzOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IDEgPDwgKDMxIC0gY2x6MzIobGFuZXMpKTtcbiAgICAgICAgICAgICAgICBmaWJlci5lbnRhbmdsZW1lbnRzWzFdIHw9IGxhbmU7XG4gICAgICAgICAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGZpYmVyKTtcbiAgICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT1cbiAgICAgICAgICAgICAgICBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPVxuICAgICAgICAgICAgICAgICAgbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TKSxcbiAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAobGFuZXMgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICAgIG51bGwgIT09IGxhbmVzICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihsYW5lcywgZmliZXIsIDIpLFxuICAgICAgICAgICAgZmx1c2hTeW5jV29yaygpLFxuICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBDT01QT05FTlRfVFlQRSwgdmFsdWU6IGNvbXBvbmVudCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrc1xuICAgICkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICAhMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IEhBU19QU0VVRE9fQ0xBU1NfVFlQRSwgdmFsdWU6IHNlbGVjdG9ycyB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBjYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4gPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgITAsXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICAgICAgY29udGFpbmVySW5mbyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICAgICAgdGFnID0gcmVxdWVzdFVwZGF0ZUxhbmUoY29udGFpbmVySW5mbyk7XG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MgPSBjcmVhdGVVcGRhdGUodGFnKTtcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcy5jYWxsYmFjayA9XG4gICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IG51bGw7XG4gICAgICBlbnF1ZXVlVXBkYXRlKGNvbnRhaW5lckluZm8sIGh5ZHJhdGlvbkNhbGxiYWNrcywgdGFnKTtcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jdXJyZW50LmxhbmVzID0gdGFnO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEoaW5pdGlhbENoaWxkcmVuLCB0YWcpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gICAgICByZXR1cm4gaW5pdGlhbENoaWxkcmVuO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICB2YXIga2V5ID1cbiAgICAgICAgMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUkNikge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICBrZXlbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICAgIGtleS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgICBcIk9iamVjdFwiXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICAgICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBST0xFX1RZUEUsIHZhbHVlOiByb2xlIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBURVNUX05BTUVfVFlQRSwgdmFsdWU6IGlkIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRleHRTZWxlY3RvciA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogVEVYVF9UWVBFLCB2YWx1ZTogdGV4dCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25DYXVnaHRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lXG4gICAgICAgICAgPyBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgICA6IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCIsXG4gICAgICAgIHJlY3JlYXRlTWVzc2FnZSA9XG4gICAgICAgICAgXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCB1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCBcIiArXG4gICAgICAgICAgKChlcnJvckJvdW5kYXJ5TmFtZSB8fCBcIkFub255bW91c1wiKSArIFwiLlwiKSxcbiAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgPyBiaW5kVG9Db25zb2xlKFxuICAgICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICAgICkoKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlb1xcblxcbiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgICByZWNyZWF0ZU1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPblVuY2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgZXJyb3IgPSBjb21wb25lbnROYW1lXG4gICAgICAgID8gXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgOiBcIkFuIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCI7XG4gICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBcIkNvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcblZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmVycmVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMzIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbigpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICBmbihhLCBiLCBjLCBkKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5maW5kQWxsTm9kZXMgPSBmaW5kQWxsTm9kZXM7XG4gICAgZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgc2VsZWN0b3JzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgaG9zdFJvb3QgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKVxuICAgICAgICBob3N0Um9vdC5wdXNoKGdldEJvdW5kaW5nUmVjdChzZWxlY3RvcnNbaV0pKTtcbiAgICAgIGZvciAoc2VsZWN0b3JzID0gaG9zdFJvb3QubGVuZ3RoIC0gMTsgMCA8IHNlbGVjdG9yczsgc2VsZWN0b3JzLS0pIHtcbiAgICAgICAgaSA9IGhvc3RSb290W3NlbGVjdG9yc107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHRhcmdldExlZnQgPSBpLngsXG4gICAgICAgICAgICB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyBpLndpZHRoLFxuICAgICAgICAgICAgdGFyZ2V0VG9wID0gaS55LFxuICAgICAgICAgICAgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0VG9wICsgaS5oZWlnaHQsXG4gICAgICAgICAgICBqID0gc2VsZWN0b3JzIC0gMTtcbiAgICAgICAgICAwIDw9IGo7XG4gICAgICAgICAgai0tXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoc2VsZWN0b3JzICE9PSBqKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJSZWN0ID0gaG9zdFJvb3Rbal0sXG4gICAgICAgICAgICAgIG90aGVyTGVmdCA9IG90aGVyUmVjdC54LFxuICAgICAgICAgICAgICBvdGhlclJpZ2h0ID0gb3RoZXJMZWZ0ICsgb3RoZXJSZWN0LndpZHRoLFxuICAgICAgICAgICAgICBvdGhlclRvcCA9IG90aGVyUmVjdC55LFxuICAgICAgICAgICAgICBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA+PSBvdGhlckxlZnQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID49IG90aGVyVG9wICYmXG4gICAgICAgICAgICAgIHRhcmdldFJpZ2h0IDw9IG90aGVyUmlnaHQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0Qm90dG9tIDw9IG90aGVyQm90dG9tXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ICE9PSBvdGhlckxlZnQgfHxcbiAgICAgICAgICAgICAgICBpLndpZHRoICE9PSBvdGhlclJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgICAgICBvdGhlckJvdHRvbSA8IHRhcmdldFRvcCB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9wID4gdGFyZ2V0Qm90dG9tXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvdGhlclRvcCA+IHRhcmdldFRvcCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LmhlaWdodCArPSBvdGhlclRvcCAtIHRhcmdldFRvcCksXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC55ID0gdGFyZ2V0VG9wKSk7XG4gICAgICAgICAgICAgIG90aGVyQm90dG9tIDwgdGFyZ2V0Qm90dG9tICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcCk7XG4gICAgICAgICAgICAgIGhvc3RSb290LnNwbGljZShzZWxlY3RvcnMsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG9wICE9PSBvdGhlclRvcCB8fFxuICAgICAgICAgICAgICAgIGkuaGVpZ2h0ICE9PSBvdGhlclJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldExlZnQgfHxcbiAgICAgICAgICAgICAgICBvdGhlckxlZnQgPiB0YXJnZXRSaWdodFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3RoZXJMZWZ0ID4gdGFyZ2V0TGVmdCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LndpZHRoICs9IG90aGVyTGVmdCAtIHRhcmdldExlZnQpLFxuICAgICAgICAgICAgICAgIChvdGhlclJlY3QueCA9IHRhcmdldExlZnQpKTtcbiAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldFJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0KTtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0Um9vdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBmaWJlciA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50LnJlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIGNvbXBvbmVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbihcIixcIik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBjb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjb21wb25lbnQgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoY29tcG9uZW50LnN0YXRlTm9kZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgICAgIGZpYmVyID1cbiAgICAgICAgbnVsbCAhPT0gZmliZXIgPyBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGZpYmVyKSA6IG51bGw7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZmliZXIgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoZmliZXIuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50ID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IGNvbXBvbmVudCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoY29tcG9uZW50Lm1vZGUgJiA4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmliZXIubW9kZSAmIDhcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGVcIixcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiBJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlXCIsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb21wb25lbnQuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHM7XG4gICAgZXhwb3J0cy5mbHVzaFN5bmNGcm9tUmVjb25jaWxlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gMTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICgoc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbikpXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmZsdXNoU3luY1dvcmsgPSBmbHVzaFN5bmNXb3JrO1xuICAgIGV4cG9ydHMuZm9jdXNXaXRoaW4gPSBmdW5jdGlvbiAoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIHNlbGVjdG9ycyA9IGZpbmRQYXRocyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIHNlbGVjdG9ycyA9IEFycmF5LmZyb20oc2VsZWN0b3JzKTtcbiAgICAgIGZvciAoaG9zdFJvb3QgPSAwOyBob3N0Um9vdCA8IHNlbGVjdG9ycy5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBzZWxlY3RvcnNbaG9zdFJvb3QrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnO1xuICAgICAgICBpZiAoIWlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZykgJiZcbiAgICAgICAgICAgIHNldEZvY3VzSWZGb2N1c2FibGUoZmliZXIuc3RhdGVOb2RlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChmaWJlciksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIG1heFNlbGVjdG9ySW5kZXggPSAwLFxuICAgICAgICBtYXRjaGVkTmFtZXMgPSBbXTtcbiAgICAgIGhvc3RSb290ID0gW2ZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCksIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgICBzZWxlY3RvckluZGV4ID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmICgoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHwgIWlzSGlkZGVuU3VidHJlZShmaWJlcikpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSAmJlxuICAgICAgICAgICAgICAobWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikpLFxuICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4ICYmXG4gICAgICAgICAgICAgICAgKG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4KSksXG4gICAgICAgICAgICBzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aClcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgIGhvc3RSb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGhvc3RSb290ID0gW107XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGg7XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCsrXG4gICAgICAgIClcbiAgICAgICAgICBob3N0Um9vdC5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3JzW21heFNlbGVjdG9ySW5kZXhdKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgXCJmaW5kQWxsTm9kZXMgd2FzIGFibGUgdG8gbWF0Y2ggcGFydCBvZiB0aGUgc2VsZWN0b3I6XFxuICBcIiArXG4gICAgICAgICAgKG1hdGNoZWROYW1lcy5qb2luKFwiID4gXCIpICtcbiAgICAgICAgICAgIFwiXFxuXFxuTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuICBcIikgK1xuICAgICAgICAgIGhvc3RSb290LmpvaW4oXCIgPiBcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyLmNoaWxkKSByZXR1cm4gbnVsbDtcbiAgICAgIHN3aXRjaCAoY29udGFpbmVyLmNoaWxkLnRhZykge1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXJuYWxzID0ge1xuICAgICAgICBidW5kbGVUeXBlOiAxLFxuICAgICAgICB2ZXJzaW9uOiByZW5kZXJlclZlcnNpb24sXG4gICAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IHJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICAgIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjAuMFwiXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gZXh0cmFEZXZUb29sc0NvbmZpZyAmJlxuICAgICAgICAoaW50ZXJuYWxzLnJlbmRlcmVyQ29uZmlnID0gZXh0cmFEZXZUb29sc0NvbmZpZyk7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGUgPSBvdmVycmlkZUhvb2tTdGF0ZTtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHMgPSBvdmVycmlkZVByb3BzO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVVwZGF0ZSA9IHNjaGVkdWxlVXBkYXRlO1xuICAgICAgaW50ZXJuYWxzLnNldEVycm9ySGFuZGxlciA9IHNldEVycm9ySGFuZGxlcjtcbiAgICAgIGludGVybmFscy5zZXRTdXNwZW5zZUhhbmRsZXIgPSBzZXRTdXNwZW5zZUhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSZWZyZXNoID0gc2NoZWR1bGVSZWZyZXNoO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlUm9vdCA9IHNjaGVkdWxlUm9vdDtcbiAgICAgIGludGVybmFscy5zZXRSZWZyZXNoSGFuZGxlciA9IHNldFJlZnJlc2hIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLmdldEN1cnJlbnRGaWJlciA9IGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzO1xuICAgICAgaW50ZXJuYWxzLmdldExhbmVMYWJlbE1hcCA9IGdldExhbmVMYWJlbE1hcDtcbiAgICAgIGludGVybmFscy5pbmplY3RQcm9maWxpbmdIb29rcyA9IGluamVjdFByb2ZpbGluZ0hvb2tzO1xuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0FscmVhZHlSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0O1xuICAgIH07XG4gICAgZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gZnVuY3Rpb24gKFxuICAgICAgaG9zdFJvb3QsXG4gICAgICBzZWxlY3RvcnMsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2soKSB7XG4gICAgICAgIHZhciBuZXh0SW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAwID4gbmV4dEluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpICYmIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV4dEluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgMCA+IGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpICYmIG9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBjYWxsYmFjayA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgdmFyIGRpc2Nvbm5lY3QgPSBjYWxsYmFjay5kaXNjb25uZWN0LFxuICAgICAgICBvYnNlcnZlID0gY2FsbGJhY2sub2JzZXJ2ZSxcbiAgICAgICAgdW5vYnNlcnZlID0gY2FsbGJhY2sudW5vYnNlcnZlO1xuICAgICAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjb21taXRIb29rcy5pbmRleE9mKGNvbW1pdEhvb2spO1xuICAgICAgICAgIDAgPD0gaW5kZXggJiYgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBkaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLnNob3VsZEVycm9yID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2hvdWxkU3VzcGVuZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRIb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChcbiAgICAgIGZvcm1GaWJlcixcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIGZvcm1EYXRhXG4gICAgKSB7XG4gICAgICBpZiAoNSAhPT0gZm9ybUZpYmVyLnRhZylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0aGUgZm9ybSBpbnN0YW5jZSB0byBiZSBhIEhvc3RDb21wb25lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBxdWV1ZSA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikucXVldWU7XG4gICAgICBzdGFydFRyYW5zaXRpb24oXG4gICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIG51bGwgPT09IGFjdGlvblxuICAgICAgICAgID8gbm9vcFxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwicmVxdWVzdEZvcm1SZXNldCB3YXMgY2FsbGVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciByZXNldFN0YXRlUXVldWUgPVxuICAgICAgICAgICAgICAgIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikubmV4dC5xdWV1ZTtcbiAgICAgICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgICAgICAgICByZXNldFN0YXRlUXVldWUsXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZm9ybUZpYmVyKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKGZvcm1EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVwZGF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudCxcbiAgICAgICAgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgbGFuZSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfTtcbiAgICBleHBvcnRzLnVwZGF0ZUNvbnRhaW5lclN5bmMgPSB1cGRhdGVDb250YWluZXJTeW5jO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9KSxcbiAgKG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cyksXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiJCQkY29uZmlnIiwiZmluZEhvb2siLCJmaWJlciIsImlkIiwibWVtb2l6ZWRTdGF0ZSIsIm5leHQiLCJjb3B5V2l0aFNldEltcGwiLCJvYmoiLCJwYXRoIiwiaW5kZXgiLCJ2YWx1ZSIsImxlbmd0aCIsImtleSIsInVwZGF0ZWQiLCJpc0FycmF5SW1wbCIsInNsaWNlIiwiYXNzaWduIiwiY29weVdpdGhSZW5hbWUiLCJvbGRQYXRoIiwibmV3UGF0aCIsImNvbnNvbGUiLCJ3YXJuIiwiaSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZEtleSIsInNwbGljZSIsImNvcHlXaXRoRGVsZXRlSW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwic2hvdWxkRXJyb3JJbXBsIiwiY3JlYXRlRmliZXIiLCJ0YWciLCJwZW5kaW5nUHJvcHMiLCJtb2RlIiwiRmliZXJOb2RlIiwic2NoZWR1bGVSb290Iiwicm9vdCIsImVsZW1lbnQiLCJjb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwidXBkYXRlQ29udGFpbmVyU3luYyIsImZsdXNoU3luY1dvcmsiLCJzY2hlZHVsZVJlZnJlc2giLCJ1cGRhdGUiLCJyZXNvbHZlRmFtaWx5Iiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsImZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5IiwiY3VycmVudCIsInNldFJlZnJlc2hIYW5kbGVyIiwiaGFuZGxlciIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsImVycm9yIiwid2FybkludmFsaWRDb250ZXh0QWNjZXNzIiwibm9vcCIsIndhcm5Gb3JNaXNzaW5nS2V5Iiwic2V0VG9Tb3J0ZWRTdHJpbmciLCJzZXQiLCJhcnJheSIsImZvckVhY2giLCJwdXNoIiwic29ydCIsImpvaW4iLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9DT05TVU1FUl9UWVBFIiwiX2NvbnRleHQiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiaW5uZXJUeXBlIiwicmVuZGVyIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiX3BheWxvYWQiLCJfaW5pdCIsIngiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiX2RlYnVnSW5mbyIsInJldHVybiIsImRpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsImxvZyIsInByZXZJbmZvIiwiaW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwiZ3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJncm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJwcmVmaXgiLCJFcnJvciIsIm1hdGNoIiwic3RhY2siLCJ0cmltIiwic3VmZml4IiwiaW5kZXhPZiIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsInJlZW50cnkiLCJmcmFtZSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJnZXQiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiSCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiRmFrZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiUmVmbGVjdCIsImNvbnRyb2wiLCJjYWxsIiwieCQwIiwieCQxIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJpbmNsdWRlcyIsIl9mcmFtZSIsInJlcGxhY2UiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJkZWJ1Z0luZm8iLCJlbnRyeSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsImVudiIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCIsIm1lc3NhZ2UiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicnVuV2l0aEZpYmVySW5ERVYiLCJjYWxsYmFjayIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwicHJldmlvdXNGaWJlciIsImdldEN1cnJlbnRTdGFjayIsImlzUmVuZGVyaW5nIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsImZsYWdzIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwiY2hpbGQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwic3RhdGVOb2RlIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlckltcGwiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsIiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwiaW5kZXgkanNjb21wJDAiLCJmaWJlclN0YWNrIiwidmFsdWVTdGFjayIsImNsejMyRmFsbGJhY2siLCJsb2ckMSIsIkxOMiIsImdldExhYmVsRm9yTGFuZSIsImxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsImxhbmVzIiwicGVuZGluZ1N5bmNMYW5lcyIsImdldE5leHRMYW5lcyIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIndhcm1MYW5lcyIsImZpbmlzaGVkTGFuZXMiLCJub25JZGxlUGVuZGluZ0xhbmVzIiwiY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyIsInJlbmRlckxhbmVzIiwiY29tcHV0ZUV4cGlyYXRpb25UaW1lIiwiY3VycmVudFRpbWUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsIm5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsIm5leHRSZXRyeUxhbmUiLCJjcmVhdGVMYW5lTWFwIiwiaW5pdGlhbCIsImxhbmVNYXAiLCJtYXJrUm9vdFVwZGF0ZWQkMSIsInVwZGF0ZUxhbmUiLCJtYXJrUm9vdEZpbmlzaGVkIiwicmVtYWluaW5nTGFuZXMiLCJzcGF3bmVkTGFuZSIsInVwZGF0ZWRMYW5lcyIsInN1c3BlbmRlZFJldHJ5TGFuZXMiLCJwcmV2aW91c2x5UGVuZGluZ0xhbmVzIiwiZXhwaXJlZExhbmVzIiwiZW50YW5nbGVkTGFuZXMiLCJlcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyIsInNoZWxsU3VzcGVuZENvdW50ZXIiLCJlbnRhbmdsZW1lbnRzIiwiZXhwaXJhdGlvblRpbWVzIiwiaGlkZGVuVXBkYXRlcyIsImNsejMyIiwiaGlkZGVuVXBkYXRlc0ZvckxhbmUiLCJtYXJrU3Bhd25lZERlZmVycmVkTGFuZSIsInNwYXduZWRMYW5lSW5kZXgiLCJtYXJrUm9vdEVudGFuZ2xlZCIsInJvb3RFbnRhbmdsZWRMYW5lcyIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsImFkZCIsIm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZCIsIm1lbW9pemVkVXBkYXRlcnMiLCJzaXplIiwiaGFzIiwiY2xlYXIiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImhvb2siLCJpc0Rpc2FibGVkIiwic3VwcG9ydHNGaWJlciIsInJlbmRlcmVySUQiLCJpbmplY3QiLCJpbmplY3RlZEhvb2siLCJlcnIiLCJjaGVja0RDRSIsIm9uQ29tbWl0Um9vdCQxIiwiZXZlbnRQcmlvcml0eSIsIm9uQ29tbWl0RmliZXJSb290IiwiZGlkRXJyb3IiLCJzY2hlZHVsZXJQcmlvcml0eSIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSQxIiwiSWRsZVByaW9yaXR5IiwiaGFzTG9nZ2VkRXJyb3IiLCJzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyIsIm5ld0lzU3RyaWN0TW9kZSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwic2V0U3RyaWN0TW9kZSIsImluamVjdFByb2ZpbGluZ0hvb2tzIiwicHJvZmlsaW5nSG9va3MiLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya1JlbmRlclN0YXJ0ZWQiLCJtYXJrUmVuZGVyU3RvcHBlZCIsIm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCIsImlzIiwieSIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwic291cmNlIiwiZXhpc3RpbmciLCJDYXB0dXJlZFN0YWNrcyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrQ291bnQiLCJ0cmVlRm9ya1Byb3ZpZGVyIiwicHVzaFRyZWVJZCIsImlkU3RhY2siLCJpZFN0YWNrSW5kZXgiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VMZW5ndGgiLCJudW1iZXJPZk92ZXJmbG93Qml0cyIsInRvU3RyaW5nIiwicHVzaE1hdGVyaWFsaXplZFRyZWVJZCIsInBvcFRyZWVDb250ZXh0IiwiaXNIeWRyYXRpbmciLCJyZXF1aXJlZENvbnRleHQiLCJjIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsImNvbnRleHRTdGFja0N1cnNvciIsImdldFJvb3RIb3N0Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJnZXRIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGV4dCIsImhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IiLCJuZXh0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsImlzUHJpbWFyeVJlbmRlcmVyIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0IiwiX2N1cnJlbnRWYWx1ZSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwiX2N1cnJlbnRWYWx1ZTIiLCJmaW5kTm90YWJsZU5vZGUiLCJpbmRlbnQiLCJzZXJ2ZXJQcm9wcyIsInNlcnZlclRhaWwiLCJjaGlsZHJlbiIsImRpc3RhbmNlRnJvbUxlYWYiLCJpbmRlbnRhdGlvbiIsInJlcGVhdCIsImFkZGVkIiwicmVtb3ZlZCIsImRlc2NyaWJlRmliZXJUeXBlIiwiZGVzY3JpYmVUZXh0Tm9kZSIsImNvbnRlbnQiLCJtYXhMZW5ndGgiLCJuZWVkc0VzY2FwaW5nIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZXNjcmliZVRleHREaWZmIiwiY2xpZW50VGV4dCIsImZpcnN0RGlmZiIsImNoYXJDb2RlQXQiLCJvYmplY3ROYW1lIiwib2JqZWN0IiwibSIsInAwIiwiZGVzY3JpYmVWYWx1ZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsInByb3BOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJqc29uUHJvcE5hbWUiLCJTdHJpbmciLCJkZXNjcmliZVByb3BWYWx1ZSIsImRlc2NyaWJlRXhwYW5kZWRFbGVtZW50Iiwicm93UHJlZml4IiwicmVtYWluaW5nUm93TGVuZ3RoIiwicHJvcGVydGllcyIsInByb3BWYWx1ZSIsImRlc2NyaWJlUHJvcGVydGllc0RpZmYiLCJjbGllbnRPYmplY3QiLCJzZXJ2ZXJPYmplY3QiLCJyZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzIiwiY2xpZW50UHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiZGVzY3JpYmVFbGVtZW50RGlmZiIsImNsaWVudFByb3BzIiwic2VydmVyUHJvcE5hbWVzIiwiTWFwIiwicHJvcE5hbWUkanNjb21wJDAiLCJ0b0xvd2VyQ2FzZSIsIl9wcm9wTmFtZTIiLCJtYXhMZW5ndGgkanNjb21wJDAiLCJzZXJ2ZXJQcm9wTmFtZSIsImRlbGV0ZSIsImtleXMiLCJkZXNjcmliZVNpYmxpbmdGaWJlciIsImRlc2NyaWJlTm9kZSIsInNraXBUb05vZGUiLCJzZXJ2ZXJDb21wb25lbnROYW1lIiwiZGVzY3JpYmVEaWZmIiwicm9vdE5vZGUiLCJidWlsZEh5ZHJhdGlvbkRpZmZOb2RlIiwiaHlkcmF0aW9uRGlmZlJvb3RERVYiLCJzaWJsaW5ncyIsIndhcm5Ob25IeWRyYXRlZEluc3RhbmNlIiwicmVqZWN0ZWRDYW5kaWRhdGUiLCJkaWRTdXNwZW5kT3JFcnJvckRFViIsImRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MiLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJkaWZmIiwiZGlmZlJvb3QiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24iLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsImh5ZHJhdGVJbnN0YW5jZSIsIm1lbW9pemVkUHJvcHMiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJyb290T3JTaW5nbGV0b25Db250ZXh0IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJzaG91bGRDbGVhciIsInN1cHBvcnRzU2luZ2xldG9ucyIsInNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzIiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZGlmZk5vZGUiLCJkZXNjcmlwdGlvbiIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJkZWh5ZHJhdGVkIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsImh5ZHJhdGlvbkVycm9ycyIsImVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MiLCJmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzIiwiZW5kSW5kZXgiLCJjb25jdXJyZW50UXVldWVzSW5kZXgiLCJjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJjb25jdXJyZW50UXVldWVzIiwicXVldWUiLCJwZW5kaW5nIiwibWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUiLCJnZXRSb290Rm9yVXBkYXRlZEZpYmVyIiwiZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lIiwic291cmNlRmliZXIiLCJpc0hpZGRlbiIsImNoaWxkTGFuZXMiLCJfdmlzaWJpbGl0eSIsIm5lc3RlZFVwZGF0ZUNvdW50IiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMiLCJyb290V2l0aE5lc3RlZFVwZGF0ZXMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJ3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWIiwicHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucyIsInByZXZFZmZlY3REdXJhdGlvbiIsInByb2ZpbGVyRWZmZWN0RHVyYXRpb24iLCJwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJlbGFwc2VkVGltZSIsImJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyIsInN0YXJ0UHJvZmlsZXJUaW1lciIsInByb2ZpbGVyU3RhcnRUaW1lIiwibm93IiwiYWN0dWFsU3RhcnRUaW1lIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbiIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uIiwicmVjb3JkRWZmZWN0RHVyYXRpb24iLCJzdGFydEVmZmVjdFRpbWVyIiwidHJhbnNmZXJBY3R1YWxEdXJhdGlvbiIsImVuc3VyZVJvb3RJc1NjaGVkdWxlZCIsImxhc3RTY2hlZHVsZWRSb290IiwiZmlyc3RTY2hlZHVsZWRSb290IiwibWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrIiwiYWN0UXVldWUiLCJkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QiLCJzY2hlZHVsZUltbWVkaWF0ZVRhc2siLCJwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2siLCJkaWRTY2hlZHVsZU1pY3JvdGFzayIsImZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsIiwic3luY1RyYW5zaXRpb25MYW5lcyIsIm9ubHlMZWdhY3kiLCJpc0ZsdXNoaW5nV29yayIsImRpZFBlcmZvcm1Tb21lV29yayIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290IiwiY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwibm93JDEiLCJwcmV2Iiwic2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayIsImV4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tOb2RlIiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24iLCJTdXNwZW5kZWRPbkRhdGEiLCJjYW5jZWxQZW5kaW5nQ29tbWl0IiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja1ByaW9yaXR5IiwiZmFrZUFjdENhbGxiYWNrTm9kZSQxIiwicGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrIiwiYmluZCIsInNjaGVkdWxlQ2FsbGJhY2skMyIsImRpZFRpbWVvdXQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJvcmlnaW5hbENhbGxiYWNrTm9kZSIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIiwicGVyZm9ybVdvcmtPblJvb3QiLCJjYW5jZWxDYWxsYmFjayQxIiwiY2IiLCJzdXBwb3J0c01pY3JvdGFza3MiLCJzY2hlZHVsZU1pY3JvdGFzayIsImV4ZWN1dGlvbkNvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIk5vQ29udGV4dCIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsImVudGFuZ2xlQXN5bmNBY3Rpb24iLCJ0cmFuc2l0aW9uIiwidGhlbmFibGUiLCJjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzIiwiZW50YW5nbGVkTGlzdGVuZXJzIiwiY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCIsImN1cnJlbnRFbnRhbmdsZWRMYW5lIiwiY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwic3RhdHVzIiwidGhlbiIsInJlc29sdmUiLCJwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlIiwibGlzdGVuZXJzIiwiY2hhaW5UaGVuYWJsZVZhbHVlIiwicmVzdWx0IiwidGhlbmFibGVXaXRoT3ZlcnJpZGUiLCJyZWFzb24iLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJ1cGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwiaGlkZGVuQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiY2xvbmVVcGRhdGVRdWV1ZSIsImNyZWF0ZVVwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwicGF5bG9hZCIsImVucXVldWVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY29tcG9uZW50TmFtZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJjbG9uZSIsInN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJpbnN0YW5jZSRqc2NvbXAkMCIsImhhc0ZvcmNlVXBkYXRlIiwicGVuZGluZ1F1ZXVlIiwibGFzdFBlbmRpbmdVcGRhdGUiLCJmaXJzdFBlbmRpbmdVcGRhdGUiLCJuZXdTdGF0ZSIsImlzSGlkZGVuVXBkYXRlIiwicGFydGlhbFN0YXRlIiwibmV4dFByb3BzIiwiaW5zdGFuY2UiLCJSZXBsYWNlU3RhdGUiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwibmV4dFN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsIkZvcmNlVXBkYXRlIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwiY2FsbENhbGxiYWNrIiwiY29tbWl0SGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0Q2FsbGJhY2tzIiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJvYmplY3RJcyIsImtleXNBIiwia2V5c0IiLCJjdXJyZW50S2V5IiwiY3JlYXRlVGhlbmFibGVTdGF0ZSIsImRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSIsInRoZW5hYmxlcyIsImlzVGhlbmFibGVSZXNvbHZlZCIsIm5vb3AkMSIsInRyYWNrVXNlZFRoZW5hYmxlIiwidGhlbmFibGVTdGF0ZSIsImRpZFVzZVByb21pc2UiLCJ0cmFja2VkVGhlbmFibGVzIiwiY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2giLCJmdWxmaWxsZWRWYWx1ZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwibmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwicmVqZWN0ZWRSZWFzb24iLCJwdXNoRGVidWdJbmZvIiwicHJldmlvdXNEZWJ1Z0luZm8iLCJjdXJyZW50RGVidWdJbmZvIiwiY29uY2F0IiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwicmV0dXJuRmliZXIiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwiZXJyb3JlZEtleSIsInVud3JhcFRoZW5hYmxlIiwidGhlbmFibGVJbmRleENvdW50ZXIkMSIsInRoZW5hYmxlU3RhdGUkMSIsImNvZXJjZVJlZiIsInJlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsImludmFsaWRDaGlsZCIsInBhcmVudE5hbWUiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuT25TeW1ib2xUeXBlIiwib3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyIsImNyZWF0ZUNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGlvbnMiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwidGV4dENvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiX2RlYnVnT3duZXIiLCJ1cGRhdGVFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJ1cGRhdGVGcmFnbWVudCIsImlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyIsImNhbGxMYXp5SW5pdEluREVWIiwiX293bmVyIiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiY29udGFpbmVySW5mbyIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwiZnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX3ByZXZEZWJ1Z0luZm8iLCJyZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uIiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIl9wcmV2RGVidWdJbmZvNyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJTZXQiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJzdGVwIiwiZG9uZSIsInJlY29uY2lsZUNoaWxkRmliZXJzSW1wbCIsInByZXZEZWJ1Z0luZm8iLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZW50cmllcyIsImRpZFdhcm5BYm91dE1hcHMiLCJmaXJzdENoaWxkRmliZXIiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yIiwiY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciIsImJhc2VMYW5lcyIsInJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2siLCJwb3BIaWRkZW5Db250ZXh0IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwic3VzcGVuc2VTdGFja0N1cnNvciIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwic3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IiLCJzaGVsbEJvdW5kYXJ5IiwicHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlciIsInJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayIsInBvcFN1c3BlbnNlSGFuZGxlciIsImZpbmRGaXJzdFN1c3BlbmRlZCIsInJvdyIsInN0YXRlIiwiaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyIsImlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrIiwicmV2ZWFsT3JkZXIiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwiY3VycmVudEhvb2tOYW1lSW5EZXYiLCJob29rVHlwZXNEZXYiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJob29rVHlwZXNVcGRhdGVJbmRleERldiIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJ0YWJsZSIsIm9sZEhvb2tOYW1lIiwibmV3SG9va05hbWUiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJ3YXJuT25Vc2VGb3JtU3RhdGVJbkRldiIsImRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsInJlbmRlcldpdGhIb29rcyIsIkNvbXBvbmVudCIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsImRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50IiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViIsIk5vTW9kZSIsImNhbGxDb21wb25lbnRJbkRFViIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyIsInJlbmRlcldpdGhIb29rc0FnYWluIiwiZmluaXNoUmVuZGVyaW5nSG9va3MiLCJkZXBlbmRlbmNpZXMiLCJmaXJzdENvbnRleHQiLCJfZGVidWdUaGVuYWJsZVN0YXRlIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJ0aGVuYWJsZUluZGV4Q291bnRlciIsImRpZFJlY2VpdmVVcGRhdGUiLCJjaGVja0lmQ29udGV4dENoYW5nZWQiLCJkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCIsIm51bWJlck9mUmVSZW5kZXJzIiwiUkVfUkVOREVSX0xJTUlUIiwibGFzdEVmZmVjdCIsImV2ZW50cyIsInN0b3JlcyIsIm1lbW9DYWNoZSIsIkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIlRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQiLCJkaXNwYXRjaGVyIiwibWF5YmVUaGVuYWJsZSIsInVzZVN0YXRlIiwidXNlVGhlbmFibGUiLCJjaGVja0RpZFJlbmRlcklkSG9vayIsImRpZFJlbmRlcklkSG9vayIsImxvY2FsSWRDb3VudGVyIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc09uVW53aW5kIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwidXNlIiwidXNhYmxlIiwicmVhZENvbnRleHQiLCJ1c2VNZW1vQ2FjaGUiLCJkYXRhIiwibWFwIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSIsIkFycmF5IiwiUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCIsImJhc2ljU3RhdGVSZWR1Y2VyIiwiYWN0aW9uIiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0IiwiaW5pdGlhbFN0YXRlIiwiZGlzcGF0Y2giLCJsYXN0UmVuZGVyZWRSZWR1Y2VyIiwibGFzdFJlbmRlcmVkU3RhdGUiLCJkaXNwYXRjaFJlZHVjZXJBY3Rpb24iLCJ1cGRhdGVSZWR1Y2VyIiwidXBkYXRlUmVkdWNlckltcGwiLCJiYXNlRmlyc3QiLCJuZXdCYXNlUXVldWVGaXJzdCIsIm5ld0Jhc2VRdWV1ZUxhc3QiLCJyZXZlcnRMYW5lIiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJtb3VudFN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsIm5leHRTbmFwc2hvdCIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IiwicHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayIsIm1vdW50RWZmZWN0Iiwic3Vic2NyaWJlVG9TdG9yZSIsInB1c2hFZmZlY3QiLCJIYXNFZmZlY3QiLCJQYXNzaXZlIiwidXBkYXRlU3RvcmVJbnN0YW5jZSIsImRlc3Ryb3kiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsImlzSHlkcmF0aW5nJGpzY29tcCQwIiwiY2FjaGVkU25hcHNob3QiLCJjcmVhdGUiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicmVuZGVyZWRTbmFwc2hvdCIsImluc3QiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiZm9yY2VTdG9yZVJlcmVuZGVyIiwibGF0ZXN0R2V0U25hcHNob3QiLCJuZXh0VmFsdWUiLCJzY2hlZHVsZVVwZGF0ZU9uRmliZXIiLCJtb3VudFN0YXRlSW1wbCIsImluaXRpYWxTdGF0ZUluaXRpYWxpemVyIiwibW91bnRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGUiLCJtb3VudE9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlIiwidXBkYXRlT3B0aW1pc3RpYyIsInVwZGF0ZU9wdGltaXN0aWNJbXBsIiwicmVyZW5kZXJPcHRpbWlzdGljIiwiZGlzcGF0Y2hBY3Rpb25TdGF0ZSIsImFjdGlvblF1ZXVlIiwic2V0UGVuZGluZ1N0YXRlIiwic2V0U3RhdGUiLCJpc1JlbmRlclBoYXNlVXBkYXRlIiwiYWN0aW9uTm9kZSIsImlzVHJhbnNpdGlvbiIsImxpc3RlbmVyIiwiVCIsInJ1bkFjdGlvblN0YXRlQWN0aW9uIiwicHJldlN0YXRlIiwicHJldlRyYW5zaXRpb24iLCJjdXJyZW50VHJhbnNpdGlvbiIsIl91cGRhdGVkRmliZXJzIiwicmV0dXJuVmFsdWUiLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsIlMiLCJoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZSIsIm9uQWN0aW9uRXJyb3IiLCJlcnJvciQyIiwib25BY3Rpb25TdWNjZXNzIiwibm90aWZ5QWN0aW9uTGlzdGVuZXJzIiwibGFzdCIsImFjdGlvblN0YXRlUmVkdWNlciIsIm9sZFN0YXRlIiwibW91bnRBY3Rpb25TdGF0ZSIsImluaXRpYWxTdGF0ZVByb3AiLCJzc3JGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJpc01hdGNoaW5nIiwibWFya2VySW5zdGFuY2UiLCJjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyIiwiaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyIsInVwZGF0ZUFjdGlvblN0YXRlIiwic3RhdGVIb29rIiwidXBkYXRlQWN0aW9uU3RhdGVJbXBsIiwiY3VycmVudFN0YXRlSG9vayIsImFjdGlvblF1ZXVlSG9vayIsImFjdGlvblN0YXRlQWN0aW9uRWZmZWN0IiwicmVyZW5kZXJBY3Rpb25TdGF0ZSIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwibW91bnRFZmZlY3RJbXBsIiwiZmliZXJGbGFncyIsImhvb2tGbGFncyIsIm1vdW50TGF5b3V0RWZmZWN0IiwiTGF5b3V0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNsZWFudXAiLCJtb3VudEltcGVyYXRpdmVIYW5kbGUiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJtb3VudERlZmVycmVkVmFsdWVJbXBsIiwidXBkYXRlRGVmZXJyZWRWYWx1ZSIsInVwZGF0ZURlZmVycmVkVmFsdWVJbXBsIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwicmVxdWVzdERlZmVycmVkTGFuZSIsInByZXZWYWx1ZSIsInN0YXJ0VHJhbnNpdGlvbiIsInBlbmRpbmdTdGF0ZSIsImZpbmlzaGVkU3RhdGUiLCJwcmV2aW91c1ByaW9yaXR5IiwiZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5Iiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwidGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsIiwicmVxdWVzdFVwZGF0ZUxhbmUiLCJlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bCIsImZvcm1GaWJlciIsImV4aXN0aW5nU3RhdGVIb29rIiwiaW5pdGlhbFJlc2V0U3RhdGUiLCJtb3VudFRyYW5zaXRpb24iLCJ1cGRhdGVUcmFuc2l0aW9uIiwiYm9vbGVhbk9yVGhlbmFibGUiLCJzdGFydCIsInJlcmVuZGVyVHJhbnNpdGlvbiIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJpZFdpdGhMZWFkaW5nQml0IiwiZ2xvYmFsQ2xpZW50SWRDb3VudGVyIiwibW91bnRSZWZyZXNoIiwicmVmcmVzaENhY2hlIiwic2VlZEtleSIsInByb3ZpZGVyIiwiY3JlYXRlQ2FjaGUiLCJjYWNoZSIsIkpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCIsImVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZSIsIkpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJjdXJyZW50U3RhdGUiLCJ0aHJvd0lmRHVyaW5nUmVuZGVyIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjdG9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJyZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyIsImJhc2VQcm9wcyIsImRlZmF1bHRQcm9wcyIsImxvZ1VuY2F1Z2h0RXJyb3IiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5TmFtZSIsInRocm93bkVycm9ycyIsIm9uVW5jYXVnaHRFcnJvciIsImNvbXBvbmVudFN0YWNrIiwiZSIsInNldFRpbWVvdXQiLCJsb2dDYXVnaHRFcnJvciIsImJvdW5kYXJ5Iiwib25DYXVnaHRFcnJvciIsImVycm9yQm91bmRhcnkiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwiaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyIsImNvbXBvbmVudERpZENhdGNoIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViIsInRocm93RXhjZXB0aW9uIiwicm9vdFJlbmRlckxhbmVzIiwicmVzdG9yZVBlbmRpbmdVcGRhdGVycyIsInByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsIndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMiLCJSb290SW5Qcm9ncmVzcyIsIlJvb3RTdXNwZW5kZWQiLCJub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJ0cmFuc2l0aW9ucyIsIm1hcmtlckluc3RhbmNlcyIsInJldHJ5UXVldWUiLCJjYXVzZSIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290RXJyb3JlZCIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsInVwZGF0ZUZvcndhcmRSZWYiLCJwcm9wc1dpdGhvdXRSZWYiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50Iiwic2hvdWxkQ29uc3RydWN0IiwiY29tcGFyZSIsInJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMiLCJjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsInByZXZQcm9wcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwibmV4dElzRGV0YWNoZWQiLCJfcGVuZGluZ1Zpc2liaWxpdHkiLCJtYXJrUmVmIiwiZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQiLCJjYWNoZVBvb2wiLCJwdXNoVHJhbnNpdGlvbiIsIm5leHRCYXNlTGFuZXMiLCJwZWVrQ2FjaGVGcm9tUG9vbCIsIkNhY2hlQ29udGV4dCIsInBvb2wiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJjb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMiLCJyZXBsYXlGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZUNsYXNzQ29tcG9uZW50IiwiY3VycmVudCRqc2NvbXAkMCIsIl9pbnN0YW5jZSIsInVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJjb250ZXh0VHlwZSIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsIl9yZWFjdEludGVybmFscyIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwibmV3QXBpTmFtZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJyZWZzIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsImNvbXBvbmVudERpZE1vdW50IiwidW5yZXNvbHZlZE9sZFByb3BzIiwib2xkQ29udGV4dCIsImNhbGxSZW5kZXJJbkRFViIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJnZXRTdXNwZW5kZWRDYWNoZSIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwicHJpbWFyeVRyZWVEaWREZWZlciIsIndvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG93RmFsbGJhY2siLCJkaWRTdXNwZW5kIiwiSlNDb21waWxlcl90ZW1wIiwiRm9yY2VTdXNwZW5zZUZhbGxiYWNrIiwibmV4dEluc3RhbmNlIiwiSlNDb21waWxlcl90ZW1wJGpzY29tcCQwIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJ0cmVlQ29udGV4dCIsIm92ZXJmbG93IiwicmV0cnlMYW5lIiwiZmFsbGJhY2siLCJtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsInJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nIiwiZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzIiwiZGlnZXN0IiwiU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uIiwicmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsInJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5IiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlIiwic3VidHJlZUZsYWdzIiwicHJpbWFyeUNoaWxkcmVuIiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGlvblJvb3QiLCJzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsImlzQmFja3dhcmRzIiwidGFpbCIsImxhc3RDb250ZW50Um93IiwidGFpbE1vZGUiLCJyZW5kZXJTdGF0ZSIsInJlbmRlcmluZyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJfaSIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwicHVzaFByb3ZpZGVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJkaWRTdXNwZW5kQmVmb3JlIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwicHJldlNpYmxpbmciLCJyZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzIiwiaXNEZWh5ZHJhdGVkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJzdXBwb3J0c1Jlc291cmNlcyIsImdldFJlc291cmNlIiwiY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UiLCJyZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UiLCJkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJ2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsInZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciIsInBvb2xlZENhY2hlIiwicmV0YWluQ2FjaGUiLCJwb29sZWRDYWNoZUxhbmVzIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwibGFzdENvbnRleHREZXBlbmRlbmN5IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJwcm92aWRlckZpYmVyIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlckN1cnNvckRFViIsIl9jdXJyZW50UmVuZGVyZXIiLCJyZW5kZXJlclNpZ2lsIiwicmVuZGVyZXIyQ3Vyc29yREVWIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsImNvbnRleHRzIiwiZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIiwibGlzdCIsIm5leHRGaWJlciIsImRlcGVuZGVuY3kiLCJpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCIsImN1cnJlbnRQYXJlbnQiLCJjdXJyZW50RGVwZW5kZW5jaWVzIiwibWVtb2l6ZWRWYWx1ZSIsInJlYWRDb250ZXh0Rm9yQ29uc3VtZXIiLCJjb25zdW1lciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXJMb2NhbCIsInJlZkNvdW50Iiwic2lnbmFsIiwiYWJvcnRlZCIsInJlbGVhc2VDYWNoZSIsInNjaGVkdWxlQ2FsbGJhY2skMSIsIk5vcm1hbFByaW9yaXR5IiwiYWJvcnQiLCJjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIiLCJyZXN1bWVkQ2FjaGUiLCJvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyIsInByZXZDYWNoZVBvb2wiLCJjYWNoZUZyb21Qb29sIiwibWFya1VwZGF0ZSIsImRvZXNSZXF1aXJlQ2xvbmUiLCJjb21wbGV0ZWRXb3JrIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJzdXBwb3J0c011dGF0aW9uIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsIl9ub2RlIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lSGlkZGVuVGV4dEluc3RhbmNlIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwidXBkYXRlSG9zdENvbnRhaW5lciIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJwZW5kaW5nQ2hpbGRyZW4iLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwidXBkYXRlSG9zdENvbXBvbmVudCIsImN1cnJlbnRJbnN0YW5jZSIsIl9vbGRQcm9wcyIsImN1cnJlbnRIb3N0Q29udGV4dCIsImNsb25lSW5zdGFuY2UiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCIsIm1heVN1c3BlbmRDb21taXQiLCJwcmVsb2FkSW5zdGFuY2UiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwiU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwicmVzb3VyY2UiLCJtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQiLCJwcmVsb2FkUmVzb3VyY2UiLCJzY2hlZHVsZVJldHJ5RWZmZWN0Iiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwiaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIiwibGFzdFRhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJkaWRCYWlsb3V0IiwibmV3Q2hpbGRMYW5lcyIsIl90cmVlQmFzZUR1cmF0aW9uIiwiX2NoaWxkMiIsInRyZWVCYXNlRHVyYXRpb24iLCJjb21wbGV0ZVdvcmsiLCJwZW5kaW5nQ29udGV4dCIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJuZXh0UmVzb3VyY2UiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsInByZXBhcmVQb3J0YWxNb3VudCIsInJlc2V0V29ya0luUHJvZ3Jlc3MiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwidW53aW5kV29yayIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsInNob3VsZFByb2ZpbGUiLCJjb21taXRIb29rTGF5b3V0RWZmZWN0cyIsImZpbmlzaGVkV29yayIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMiLCJuZWFyZXN0TW91bnRlZEFuY2VzdG9yIiwiY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50IiwiZmlyc3RFZmZlY3QiLCJOb0ZsYWdzIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkIiwiSW5zZXJ0aW9uIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiY2FsbENyZWF0ZUluREVWIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkIiwiYWRkZW5kdW0iLCJuIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkIiwiY2FsbERlc3Ryb3lJbkRFViIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMiLCJjb21taXRDbGFzc1NuYXBzaG90IiwicmVzb2x2ZWRQcmV2UHJvcHMiLCJzbmFwc2hvdCIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViIsImNvbW1pdEF0dGFjaFJlZiIsImdldFB1YmxpY0luc3RhbmNlIiwic2FmZWx5QXR0YWNoUmVmIiwic2FmZWx5RGV0YWNoUmVmIiwiZXJyb3IkMyIsImNvbW1pdFByb2ZpbGVyIiwiY29tbWl0U3RhcnRUaW1lIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplIiwib25Db21taXQiLCJvblJlbmRlciIsImNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUyIiwib25Qb3N0Q29tbWl0IiwiY29tbWl0SG9zdE1vdW50IiwiY29tbWl0TW91bnQiLCJjb21taXRIb3N0VXBkYXRlIiwiY29tbWl0VXBkYXRlIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyIiwiYmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJjb21taXRQbGFjZW1lbnQiLCJwYXJlbnRGaWJlciIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMiLCJmaXJzdENoaWxkIiwicHJlcGFyZUZvckNvbW1pdCIsIm5leHRFZmZlY3QiLCJjbGVhckNvbnRhaW5lciIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdExheW91dEVmZmVjdE9uRmliZXIiLCJmaW5pc2hlZFJvb3QiLCJyZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyIsImNhbGxDb21wb25lbnREaWRNb3VudEluREVWIiwiY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWIiwiY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MiLCJvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyIsImNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIiLCJkZWxldGVkRmliZXIiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInJlbGVhc2VSZXNvdXJjZSIsInVubW91bnRIb2lzdGFibGUiLCJwcmV2SG9zdFBhcmVudCIsImhvc3RQYXJlbnQiLCJwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiaG9zdFBhcmVudElzQ29udGFpbmVyIiwicmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwicmVtb3ZlQ2hpbGQiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJnZXRSZXRyeUNhY2hlIiwicmV0cnlDYWNoZSIsIlBvc3NpYmx5V2Vha1NldCIsIl9yZXRyeUNhY2hlIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsIndha2VhYmxlcyIsIndha2VhYmxlIiwicmV0cnkiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwiY29tbWl0TXV0YXRpb25FZmZlY3RzIiwiY29tbWl0dGVkTGFuZXMiLCJjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyIsInJvb3QkanNjb21wJDAiLCJjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMiLCJob2lzdGFibGVSb290IiwiY3VycmVudEhvaXN0YWJsZVJvb3QiLCJoeWRyYXRlSG9pc3RhYmxlIiwibW91bnRIb2lzdGFibGUiLCJhY3F1aXJlUmVzb3VyY2UiLCJjbGVhclNpbmdsZXRvbiIsImFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSIsIm5lZWRzRm9ybVJlc2V0IiwiY29tbWl0VGV4dFVwZGF0ZSIsInByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMiLCJnZXRIb2lzdGFibGVSb290IiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJyZWN1cnNpdmVseVJlc2V0Rm9ybXMiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwid2FzSGlkZGVuIiwiX2N1cnJlbnQiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsImhpZGVJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsInJlc2V0Rm9ybUluc3RhbmNlIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImRpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZWFwcGVhckxheW91dEVmZmVjdHMiLCJpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzIiwiY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyIsInByZXZpb3VzQ2FjaGUiLCJjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0dGVkVHJhbnNpdGlvbnMiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwicmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfaW5zdGFuY2UyIiwiZmluaXNoZWRSb290JGpzY29tcCQwIiwicmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0Iiwic3VzcGVuc2V5Q29tbWl0RmxhZyIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwic3VzcGVuZFJlc291cmNlIiwic3VzcGVuZEluc3RhbmNlIiwicHJldmlvdXNIb2lzdGFibGVSb290IiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbiIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJmaW5kRmliZXJSb290IiwibWF0Y2hTZWxlY3RvciIsImZpYmVyJGpzY29tcCQwIiwic2VsZWN0b3IiLCJDT01QT05FTlRfVFlQRSIsIkhBU19QU0VVRE9fQ0xBU1NfVFlQRSIsInRhZyRqc2NvbXAkMCIsInNlbGVjdG9ySW5kZXgiLCJzZWxlY3RvciRqc2NvbXAkMCIsImlzSGlkZGVuU3VidHJlZSIsIlJPTEVfVFlQRSIsIm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUiLCJURVhUX1RZUEUiLCJnZXRUZXh0Q29udGVudCIsIlRFU1RfTkFNRV9UWVBFIiwic2VsZWN0b3JUb1N0cmluZyIsImZpbmRQYXRocyIsInNlbGVjdG9ycyIsIm1hdGNoaW5nRmliZXJzIiwiZmluZEFsbE5vZGVzIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZnJvbSIsIm9uQ29tbWl0Um9vdCIsImNvbW1pdEhvb2tzIiwiY29tbWl0SG9vayIsImlzQ29uY3VycmVudEFjdEVudmlyb25tZW50IiwiaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwicmVzb2x2ZVVwZGF0ZVByaW9yaXR5Iiwic3VzcGVuc2VIYW5kbGVyIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyIsInByZXBhcmVGcmVzaFN0YWNrIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsIndhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFViIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwiZm9yY2VTeW5jIiwic2hvdWxkVGltZVNsaWNlIiwiZXhpdFN0YXR1cyIsInJlbmRlclJvb3RDb25jdXJyZW50IiwicmVuZGVyUm9vdFN5bmMiLCJyZW5kZXJXYXNDb25jdXJyZW50Iiwid29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmciLCJSb290RGlkTm90Q29tcGxldGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MiLCJpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMiLCJlcnJvclJldHJ5TGFuZXMiLCJlcnJvclJldHJ5TGFuZXMkanNjb21wJDAiLCJ3YXNSb290RGVoeWRyYXRlZCIsIndvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciIsIndvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RDb21wbGV0ZWQiLCJjb21taXRSb290Iiwid29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJJTU1FRElBVEVfQ09NTUlUIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ0aW1lb3V0SGFuZGxlIiwic2NoZWR1bGVUaW1lb3V0IiwiY29tbWl0Um9vdFdoZW5SZWFkeSIsIlRIUk9UVExFRF9DT01NSVQiLCJlcnJvcnMiLCJhcHBseSIsInJlY292ZXJhYmxlRXJyb3JzIiwiZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIiwiZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIiwic3VzcGVuZGVkQ29tbWl0UmVhc29uIiwiY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lIiwiY29tcGxldGVkUmVuZGVyRW5kVGltZSIsInN0YXJ0U3VzcGVuZGluZ0NvbW1pdCIsIndhaXRGb3JDb21taXRUb0JlUmVhZHkiLCJTVVNQRU5ERURfQ09NTUlUIiwiY2hlY2siLCJkaWRBdHRlbXB0RW50aXJlVHJlZSIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwicmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrIiwiTm90U3VzcGVuZGVkIiwibm9UaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIndvcmtJblByb2dyZXNzVGhyb3duVmFsdWUiLCJhbGxFbnRhbmdsZWRMYW5lcyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJoYW5kbGVUaHJvdyIsInRocm93blZhbHVlIiwiU3VzcGVuZGVkT25JbW1lZGlhdGUiLCJTdXNwZW5kZWRPbkluc3RhbmNlIiwiU3VzcGVuZGVkT25IeWRyYXRpb24iLCJTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UiLCJTdXNwZW5kZWRPbkVycm9yIiwiZXJyb3JlZFdvcmsiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsIlN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSIsIm1hcmtDb21wb25lbnRTdXNwZW5kZWQiLCJwdXNoRGlzcGF0Y2hlciIsInB1c2hBc3luY0Rpc3BhdGNoZXIiLCJwcmV2QXN5bmNEaXNwYXRjaGVyIiwiQSIsIkRlZmF1bHRBc3luY0Rpc3BhdGNoZXIiLCJzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZyIsInByZXZFeGVjdXRpb25Db250ZXh0IiwidW5pdE9mV29yayIsInRocm93QW5kVW53aW5kV29ya0xvb3AiLCJ3b3JrTG9vcFN5bmMiLCJ0aHJvd25WYWx1ZSQ0IiwicGVyZm9ybVVuaXRPZldvcmsiLCJSRU5ERVJfVElNRU9VVF9NUyIsInJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsiLCJTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlIiwiaG9zdEZpYmVyIiwiY29tcGxldGVVbml0T2ZXb3JrIiwid29ya0xvb3BDb25jdXJyZW50IiwidGhyb3duVmFsdWUkNSIsIm1hcmtSZW5kZXJZaWVsZGVkIiwic2hvdWxkWWllbGQiLCJyZXBsYXlCZWdpbldvcmsiLCJpc1Byb2ZpbGluZ01vZGUiLCJzdXNwZW5kZWRSZWFzb24iLCJ1bndpbmRVbml0T2ZXb3JrIiwic2tpcFNpYmxpbmdzIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsIm1hcmtDb21taXRTdGFydGVkIiwicm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyIsInBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMiLCJzY2hlZHVsZUNhbGxiYWNrIiwicmVzZXRBZnRlckNvbW1pdCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCIsInJlcXVlc3RQYWludCIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzIiwicmVsZWFzZVJvb3RQb29sZWRDYWNoZSIsImNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm1ha2VFcnJvckluZm8iLCJyZW5kZXJQcmlvcml0eSIsInByaW9yaXR5IiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsInBpbmdDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsInRocmVhZElEcyIsInBpbmdTdXNwZW5kZWRSb290IiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsInN1c3BlbnNlU3RhdGUiLCJyZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwiaXNJblN0cmljdE1vZGUiLCJpc1N0cmljdE1vZGVGaWJlciIsImRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyIiwic2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMiLCJhcmd1bWVudHMiLCJkb3VibGVJbnZva2VFZmZlY3RzIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsInNjaGVkdWxpbmdGaWJlciIsInByaW9yaXR5TGV2ZWwiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlIiwiZmFtaWx5IiwicHJldlR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJXZWFrU2V0IiwiZmFpbGVkQm91bmRhcmllcyIsImNhbmRpZGF0ZVR5cGUiLCJuZWVkc1JlbmRlciIsImhhc0JhZE1hcFBvbHlmaWxsIiwicHJldmVudEV4dGVuc2lvbnMiLCJpc1JlYWN0Q29tcG9uZW50Iiwib3duZXIiLCJmaWJlclRhZyIsInJlc29sdmVkVHlwZSIsImlzSG9zdEhvaXN0YWJsZVR5cGUiLCJpc0hvc3RTaW5nbGV0b25UeXBlIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiZWxlbWVudHMiLCJwcmltYXJ5Q2hpbGRJbnN0YW5jZSIsIl9wZW5kaW5nTWFya2VycyIsIl90cmFuc2l0aW9ucyIsImRldGFjaCIsImF0dGFjaCIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJoeWRyYXRpb25DYWxsYmFja3MiLCJpc1N0cmljdE1vZGUiLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJ1cGRhdGVDb250YWluZXJJbXBsIiwib25TY2hlZHVsZUZpYmVyUm9vdCIsIm1hcmtSZW5kZXJTY2hlZHVsZWQiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwibWFya1JldHJ5TGFuZUltcGwiLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiZ2V0TGFuZUxhYmVsTWFwIiwibGFiZWwiLCJSZWFjdCIsInJlcXVpcmUiLCJTY2hlZHVsZXIiLCJTeW1ib2wiLCJmb3IiLCJpdGVyYXRvciIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIl9fcmVhY3REaXNhYmxlZExvZyIsIldlYWtNYXAiLCJpc0FycmF5IiwicmVuZGVyZXJWZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsImV4dHJhRGV2VG9vbHNDb25maWciLCJ3YXJuc0lmTm90QWN0aW5nIiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJwcmVwYXJlU2NvcGVVcGRhdGUiLCJnZXRJbnN0YW5jZUZyb21TY29wZSIsInJlc29sdmVFdmVudFR5cGUiLCJyZXNvbHZlRXZlbnRUaW1lU3RhbXAiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJiaW5kVG9Db25zb2xlIiwiZ2V0Qm91bmRpbmdSZWN0Iiwic2V0Rm9jdXNJZkZvY3VzYWJsZSIsInNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJmcmVlemUiLCJNYXRoIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9ub3ciLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsImNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsImNhbGxDb21wb25lbnQiLCJ3YXNSZW5kZXJpbmciLCJjYWxsUmVuZGVyIiwiY2FsbENvbXBvbmVudERpZE1vdW50IiwiY2FsbENvbXBvbmVudERpZFVwZGF0ZSIsImNhbGxDb21wb25lbnREaWRDYXRjaCIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsImNhbGxDcmVhdGUiLCJlZmZlY3QiLCJjYWxsRGVzdHJveSIsImNhbGxMYXp5SW5pdCIsImxhenkiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb21wb25lbnRLZXkiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lckFwcGVuZGl4IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VUcmFuc2l0aW9uIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VJZCIsInVzZUNhY2hlUmVmcmVzaCIsInVzZUZvcm1TdGF0ZSIsInVzZUFjdGlvblN0YXRlIiwidXNlT3B0aW1pc3RpYyIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiaXNNb3VudGVkIiwiY29tcG9uZW50IiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJyZXBvcnRFcnJvciIsIndpbmRvdyIsIkVycm9yRXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsInByb2Nlc3MiLCJlbWl0IiwiQWJvcnRDb250cm9sbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkNvbnN1bWVyIiwiUHJvdmlkZXIiLCJfdGhyZWFkQ291bnQiLCJwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2giLCJnZXRDYWNoZUZvclR5cGUiLCJyZXNvdXJjZVR5cGUiLCJjYWNoZUZvclR5cGUiLCJnZXRPd25lciIsInN5bWJvbEZvciIsIkluZmluaXR5Iiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiIsImF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSIsImF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiIsImJhdGNoZWRVcGRhdGVzIiwiY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IiLCJjcmVhdGVDb250YWluZXIiLCJjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlIiwiY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvciIsImNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciIsImNyZWF0ZVBvcnRhbCIsImUkNiIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImNyZWF0ZVRleHRTZWxlY3RvciIsInRleHQiLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwicmVjcmVhdGVNZXNzYWdlIiwicHJldkdldEN1cnJlbnRTdGFjayIsImVudmlyb25tZW50TmFtZSIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJkZWZhdWx0T25VbmNhdWdodEVycm9yIiwiZGVmZXJyZWRVcGRhdGVzIiwiZGlzY3JldGVVcGRhdGVzIiwiZCIsImZpbmRCb3VuZGluZ1JlY3RzIiwidGFyZ2V0TGVmdCIsInRhcmdldFJpZ2h0Iiwid2lkdGgiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJoZWlnaHQiLCJqIiwib3RoZXJSZWN0Iiwib3RoZXJMZWZ0Iiwib3RoZXJSaWdodCIsIm90aGVyVG9wIiwib3RoZXJCb3R0b20iLCJmaW5kSG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIiLCJmb2N1c1dpdGhpbiIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwidmVyc2lvbiIsImN1cnJlbnREaXNwYXRjaGVyUmVmIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJyZWNvbmNpbGVyVmVyc2lvbiIsInJlbmRlcmVyQ29uZmlnIiwiZ2V0Q3VycmVudEZpYmVyIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwib2JzZXJ2ZVZpc2libGVSZWN0cyIsIm9wdGlvbnMiLCJuZXh0SW5zdGFuY2VSb290cyIsImluc3RhbmNlUm9vdHMiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInNob3VsZEVycm9yIiwic2hvdWxkU3VzcGVuZCIsInN0YXJ0SG9zdFRyYW5zaXRpb24iLCJmb3JtRGF0YSIsInJlc2V0U3RhdGVRdWV1ZSIsInVwZGF0ZUNvbnRhaW5lciIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxMRU5PVk9cXERvY3VtZW50c1xcZ2l0aHViXFx6aWtyaWFuYmlhLmdpdGh1Yi5pb1xcbm9kZV9tb2R1bGVzXFxyZWFjdC1yZWNvbmNpbGVyXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ })

};
;