"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  try {\n    return decodeURIComponent(escape(s));\n  } catch (e) {\n    return s;\n  }\n}\n\n//# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTEVOT1ZPXFxEb2N1bWVudHNcXGdpdGh1YlxcemlrcmlhbmJpYS5naXRodWIuaW9cXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxfcG9seWZpbGxcXExvYWRlclV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVRleHQoYXJyYXkpIHtcbiAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXkpO1xuICB9XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZXhwb3J0IHtcbiAgZGVjb2RlVGV4dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst version = /* @__PURE__ */ (() => parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsZ0RBQWdELDJDQUFRO0FBR3REO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTEVOT1ZPXFxEb2N1bWVudHNcXGdpdGh1YlxcemlrcmlhbmJpYS5naXRodWIuaW9cXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxfcG9seWZpbGxcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgdmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkpKCk7XG5leHBvcnQge1xuICB2ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/uv1.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/uv1.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UV1: () => (/* binding */ UV1)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\nconst UV1 = _constants_js__WEBPACK_IMPORTED_MODULE_0__.version >= 125 ? \"uv1\" : \"uv2\";\n\n//# sourceMappingURL=uv1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC91djEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUM7QUFDekMsWUFBWSxrREFBTztBQUdqQjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcX3BvbHlmaWxsXFx1djEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuY29uc3QgVVYxID0gdmVyc2lvbiA+PSAxMjUgPyBcInV2MVwiIDogXCJ1djJcIjtcbmV4cG9ydCB7XG4gIFVWMVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV2MS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/uv1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = () => {\n  if (generated)\n    return generated;\n  const wasm_base = \"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\";\n  const wasm_simd = \"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\";\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11\n  ]);\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167\n  ]);\n  if (typeof WebAssembly !== \"object\") {\n    return {\n      supported: false\n    };\n  }\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n  }\n  let instance;\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance;\n    instance.exports.__wasm_call_ctors();\n  });\n  function unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n  }\n  function decode(fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = count + 3 & ~3;\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n      filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`);\n    }\n  }\n  const filters = {\n    // legacy index-based enums for glTF\n    0: \"\",\n    1: \"meshopt_decodeFilterOct\",\n    2: \"meshopt_decodeFilterQuat\",\n    3: \"meshopt_decodeFilterExp\",\n    // string-based enums for glTF\n    NONE: \"\",\n    OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n    QUATERNION: \"meshopt_decodeFilterQuat\",\n    EXPONENTIAL: \"meshopt_decodeFilterExp\"\n  };\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: \"meshopt_decodeVertexBuffer\",\n    1: \"meshopt_decodeIndexBuffer\",\n    2: \"meshopt_decodeIndexSequence\",\n    // string-based enums for glTF\n    ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n    TRIANGLES: \"meshopt_decodeIndexBuffer\",\n    INDICES: \"meshopt_decodeIndexSequence\"\n  };\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    }\n  };\n  return generated;\n};\n\n//# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTEVOT1ZPXFxEb2N1bWVudHNcXGdpdGh1YlxcemlrcmlhbmJpYS5naXRodWIuaW9cXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsaWJzXFxNZXNob3B0RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZ2VuZXJhdGVkO1xuY29uc3QgTWVzaG9wdERlY29kZXIgPSAoKSA9PiB7XG4gIGlmIChnZW5lcmF0ZWQpXG4gICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgY29uc3Qgd2FzbV9iYXNlID0gXCJCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCXCI7XG4gIGNvbnN0IHdhc21fc2ltZCA9IFwiQjloOXo5dEZCQkJGaUk5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmFFTWNCQkZCRkZHR0dFSUxGOXdGRkZMRUZCRktORmFGQ3gvYUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRzhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkl5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JLaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JPbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3Qk5JOXo5aXFsQlZjK045SWNJQlRFTTkrRkxhOGpVVVVVQkNUbFJCQ0JSRkVYQ0JSR0NCUkVFWEFCQ05KQUdKQUVDVWFBRkFHckNGWkhJeTg2QkJBRUFJSlJFQUdDRkpIR0NOOUhRQk1BRkN4K1lVVUJKQUU4NkJCQUZDRVdDeGtVVUJKQUI4cEVOODNFQkFGQ0ZKSEZDVUc5SFFCTU1rOGxMYmFFOTdGOStGYUw5NzhqVVVVVUJDVS9LQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHLzhjQkJDVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSTkFFQ0ZKUktDQlJWR1hFWEFWQUY5UFFGQU5BRkFWbEFWQU5KQUY5SnlSY0dYR1hBRzlGUUJBY0NiSkhJQzl3WkhNQ0U5c1JTQU1DRldSUUFJQ0lyQ0VKQ0dyUmZDQlJiRVhBS1JUQ0JSdEdYRVhHWEFPQVRsQWY5UFFCQ0JSS1NMTUFMQ1UvQ0JKQXRBTTlzSlJtQVRBZkpSS0NCUkVHWEFNQ29COUpRQkFPQUtsQy9nQjlKUUJDQlJJRVhBbUFJSlJFR1hHWEdYR1hHWEFUQUlDS3JKMkJCSFlDRVpmSUJGR0VCTUFFQ0JEdERNSUJTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlUQUtDVEpSS01HWEdYR1hHWEdYQVlDSXJDRVpmSUJGR0VCTUFFQ0JEdERNSUFTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlBQUtDVEpSS01HWEdYR1hHWEdYQVlDS3JmSUJGR0VCTUFFQ0JEdERNSTh3U0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NJSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BWUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BWUFLREJCQkRNSUJBS0NUSlJLTUFJQ0dKUklBRUNUSkhFQU05SlFCTU1HWEFLOUZRQkFLUlRBdENGSkh0Q0k2UUdTRk1NQ0JSS1NFTUdYQU05RlFCQUxDVUdKQWJKUkVBTEFiSkRCR0JSZUNCUllFWEFFQUxDVS9DQkpBWUpISURCSUJIZENGRDl0QWRDRkRiSFBEOU9EOWhEOVJIZEFJQU1KREJJQkg4WkNGRDl0QThaQVBEOU9EOWhEOVJIOFpEUUJURnRHbUVZSVBMZEtlT25IcEFJQVFKREJJQkh5Q0ZEOXRBeUFQRDlPRDloRDlSSHlBSUFTSkRCSUJIOGNDRkQ5dEE4Y0FQRDlPRDloRDlSSDhjRFFCVEZ0R21FWUlQTGRLZU9uSDhkRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFlRDl1SGVEeUJqR0JBRUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBcEE4ZERRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXlBOGNEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4Zkg4WkRRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS9kTEVLOTdGYUY5N0dYR1hBR0NJOUhRQkFGOUZRRkNCUkdFWEFCQUJEQkJCSEVDaUQrckZDaUQrc0ZELzZGSElBRUNORCtyRkNpRCtzRkQvNkZBSUQvZ0ZBRUNURCtyRkNpRCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhLQ0JEdEQrMkZIT0FJQ1VVVVU5NER0SE5EOU9EOVJEL2tGSEk5REJCLytoRFlBSUFJRC9tRkFLQUtEL21GQUxBT0FMQU5EOU9EOVJEL2tGSElBSUQvbUZEL2tGRC9rRkQvakZEL25GSExEL21GOURCQlg5TERZSE9EL2tGQ2dGRHREOU9BRUNVVVU5NER0RDlPRDlRQUlBTEQvbUZBT0Qva0ZDTkQrckZDVS8rRUR0RDlPRDlRQUtBTEQvbUZBT0Qva0ZDVEQrckZDVVUvOE9EdEQ5T0Q5UURNQkJBQkNUSlJCQUdDSUpIR0FGOUpRQlNHTU1BRjlGUUJDQlJHRVhBQkNUSkhWQVZEQkJCSEVDQkR0SE9DVVU5OEQ4Y0ZDVVU5OEQ4Y0VITkQ5T0FCREJCQkhLQUVEUUlMS09TUWZiUGRlbjhjOGQ4ZThmQ2dnRkR0RDlPRC82RkFLQUVEUUJGR0VOVmNNVHRtWWk4WnB5SEVDVEQrc0ZELzZGSElEL2dGQUVDVEQrckZDVEQrc0ZELzZGSExEL2dGRC9rRkQvbEZIRTlEQi8rZzZEWUFMQUVBT0QrMkZIT0FMQ1VVVVU5NER0SGNEOU9EOVJEL2tGSExBTEQvbUZBRUFFRC9tRkFJQU9BSUFjRDlPRDlSRC9rRkhFQUVEL21GRC9rRkQva0ZEL2pGRC9uRkhJRC9tRjlEQkJYOUxEWUhPRC9rRkNURCtyRkFMQUlEL21GQU9EL2tGQ2dnRUR0RDlPRDlRSExBRUFJRC9tRkFPRC9rRkNhRGJDQkRuR0NCRG5FQ0JEbktDQkRuT0NCRG5jQ0JEbk1DQkRuZkNCRG5iRDlPSEVEUU5WaThaY01weVNROGM4ZGZiOGU4ZkQ5UURNQkJBQkFLQU5EOU9BTEFFRFFCRlR0R0VtWUlMUGRLT2VuRDlRRE1CQkFCQ0FKUkJBR0NJSkhHQUY5SlFCTU1NL2hFSUdhRjk3RmFMOTc4alVVVVVCQ1RsUkVHWEFGOUZRQkNCUklFWEFFQUJEQkJCSExBQkNUSkhLREJCQkhPRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkhOQ1REK3NGSFZDSUQrckZETUlCQUI5REJCVTgvRFk5RC96STgxOC9EWUFWQ0VEdEQ5UUQvNkZEL25GSFZBTEFPRFFCRkdFTlZjTVR0bVlpOFpweUhMQ1REK3JGQ1REK3NGRC82RkQvbUZIT0FPRC9tRkFWQUxDVEQrc0ZELzZGRC9tRkhjQWNEL21GQVZBTkNURCtyRkNURCtzRkQvNkZEL21GSE5BTkQvbUZEL2tGRC9rRkQvbEZDQkR0RCs0RkQvakY5REIvK2c2RFlIVkQvbUY5REJCWDlMRFlITEQva0ZDZ2dFRHRITUQ5T0FjQVZEL21GQUxEL2tGQ1REK3JGRDlRSGNBTkFWRC9tRkFMRC9rRkNURCtyRkFPQVZEL21GQUxEL2tGQU1EOU9EOVFIVkRRQkZUdEdFbVlJTFBkS09lbkhMRDhkQkFFREJJQkR5Qit0K0o4M0VCQUJDTkpBTEQ4ZEZBRURCSUJEeUYrdCtKODNFQkFLQWNBVkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFZEOGRCQUVEQklCRHlHK3QrSjgzRUJBQkNpSkFWRDhkRkFFREJJQkR5RSt0K0o4M0VCQUJDQUpSQkFJQ0lKSElBRjlKUUJNTU05akZGOTdHWEFHQ0dyQUY5c0hHOUZRQkNCUkZFWEFCQUJEQkJCSEVDTkQrckZDTkQrc0ZELzZGQUVDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBQkNUSlJCQUZDSUpIRkFHOUpRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQlwiO1xuICBjb25zdCBkZXRlY3RvciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIDk3LFxuICAgIDExNSxcbiAgICAxMDksXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDQsXG4gICAgMSxcbiAgICA5NixcbiAgICAwLFxuICAgIDAsXG4gICAgMyxcbiAgICAzLFxuICAgIDIsXG4gICAgMCxcbiAgICAwLFxuICAgIDUsXG4gICAgMyxcbiAgICAxLFxuICAgIDAsXG4gICAgMSxcbiAgICAxMixcbiAgICAxLFxuICAgIDAsXG4gICAgMTAsXG4gICAgMjIsXG4gICAgMixcbiAgICAxMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MixcbiAgICAxMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTEsXG4gICAgNyxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUzLFxuICAgIDE1LFxuICAgIDI2LFxuICAgIDExXG4gIF0pO1xuICBjb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAzMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDI1MyxcbiAgICAzLFxuICAgIDEsXG4gICAgMixcbiAgICAzNCxcbiAgICA0LFxuICAgIDEwNixcbiAgICA2LFxuICAgIDUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDMzLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEyOCxcbiAgICA5LFxuICAgIDExNixcbiAgICA2NCxcbiAgICAxOSxcbiAgICAxMTMsXG4gICAgMTI3LFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDE0LFxuICAgIDI1NSxcbiAgICA2NixcbiAgICAyNCxcbiAgICA1NCxcbiAgICAxMzYsXG4gICAgMTA3LFxuICAgIDE4LFxuICAgIDIzLFxuICAgIDE5MixcbiAgICAyNixcbiAgICAxMTQsXG4gICAgMTE4LFxuICAgIDEzMixcbiAgICAxNyxcbiAgICA3NyxcbiAgICAxMDEsXG4gICAgMTMwLFxuICAgIDE0NCxcbiAgICAyNyxcbiAgICA4NyxcbiAgICAxMzEsXG4gICAgNDQsXG4gICAgNDUsXG4gICAgNzQsXG4gICAgMTU2LFxuICAgIDE1NCxcbiAgICA3MCxcbiAgICAxNjdcbiAgXSk7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuICB9XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgcHJvbWlzZSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHVucGFjayh3YXNtKSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YXNtX2NhbGxfY3RvcnMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVucGFjayhkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXN1bHRbaV0gPSBjaCA+IDk2ID8gY2ggLSA3MSA6IGNoID4gNjQgPyBjaCAtIDY1IDogY2ggPiA0NyA/IGNoICsgNCA6IGNoID4gNDYgPyA2MyA6IDYyO1xuICAgIH1cbiAgICBsZXQgd3JpdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyLnNsaWNlKDAsIHdyaXRlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoZnVuLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHNicmsgPSBpbnN0YW5jZS5leHBvcnRzLnNicms7XG4gICAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gICAgY29uc3QgdHAgPSBzYnJrKGNvdW50NCAqIHNpemUpO1xuICAgIGNvbnN0IHNwID0gc2Jyayhzb3VyY2UubGVuZ3RoKTtcbiAgICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBoZWFwLnNldChzb3VyY2UsIHNwKTtcbiAgICBjb25zdCByZXMgPSBmdW4odHAsIGNvdW50LCBzaXplLCBzcCwgc291cmNlLmxlbmd0aCk7XG4gICAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcih0cCwgY291bnQ0LCBzaXplKTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICAgIHNicmsodHAgLSBzYnJrKDApKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBidWZmZXIgZGF0YTogJHtyZXN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbHRlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICAzOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgTk9ORTogXCJcIixcbiAgICBPQ1RBSEVEUkFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgUVVBVEVSTklPTjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICBFWFBPTkVOVElBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiXG4gIH07XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIEFUVFJJQlVURVM6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICBUUklBTkdMRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIElORElDRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCJcbiAgfTtcbiAgZ2VuZXJhdGVkID0ge1xuICAgIHJlYWR5OiBwcm9taXNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBkZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlR2x0ZkJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIG1vZGUsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2RlY29kZXJzW21vZGVdXSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2VuZXJhdGVkO1xufTtcbmV4cG9ydCB7XG4gIE1lc2hvcHREZWNvZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaG9wdERlY29kZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/Line2.js":
/*!**************************************************!*\
  !*** ./node_modules/three-stdlib/lines/Line2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line2: () => (/* binding */ Line2)\n/* harmony export */ });\n/* harmony import */ var _LineSegments2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegments2.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js\");\n/* harmony import */ var _LineGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineGeometry.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js\");\n/* harmony import */ var _LineMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineMaterial.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\");\n\n\n\nclass Line2 extends _LineSegments2_js__WEBPACK_IMPORTED_MODULE_0__.LineSegments2 {\n  constructor(geometry = new _LineGeometry_js__WEBPACK_IMPORTED_MODULE_1__.LineGeometry(), material = new _LineMaterial_js__WEBPACK_IMPORTED_MODULE_2__.LineMaterial({ color: Math.random() * 16777215 })) {\n    super(geometry, material);\n    this.isLine2 = true;\n    this.type = \"Line2\";\n  }\n}\n\n//# sourceMappingURL=Line2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmUyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUQ7QUFDRjtBQUNBO0FBQ2pELG9CQUFvQiw0REFBYTtBQUNqQyw2QkFBNkIsMERBQVksbUJBQW1CLDBEQUFZLEdBQUcsaUNBQWlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbGluZXNcXExpbmUyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmVTZWdtZW50czIgfSBmcm9tIFwiLi9MaW5lU2VnbWVudHMyLmpzXCI7XG5pbXBvcnQgeyBMaW5lR2VvbWV0cnkgfSBmcm9tIFwiLi9MaW5lR2VvbWV0cnkuanNcIjtcbmltcG9ydCB7IExpbmVNYXRlcmlhbCB9IGZyb20gXCIuL0xpbmVNYXRlcmlhbC5qc1wiO1xuY2xhc3MgTGluZTIgZXh0ZW5kcyBMaW5lU2VnbWVudHMyIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBuZXcgTGluZUdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVNYXRlcmlhbCh7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMTY3NzcyMTUgfSkpIHtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIHRoaXMuaXNMaW5lMiA9IHRydWU7XG4gICAgdGhpcy50eXBlID0gXCJMaW5lMlwiO1xuICB9XG59XG5leHBvcnQge1xuICBMaW5lMlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmUyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/Line2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineGeometry.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineGeometry: () => (/* binding */ LineGeometry)\n/* harmony export */ });\n/* harmony import */ var _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegmentsGeometry.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\");\n\nclass LineGeometry extends _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_0__.LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.isLineGeometry = true;\n    this.type = \"LineGeometry\";\n  }\n  setPositions(array) {\n    const length = array.length - 3;\n    const points = new Float32Array(2 * length);\n    for (let i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n    super.setPositions(points);\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    const length = array.length - itemSize;\n    const colors = new Float32Array(2 * length);\n    if (itemSize === 3) {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i];\n        colors[2 * i + 1] = array[i + 1];\n        colors[2 * i + 2] = array[i + 2];\n        colors[2 * i + 3] = array[i + 3];\n        colors[2 * i + 4] = array[i + 4];\n        colors[2 * i + 5] = array[i + 5];\n      }\n    } else {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i];\n        colors[2 * i + 1] = array[i + 1];\n        colors[2 * i + 2] = array[i + 2];\n        colors[2 * i + 3] = array[i + 3];\n        colors[2 * i + 4] = array[i + 4];\n        colors[2 * i + 5] = array[i + 5];\n        colors[2 * i + 6] = array[i + 6];\n        colors[2 * i + 7] = array[i + 7];\n      }\n    }\n    super.setColors(colors, itemSize);\n    return this;\n  }\n  fromLine(line) {\n    const geometry = line.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n}\n\n//# sourceMappingURL=LineGeometry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVHZW9tZXRyeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTtBQUNqRSwyQkFBMkIsMEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbGluZXNcXExpbmVHZW9tZXRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaW5lU2VnbWVudHNHZW9tZXRyeSB9IGZyb20gXCIuL0xpbmVTZWdtZW50c0dlb21ldHJ5LmpzXCI7XG5jbGFzcyBMaW5lR2VvbWV0cnkgZXh0ZW5kcyBMaW5lU2VnbWVudHNHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xpbmVHZW9tZXRyeSA9IHRydWU7XG4gICAgdGhpcy50eXBlID0gXCJMaW5lR2VvbWV0cnlcIjtcbiAgfVxuICBzZXRQb3NpdGlvbnMoYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggLSAzO1xuICAgIGNvbnN0IHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgICAgcG9pbnRzWzIgKiBpXSA9IGFycmF5W2ldO1xuICAgICAgcG9pbnRzWzIgKiBpICsgMV0gPSBhcnJheVtpICsgMV07XG4gICAgICBwb2ludHNbMiAqIGkgKyAyXSA9IGFycmF5W2kgKyAyXTtcbiAgICAgIHBvaW50c1syICogaSArIDNdID0gYXJyYXlbaSArIDNdO1xuICAgICAgcG9pbnRzWzIgKiBpICsgNF0gPSBhcnJheVtpICsgNF07XG4gICAgICBwb2ludHNbMiAqIGkgKyA1XSA9IGFycmF5W2kgKyA1XTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UG9zaXRpb25zKHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0Q29sb3JzKGFycmF5LCBpdGVtU2l6ZSA9IDMpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggLSBpdGVtU2l6ZTtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBsZW5ndGgpO1xuICAgIGlmIChpdGVtU2l6ZSA9PT0gMykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaXRlbVNpemUpIHtcbiAgICAgICAgY29sb3JzWzIgKiBpXSA9IGFycmF5W2ldO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyAxXSA9IGFycmF5W2kgKyAxXTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgMl0gPSBhcnJheVtpICsgMl07XG4gICAgICAgIGNvbG9yc1syICogaSArIDNdID0gYXJyYXlbaSArIDNdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyA0XSA9IGFycmF5W2kgKyA0XTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgNV0gPSBhcnJheVtpICsgNV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGl0ZW1TaXplKSB7XG4gICAgICAgIGNvbG9yc1syICogaV0gPSBhcnJheVtpXTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgMV0gPSBhcnJheVtpICsgMV07XG4gICAgICAgIGNvbG9yc1syICogaSArIDJdID0gYXJyYXlbaSArIDJdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyAzXSA9IGFycmF5W2kgKyAzXTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgNF0gPSBhcnJheVtpICsgNF07XG4gICAgICAgIGNvbG9yc1syICogaSArIDVdID0gYXJyYXlbaSArIDVdO1xuICAgICAgICBjb2xvcnNbMiAqIGkgKyA2XSA9IGFycmF5W2kgKyA2XTtcbiAgICAgICAgY29sb3JzWzIgKiBpICsgN10gPSBhcnJheVtpICsgN107XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnNldENvbG9ycyhjb2xvcnMsIGl0ZW1TaXplKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmcm9tTGluZShsaW5lKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBsaW5lLmdlb21ldHJ5O1xuICAgIHRoaXMuc2V0UG9zaXRpb25zKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5leHBvcnQge1xuICBMaW5lR2VvbWV0cnlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lR2VvbWV0cnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineMaterial.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineMaterial: () => (/* binding */ LineMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\nclass LineMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: \"LineMaterial\",\n      uniforms: three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(\n        three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.merge([\n          three__WEBPACK_IMPORTED_MODULE_1__.UniformsLib.common,\n          three__WEBPACK_IMPORTED_MODULE_1__.UniformsLib.fog,\n          {\n            worldUnits: { value: 1 },\n            linewidth: { value: 1 },\n            resolution: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1) },\n            dashOffset: { value: 0 },\n            dashScale: { value: 1 },\n            dashSize: { value: 1 },\n            gapSize: { value: 1 }\n            // todo FIX - maybe change to totalSize\n          }\n        ])\n      ),\n      vertexShader: (\n        /* glsl */\n        `\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${_polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      clipping: true\n      // required for clipping support\n    });\n    this.isLineMaterial = true;\n    this.onBeforeCompile = function() {\n      if (this.transparent) {\n        this.defines.USE_LINE_COLOR_ALPHA = \"1\";\n      } else {\n        delete this.defines.USE_LINE_COLOR_ALPHA;\n      }\n    };\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function(value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function() {\n          return \"WORLD_UNITS\" in this.defines;\n        },\n        set: function(value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = \"\";\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function(value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function() {\n          return Boolean(\"USE_DASH\" in this.defines);\n        },\n        set(value) {\n          if (Boolean(value) !== Boolean(\"USE_DASH\" in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_DASH = \"\";\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function(value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function(value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function(value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.resolution.value;\n        },\n        set: function(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function() {\n          return Boolean(\"USE_ALPHA_TO_COVERAGE\" in this.defines);\n        },\n        set: function(value) {\n          if (Boolean(value) !== Boolean(\"USE_ALPHA_TO_COVERAGE\" in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_ALPHA_TO_COVERAGE = \"\";\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.USE_ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n}\n\n//# sourceMappingURL=LineMaterial.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRFO0FBQ3hCO0FBQ3BELDJCQUEyQixpREFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWE7QUFDN0IsUUFBUSxnREFBYTtBQUNyQixVQUFVLDhDQUFXO0FBQ3JCLFVBQVUsOENBQVc7QUFDckI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQyx5QkFBeUIsVUFBVTtBQUNuQywwQkFBMEIsV0FBVywwQ0FBTyxRQUFRO0FBQ3BELDBCQUEwQixVQUFVO0FBQ3BDLHlCQUF5QixVQUFVO0FBQ25DLHdCQUF3QixVQUFVO0FBQ2xDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1EOztBQUVuRCx1RkFBdUY7O0FBRXZGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLDJEQUFPLHVEQUF1RDtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTEVOT1ZPXFxEb2N1bWVudHNcXGdpdGh1YlxcemlrcmlhbmJpYS5naXRodWIuaW9cXG5vZGVfbW9kdWxlc1xcdGhyZWUtc3RkbGliXFxsaW5lc1xcTGluZU1hdGVyaWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3Jtc1V0aWxzLCBVbmlmb3Jtc0xpYiwgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fcG9seWZpbGwvY29uc3RhbnRzLmpzXCI7XG5jbGFzcyBMaW5lTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiBcIkxpbmVNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMuY2xvbmUoXG4gICAgICAgIFVuaWZvcm1zVXRpbHMubWVyZ2UoW1xuICAgICAgICAgIFVuaWZvcm1zTGliLmNvbW1vbixcbiAgICAgICAgICBVbmlmb3Jtc0xpYi5mb2csXG4gICAgICAgICAge1xuICAgICAgICAgICAgd29ybGRVbml0czogeyB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgbGluZXdpZHRoOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgICAgICByZXNvbHV0aW9uOiB7IHZhbHVlOiBuZXcgVmVjdG9yMigxLCAxKSB9LFxuICAgICAgICAgICAgZGFzaE9mZnNldDogeyB2YWx1ZTogMCB9LFxuICAgICAgICAgICAgZGFzaFNjYWxlOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBkYXNoU2l6ZTogeyB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgZ2FwU2l6ZTogeyB2YWx1ZTogMSB9XG4gICAgICAgICAgICAvLyB0b2RvIEZJWCAtIG1heWJlIGNoYW5nZSB0byB0b3RhbFNpemVcbiAgICAgICAgICB9XG4gICAgICAgIF0pXG4gICAgICApLFxuICAgICAgdmVydGV4U2hhZGVyOiAoXG4gICAgICAgIC8qIGdsc2wgKi9cbiAgICAgICAgYFxuXHRcdFx0XHQjaW5jbHVkZSA8Y29tbW9uPlxuXHRcdFx0XHQjaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuXHRcdFx0XHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG5cdFx0XHRcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XG5cblx0XHRcdFx0dW5pZm9ybSBmbG9hdCBsaW5ld2lkdGg7XG5cdFx0XHRcdHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlU3RhcnQ7XG5cdFx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kO1xuXG5cdFx0XHRcdCNpZmRlZiBVU0VfQ09MT1Jcblx0XHRcdFx0XHQjaWZkZWYgVVNFX0xJTkVfQ09MT1JfQUxQSEFcblx0XHRcdFx0XHRcdHZhcnlpbmcgdmVjNCB2TGluZUNvbG9yO1xuXHRcdFx0XHRcdFx0YXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvclN0YXJ0O1xuXHRcdFx0XHRcdFx0YXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvckVuZDtcblx0XHRcdFx0XHQjZWxzZVxuXHRcdFx0XHRcdFx0dmFyeWluZyB2ZWMzIHZMaW5lQ29sb3I7XG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUNvbG9yU3RhcnQ7XG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUNvbG9yRW5kO1xuXHRcdFx0XHRcdCNlbmRpZlxuXHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHQjaWZkZWYgV09STERfVU5JVFNcblxuXHRcdFx0XHRcdHZhcnlpbmcgdmVjNCB3b3JsZFBvcztcblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgd29ybGRTdGFydDtcblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgd29ybGRFbmQ7XG5cblx0XHRcdFx0XHQjaWZkZWYgVVNFX0RBU0hcblxuXHRcdFx0XHRcdFx0dmFyeWluZyB2ZWMyIHZVdjtcblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdCNlbHNlXG5cblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdCNpZmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCBkYXNoU2NhbGU7XG5cdFx0XHRcdFx0YXR0cmlidXRlIGZsb2F0IGluc3RhbmNlRGlzdGFuY2VTdGFydDtcblx0XHRcdFx0XHRhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VEaXN0YW5jZUVuZDtcblx0XHRcdFx0XHR2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XG5cblx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0dm9pZCB0cmltU2VnbWVudCggY29uc3QgaW4gdmVjNCBzdGFydCwgaW5vdXQgdmVjNCBlbmQgKSB7XG5cblx0XHRcdFx0XHQvLyB0cmltIGVuZCBzZWdtZW50IHNvIGl0IHRlcm1pbmF0ZXMgYmV0d2VlbiB0aGUgY2FtZXJhIHBsYW5lIGFuZCB0aGUgbmVhciBwbGFuZVxuXG5cdFx0XHRcdFx0Ly8gY29uc2VydmF0aXZlIGVzdGltYXRlIG9mIHRoZSBuZWFyIHBsYW5lXG5cdFx0XHRcdFx0ZmxvYXQgYSA9IHByb2plY3Rpb25NYXRyaXhbIDIgXVsgMiBdOyAvLyAzbmQgZW50cnkgaW4gM3RoIGNvbHVtblxuXHRcdFx0XHRcdGZsb2F0IGIgPSBwcm9qZWN0aW9uTWF0cml4WyAzIF1bIDIgXTsgLy8gM25kIGVudHJ5IGluIDR0aCBjb2x1bW5cblx0XHRcdFx0XHRmbG9hdCBuZWFyRXN0aW1hdGUgPSAtIDAuNSAqIGIgLyBhO1xuXG5cdFx0XHRcdFx0ZmxvYXQgYWxwaGEgPSAoIG5lYXJFc3RpbWF0ZSAtIHN0YXJ0LnogKSAvICggZW5kLnogLSBzdGFydC56ICk7XG5cblx0XHRcdFx0XHRlbmQueHl6ID0gbWl4KCBzdGFydC54eXosIGVuZC54eXosIGFscGhhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRcdCNpZmRlZiBVU0VfQ09MT1JcblxuXHRcdFx0XHRcdFx0dkxpbmVDb2xvciA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gaW5zdGFuY2VDb2xvclN0YXJ0IDogaW5zdGFuY2VDb2xvckVuZDtcblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0I2lmZGVmIFVTRV9EQVNIXG5cblx0XHRcdFx0XHRcdHZMaW5lRGlzdGFuY2UgPSAoIHBvc2l0aW9uLnkgPCAwLjUgKSA/IGRhc2hTY2FsZSAqIGluc3RhbmNlRGlzdGFuY2VTdGFydCA6IGRhc2hTY2FsZSAqIGluc3RhbmNlRGlzdGFuY2VFbmQ7XG5cdFx0XHRcdFx0XHR2VXYgPSB1djtcblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0ZmxvYXQgYXNwZWN0ID0gcmVzb2x1dGlvbi54IC8gcmVzb2x1dGlvbi55O1xuXG5cdFx0XHRcdFx0Ly8gY2FtZXJhIHNwYWNlXG5cdFx0XHRcdFx0dmVjNCBzdGFydCA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIGluc3RhbmNlU3RhcnQsIDEuMCApO1xuXHRcdFx0XHRcdHZlYzQgZW5kID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggaW5zdGFuY2VFbmQsIDEuMCApO1xuXG5cdFx0XHRcdFx0I2lmZGVmIFdPUkxEX1VOSVRTXG5cblx0XHRcdFx0XHRcdHdvcmxkU3RhcnQgPSBzdGFydC54eXo7XG5cdFx0XHRcdFx0XHR3b3JsZEVuZCA9IGVuZC54eXo7XG5cblx0XHRcdFx0XHQjZWxzZVxuXG5cdFx0XHRcdFx0XHR2VXYgPSB1djtcblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uLCBhbmQgc2VnbWVudHMgdGhhdCB0ZXJtaW5hdGUgZWl0aGVyIGluLCBvciBiZWhpbmQsIHRoZSBjYW1lcmEgcGxhbmVcblx0XHRcdFx0XHQvLyBjbGVhcmx5IHRoZSBncHUgZmlybXdhcmUgaGFzIGEgd2F5IG9mIGFkZHJlc3NpbmcgdGhpcyBpc3N1ZSB3aGVuIHByb2plY3RpbmcgaW50byBuZGMgc3BhY2Vcblx0XHRcdFx0XHQvLyBidXQgd2UgbmVlZCB0byBwZXJmb3JtIG5kYy1zcGFjZSBjYWxjdWxhdGlvbnMgaW4gdGhlIHNoYWRlciwgc28gd2UgbXVzdCBhZGRyZXNzIHRoaXMgaXNzdWUgZGlyZWN0bHlcblx0XHRcdFx0XHQvLyBwZXJoYXBzIHRoZXJlIGlzIGEgbW9yZSBlbGVnYW50IHNvbHV0aW9uIC0tIFdlc3RMYW5nbGV5XG5cblx0XHRcdFx0XHRib29sIHBlcnNwZWN0aXZlID0gKCBwcm9qZWN0aW9uTWF0cml4WyAyIF1bIDMgXSA9PSAtIDEuMCApOyAvLyA0dGggZW50cnkgaW4gdGhlIDNyZCBjb2x1bW5cblxuXHRcdFx0XHRcdGlmICggcGVyc3BlY3RpdmUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc3RhcnQueiA8IDAuMCAmJiBlbmQueiA+PSAwLjAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dHJpbVNlZ21lbnQoIHN0YXJ0LCBlbmQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggZW5kLnogPCAwLjAgJiYgc3RhcnQueiA+PSAwLjAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dHJpbVNlZ21lbnQoIGVuZCwgc3RhcnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2xpcCBzcGFjZVxuXHRcdFx0XHRcdHZlYzQgY2xpcFN0YXJ0ID0gcHJvamVjdGlvbk1hdHJpeCAqIHN0YXJ0O1xuXHRcdFx0XHRcdHZlYzQgY2xpcEVuZCA9IHByb2plY3Rpb25NYXRyaXggKiBlbmQ7XG5cblx0XHRcdFx0XHQvLyBuZGMgc3BhY2Vcblx0XHRcdFx0XHR2ZWMzIG5kY1N0YXJ0ID0gY2xpcFN0YXJ0Lnh5eiAvIGNsaXBTdGFydC53O1xuXHRcdFx0XHRcdHZlYzMgbmRjRW5kID0gY2xpcEVuZC54eXogLyBjbGlwRW5kLnc7XG5cblx0XHRcdFx0XHQvLyBkaXJlY3Rpb25cblx0XHRcdFx0XHR2ZWMyIGRpciA9IG5kY0VuZC54eSAtIG5kY1N0YXJ0Lnh5O1xuXG5cdFx0XHRcdFx0Ly8gYWNjb3VudCBmb3IgY2xpcC1zcGFjZSBhc3BlY3QgcmF0aW9cblx0XHRcdFx0XHRkaXIueCAqPSBhc3BlY3Q7XG5cdFx0XHRcdFx0ZGlyID0gbm9ybWFsaXplKCBkaXIgKTtcblxuXHRcdFx0XHRcdCNpZmRlZiBXT1JMRF9VTklUU1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIG9mZnNldCBkaXJlY3Rpb24gYXMgcGVycGVuZGljdWxhciB0byB0aGUgdmlldyB2ZWN0b3Jcblx0XHRcdFx0XHRcdHZlYzMgd29ybGREaXIgPSBub3JtYWxpemUoIGVuZC54eXogLSBzdGFydC54eXogKTtcblx0XHRcdFx0XHRcdHZlYzMgb2Zmc2V0O1xuXHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi55IDwgMC41ICkge1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHN0YXJ0Lnh5eiwgd29ybGREaXIgKSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGVuZC54eXosIHdvcmxkRGlyICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBzaWduIGZsaXBcblx0XHRcdFx0XHRcdGlmICggcG9zaXRpb24ueCA8IDAuMCApIG9mZnNldCAqPSAtIDEuMDtcblxuXHRcdFx0XHRcdFx0ZmxvYXQgZm9yd2FyZE9mZnNldCA9IGRvdCggd29ybGREaXIsIHZlYzMoIDAuMCwgMC4wLCAxLjAgKSApO1xuXG5cdFx0XHRcdFx0XHQvLyBkb24ndCBleHRlbmQgdGhlIGxpbmUgaWYgd2UncmUgcmVuZGVyaW5nIGRhc2hlcyBiZWNhdXNlIHdlXG5cdFx0XHRcdFx0XHQvLyB3b24ndCBiZSByZW5kZXJpbmcgdGhlIGVuZGNhcHNcblx0XHRcdFx0XHRcdCNpZm5kZWYgVVNFX0RBU0hcblxuXHRcdFx0XHRcdFx0XHQvLyBleHRlbmQgdGhlIGxpbmUgYm91bmRzIHRvIGVuY29tcGFzcyAgZW5kY2Fwc1xuXHRcdFx0XHRcdFx0XHRzdGFydC54eXogKz0gLSB3b3JsZERpciAqIGxpbmV3aWR0aCAqIDAuNTtcblx0XHRcdFx0XHRcdFx0ZW5kLnh5eiArPSB3b3JsZERpciAqIGxpbmV3aWR0aCAqIDAuNTtcblxuXHRcdFx0XHRcdFx0XHQvLyBzaGlmdCB0aGUgcG9zaXRpb24gb2YgdGhlIHF1YWQgc28gaXQgaHVncyB0aGUgZm9yd2FyZCBlZGdlIG9mIHRoZSBsaW5lXG5cdFx0XHRcdFx0XHRcdG9mZnNldC54eSAtPSBkaXIgKiBmb3J3YXJkT2Zmc2V0O1xuXHRcdFx0XHRcdFx0XHRvZmZzZXQueiArPSAwLjU7XG5cblx0XHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0XHQvLyBlbmRjYXBzXG5cdFx0XHRcdFx0XHRpZiAoIHBvc2l0aW9uLnkgPiAxLjAgfHwgcG9zaXRpb24ueSA8IDAuMCApIHtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQueHkgKz0gZGlyICogMi4wICogZm9yd2FyZE9mZnNldDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBhZGp1c3QgZm9yIGxpbmV3aWR0aFxuXHRcdFx0XHRcdFx0b2Zmc2V0ICo9IGxpbmV3aWR0aCAqIDAuNTtcblxuXHRcdFx0XHRcdFx0Ly8gc2V0IHRoZSB3b3JsZCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0d29ybGRQb3MgPSAoIHBvc2l0aW9uLnkgPCAwLjUgKSA/IHN0YXJ0IDogZW5kO1xuXHRcdFx0XHRcdFx0d29ybGRQb3MueHl6ICs9IG9mZnNldDtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvamVjdCB0aGUgd29ybGRwb3Ncblx0XHRcdFx0XHRcdHZlYzQgY2xpcCA9IHByb2plY3Rpb25NYXRyaXggKiB3b3JsZFBvcztcblxuXHRcdFx0XHRcdFx0Ly8gc2hpZnQgdGhlIGRlcHRoIG9mIHRoZSBwcm9qZWN0ZWQgcG9pbnRzIHNvIHRoZSBsaW5lXG5cdFx0XHRcdFx0XHQvLyBzZWdtZW50cyBvdmVybGFwIG5lYXRseVxuXHRcdFx0XHRcdFx0dmVjMyBjbGlwUG9zZSA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gbmRjU3RhcnQgOiBuZGNFbmQ7XG5cdFx0XHRcdFx0XHRjbGlwLnogPSBjbGlwUG9zZS56ICogY2xpcC53O1xuXG5cdFx0XHRcdFx0I2Vsc2VcblxuXHRcdFx0XHRcdFx0dmVjMiBvZmZzZXQgPSB2ZWMyKCBkaXIueSwgLSBkaXIueCApO1xuXHRcdFx0XHRcdFx0Ly8gdW5kbyBhc3BlY3QgcmF0aW8gYWRqdXN0bWVudFxuXHRcdFx0XHRcdFx0ZGlyLnggLz0gYXNwZWN0O1xuXHRcdFx0XHRcdFx0b2Zmc2V0LnggLz0gYXNwZWN0O1xuXG5cdFx0XHRcdFx0XHQvLyBzaWduIGZsaXBcblx0XHRcdFx0XHRcdGlmICggcG9zaXRpb24ueCA8IDAuMCApIG9mZnNldCAqPSAtIDEuMDtcblxuXHRcdFx0XHRcdFx0Ly8gZW5kY2Fwc1xuXHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi55IDwgMC4wICkge1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAtIGRpcjtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggcG9zaXRpb24ueSA+IDEuMCApIHtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gZGlyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBmb3IgbGluZXdpZHRoXG5cdFx0XHRcdFx0XHRvZmZzZXQgKj0gbGluZXdpZHRoO1xuXG5cdFx0XHRcdFx0XHQvLyBhZGp1c3QgZm9yIGNsaXAtc3BhY2UgdG8gc2NyZWVuLXNwYWNlIGNvbnZlcnNpb24gLy8gbWF5YmUgcmVzb2x1dGlvbiBzaG91bGQgYmUgYmFzZWQgb24gdmlld3BvcnQgLi4uXG5cdFx0XHRcdFx0XHRvZmZzZXQgLz0gcmVzb2x1dGlvbi55O1xuXG5cdFx0XHRcdFx0XHQvLyBzZWxlY3QgZW5kXG5cdFx0XHRcdFx0XHR2ZWM0IGNsaXAgPSAoIHBvc2l0aW9uLnkgPCAwLjUgKSA/IGNsaXBTdGFydCA6IGNsaXBFbmQ7XG5cblx0XHRcdFx0XHRcdC8vIGJhY2sgdG8gY2xpcCBzcGFjZVxuXHRcdFx0XHRcdFx0b2Zmc2V0ICo9IGNsaXAudztcblxuXHRcdFx0XHRcdFx0Y2xpcC54eSArPSBvZmZzZXQ7XG5cblx0XHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHRcdGdsX1Bvc2l0aW9uID0gY2xpcDtcblxuXHRcdFx0XHRcdHZlYzQgbXZQb3NpdGlvbiA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gc3RhcnQgOiBlbmQ7IC8vIHRoaXMgaXMgYW4gYXBwcm94aW1hdGlvblxuXG5cdFx0XHRcdFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cblxuXHRcdFx0XHR9XG5cdFx0XHRgXG4gICAgICApLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IChcbiAgICAgICAgLyogZ2xzbCAqL1xuICAgICAgICBgXG5cdFx0XHRcdHVuaWZvcm0gdmVjMyBkaWZmdXNlO1xuXHRcdFx0XHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG5cdFx0XHRcdHVuaWZvcm0gZmxvYXQgbGluZXdpZHRoO1xuXG5cdFx0XHRcdCNpZmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCBnYXBTaXplO1xuXG5cdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdHZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcblxuXHRcdFx0XHQjaWZkZWYgV09STERfVU5JVFNcblxuXHRcdFx0XHRcdHZhcnlpbmcgdmVjNCB3b3JsZFBvcztcblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgd29ybGRTdGFydDtcblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgd29ybGRFbmQ7XG5cblx0XHRcdFx0XHQjaWZkZWYgVVNFX0RBU0hcblxuXHRcdFx0XHRcdFx0dmFyeWluZyB2ZWMyIHZVdjtcblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdCNlbHNlXG5cblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cdFx0XHRcdCNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cblx0XHRcdFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XG5cdFx0XHRcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cblxuXHRcdFx0XHQjaWZkZWYgVVNFX0NPTE9SXG5cdFx0XHRcdFx0I2lmZGVmIFVTRV9MSU5FX0NPTE9SX0FMUEhBXG5cdFx0XHRcdFx0XHR2YXJ5aW5nIHZlYzQgdkxpbmVDb2xvcjtcblx0XHRcdFx0XHQjZWxzZVxuXHRcdFx0XHRcdFx0dmFyeWluZyB2ZWMzIHZMaW5lQ29sb3I7XG5cdFx0XHRcdFx0I2VuZGlmXG5cdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdHZlYzIgY2xvc2VzdExpbmVUb0xpbmUodmVjMyBwMSwgdmVjMyBwMiwgdmVjMyBwMywgdmVjMyBwNCkge1xuXG5cdFx0XHRcdFx0ZmxvYXQgbXVhO1xuXHRcdFx0XHRcdGZsb2F0IG11YjtcblxuXHRcdFx0XHRcdHZlYzMgcDEzID0gcDEgLSBwMztcblx0XHRcdFx0XHR2ZWMzIHA0MyA9IHA0IC0gcDM7XG5cblx0XHRcdFx0XHR2ZWMzIHAyMSA9IHAyIC0gcDE7XG5cblx0XHRcdFx0XHRmbG9hdCBkMTM0MyA9IGRvdCggcDEzLCBwNDMgKTtcblx0XHRcdFx0XHRmbG9hdCBkNDMyMSA9IGRvdCggcDQzLCBwMjEgKTtcblx0XHRcdFx0XHRmbG9hdCBkMTMyMSA9IGRvdCggcDEzLCBwMjEgKTtcblx0XHRcdFx0XHRmbG9hdCBkNDM0MyA9IGRvdCggcDQzLCBwNDMgKTtcblx0XHRcdFx0XHRmbG9hdCBkMjEyMSA9IGRvdCggcDIxLCBwMjEgKTtcblxuXHRcdFx0XHRcdGZsb2F0IGRlbm9tID0gZDIxMjEgKiBkNDM0MyAtIGQ0MzIxICogZDQzMjE7XG5cblx0XHRcdFx0XHRmbG9hdCBudW1lciA9IGQxMzQzICogZDQzMjEgLSBkMTMyMSAqIGQ0MzQzO1xuXG5cdFx0XHRcdFx0bXVhID0gbnVtZXIgLyBkZW5vbTtcblx0XHRcdFx0XHRtdWEgPSBjbGFtcCggbXVhLCAwLjAsIDEuMCApO1xuXHRcdFx0XHRcdG11YiA9ICggZDEzNDMgKyBkNDMyMSAqICggbXVhICkgKSAvIGQ0MzQzO1xuXHRcdFx0XHRcdG11YiA9IGNsYW1wKCBtdWIsIDAuMCwgMS4wICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdmVjMiggbXVhLCBtdWIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblxuXHRcdFx0XHRcdCNpZmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0XHRpZiAoIHZVdi55IDwgLSAxLjAgfHwgdlV2LnkgPiAxLjAgKSBkaXNjYXJkOyAvLyBkaXNjYXJkIGVuZGNhcHNcblxuXHRcdFx0XHRcdFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UgKyBkYXNoT2Zmc2V0LCBkYXNoU2l6ZSArIGdhcFNpemUgKSA+IGRhc2hTaXplICkgZGlzY2FyZDsgLy8gdG9kbyAtIEZJWFxuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHRmbG9hdCBhbHBoYSA9IG9wYWNpdHk7XG5cblx0XHRcdFx0XHQjaWZkZWYgV09STERfVU5JVFNcblxuXHRcdFx0XHRcdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBwb2ludHMgb24gdGhlIHZpZXcgcmF5IGFuZCB0aGUgbGluZSBzZWdtZW50XG5cdFx0XHRcdFx0XHR2ZWMzIHJheUVuZCA9IG5vcm1hbGl6ZSggd29ybGRQb3MueHl6ICkgKiAxZTU7XG5cdFx0XHRcdFx0XHR2ZWMzIGxpbmVEaXIgPSB3b3JsZEVuZCAtIHdvcmxkU3RhcnQ7XG5cdFx0XHRcdFx0XHR2ZWMyIHBhcmFtcyA9IGNsb3Nlc3RMaW5lVG9MaW5lKCB3b3JsZFN0YXJ0LCB3b3JsZEVuZCwgdmVjMyggMC4wLCAwLjAsIDAuMCApLCByYXlFbmQgKTtcblxuXHRcdFx0XHRcdFx0dmVjMyBwMSA9IHdvcmxkU3RhcnQgKyBsaW5lRGlyICogcGFyYW1zLng7XG5cdFx0XHRcdFx0XHR2ZWMzIHAyID0gcmF5RW5kICogcGFyYW1zLnk7XG5cdFx0XHRcdFx0XHR2ZWMzIGRlbHRhID0gcDEgLSBwMjtcblx0XHRcdFx0XHRcdGZsb2F0IGxlbiA9IGxlbmd0aCggZGVsdGEgKTtcblx0XHRcdFx0XHRcdGZsb2F0IG5vcm0gPSBsZW4gLyBsaW5ld2lkdGg7XG5cblx0XHRcdFx0XHRcdCNpZm5kZWYgVVNFX0RBU0hcblxuXHRcdFx0XHRcdFx0XHQjaWZkZWYgVVNFX0FMUEhBX1RPX0NPVkVSQUdFXG5cblx0XHRcdFx0XHRcdFx0XHRmbG9hdCBkbm9ybSA9IGZ3aWR0aCggbm9ybSApO1xuXHRcdFx0XHRcdFx0XHRcdGFscGhhID0gMS4wIC0gc21vb3Roc3RlcCggMC41IC0gZG5vcm0sIDAuNSArIGRub3JtLCBub3JtICk7XG5cblx0XHRcdFx0XHRcdFx0I2Vsc2VcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9ybSA+IDAuNSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGlzY2FyZDtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHQjZWxzZVxuXG5cdFx0XHRcdFx0XHQjaWZkZWYgVVNFX0FMUEhBX1RPX0NPVkVSQUdFXG5cblx0XHRcdFx0XHRcdFx0Ly8gYXJ0aWZhY3RzIGFwcGVhciBvbiBzb21lIGhhcmR3YXJlIGlmIGEgZGVyaXZhdGl2ZSBpcyB0YWtlbiB3aXRoaW4gYSBjb25kaXRpb25hbFxuXHRcdFx0XHRcdFx0XHRmbG9hdCBhID0gdlV2Lng7XG5cdFx0XHRcdFx0XHRcdGZsb2F0IGIgPSAoIHZVdi55ID4gMC4wICkgPyB2VXYueSAtIDEuMCA6IHZVdi55ICsgMS4wO1xuXHRcdFx0XHRcdFx0XHRmbG9hdCBsZW4yID0gYSAqIGEgKyBiICogYjtcblx0XHRcdFx0XHRcdFx0ZmxvYXQgZGxlbiA9IGZ3aWR0aCggbGVuMiApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggYWJzKCB2VXYueSApID4gMS4wICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0YWxwaGEgPSAxLjAgLSBzbW9vdGhzdGVwKCAxLjAgLSBkbGVuLCAxLjAgKyBkbGVuLCBsZW4yICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQjZWxzZVxuXG5cdFx0XHRcdFx0XHRcdGlmICggYWJzKCB2VXYueSApID4gMS4wICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZmxvYXQgYSA9IHZVdi54O1xuXHRcdFx0XHRcdFx0XHRcdGZsb2F0IGIgPSAoIHZVdi55ID4gMC4wICkgPyB2VXYueSAtIDEuMCA6IHZVdi55ICsgMS4wO1xuXHRcdFx0XHRcdFx0XHRcdGZsb2F0IGxlbjIgPSBhICogYSArIGIgKiBiO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBsZW4yID4gMS4wICkgZGlzY2FyZDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIGFscGhhICk7XG5cdFx0XHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxuXHRcdFx0XHRcdFx0I2lmZGVmIFVTRV9MSU5FX0NPTE9SX0FMUEhBXG5cdFx0XHRcdFx0XHRcdGRpZmZ1c2VDb2xvciAqPSB2TGluZUNvbG9yO1xuXHRcdFx0XHRcdFx0I2Vsc2Vcblx0XHRcdFx0XHRcdFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2TGluZUNvbG9yO1xuXHRcdFx0XHRcdFx0I2VuZGlmXG5cdFx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XG5cblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBkaWZmdXNlQ29sb3I7XG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG5cdFx0XHRcdFx0I2luY2x1ZGUgPCR7dmVyc2lvbiA+PSAxNTQgPyBcImNvbG9yc3BhY2VfZnJhZ21lbnRcIiA6IFwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxuXHRcdFx0XHRcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XG5cdFx0XHRcdFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XG5cblx0XHRcdFx0fVxuXHRcdFx0YFxuICAgICAgKSxcbiAgICAgIGNsaXBwaW5nOiB0cnVlXG4gICAgICAvLyByZXF1aXJlZCBmb3IgY2xpcHBpbmcgc3VwcG9ydFxuICAgIH0pO1xuICAgIHRoaXMuaXNMaW5lTWF0ZXJpYWwgPSB0cnVlO1xuICAgIHRoaXMub25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFuc3BhcmVudCkge1xuICAgICAgICB0aGlzLmRlZmluZXMuVVNFX0xJTkVfQ09MT1JfQUxQSEEgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX0xJTkVfQ09MT1JfQUxQSEE7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpZmZ1c2UudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdvcmxkVW5pdHM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gXCJXT1JMRF9VTklUU1wiIGluIHRoaXMuZGVmaW5lcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLldPUkxEX1VOSVRTID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5XT1JMRF9VTklUUztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5ld2lkdGg6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saW5ld2lkdGgudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmxpbmV3aWR0aC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGFzaGVkOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oXCJVU0VfREFTSFwiIGluIHRoaXMuZGVmaW5lcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSAhPT0gQm9vbGVhbihcIlVTRV9EQVNIXCIgaW4gdGhpcy5kZWZpbmVzKSkge1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlVTRV9EQVNIID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfREFTSDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkYXNoU2NhbGU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kYXNoU2NhbGUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRhc2hTY2FsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGFzaFNpemU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hPZmZzZXQ6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kYXNoT2Zmc2V0LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5kYXNoT2Zmc2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnYXBTaXplOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2FwU2l6ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZ2FwU2l6ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc29sdXRpb246IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLmNvcHkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxwaGFUb0NvdmVyYWdlOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oXCJVU0VfQUxQSEFfVE9fQ09WRVJBR0VcIiBpbiB0aGlzLmRlZmluZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpICE9PSBCb29sZWFuKFwiVVNFX0FMUEhBX1RPX0NPVkVSQUdFXCIgaW4gdGhpcy5kZWZpbmVzKSkge1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlVTRV9BTFBIQV9UT19DT1ZFUkFHRSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9BTFBIQV9UT19DT1ZFUkFHRTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuICB9XG59XG5leHBvcnQge1xuICBMaW5lTWF0ZXJpYWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lTWF0ZXJpYWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineSegments2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineSegments2: () => (/* binding */ LineSegments2)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineSegmentsGeometry.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\");\n/* harmony import */ var _LineMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineMaterial.js */ \"(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\");\n/* harmony import */ var _polyfill_uv1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/uv1.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/uv1.js\");\n\n\n\n\nconst _viewport = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _start = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _end = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _start4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _end4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _ssOrigin = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nconst _ssOrigin3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _mvMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _line = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\nconst _closestPoint = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _box = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst _sphere = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\nconst _clipToWorldVector = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\nlet _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [_polyfill_uv1_js__WEBPACK_IMPORTED_MODULE_1__.UV1]: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [_polyfill_uv1_js__WEBPACK_IMPORTED_MODULE_1__.UV1]: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  constructor(geometry = new _LineSegmentsGeometry_js__WEBPACK_IMPORTED_MODULE_2__.LineSegmentsGeometry(), material = new _LineMaterial_js__WEBPACK_IMPORTED_MODULE_3__.LineMaterial({ color: Math.random() * 16777215 })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'\n      );\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\n\n//# sourceMappingURL=LineSegments2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVTZWdtZW50czIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0o7QUFDL0U7QUFDaEI7QUFDUDtBQUMxQyxzQ0FBc0MsMENBQU87QUFDN0MsbUNBQW1DLDBDQUFPO0FBQzFDLGlDQUFpQywwQ0FBTztBQUN4QyxvQ0FBb0MsMENBQU87QUFDM0Msa0NBQWtDLDBDQUFPO0FBQ3pDLHNDQUFzQywwQ0FBTztBQUM3Qyx1Q0FBdUMsMENBQU87QUFDOUMsc0NBQXNDLDBDQUFPO0FBQzdDLGtDQUFrQyx3Q0FBSztBQUN2QywwQ0FBMEMsMENBQU87QUFDakQsaUNBQWlDLHVDQUFJO0FBQ3JDLG9DQUFvQyx5Q0FBTTtBQUMxQywrQ0FBK0MsMENBQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQU87QUFDbkMsc0JBQXNCLDBDQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFHO0FBQ1osT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBTztBQUNyQyx3QkFBd0IsMENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBRztBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQUk7QUFDaEMsNkJBQTZCLDBFQUFvQixtQkFBbUIsMERBQVksR0FBRyxpQ0FBaUM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZEQUEwQjtBQUNqRSx1REFBdUQsNkRBQTBCO0FBQ2pGLHFEQUFxRCw2REFBMEI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxMRU5PVk9cXERvY3VtZW50c1xcZ2l0aHViXFx6aWtyaWFuYmlhLmdpdGh1Yi5pb1xcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXGxpbmVzXFxMaW5lU2VnbWVudHMyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lc2gsIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVmVjdG9yNCwgVmVjdG9yMywgQm94MywgU3BoZXJlLCBNYXRoVXRpbHMsIE1hdHJpeDQsIExpbmUzIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBMaW5lU2VnbWVudHNHZW9tZXRyeSB9IGZyb20gXCIuL0xpbmVTZWdtZW50c0dlb21ldHJ5LmpzXCI7XG5pbXBvcnQgeyBMaW5lTWF0ZXJpYWwgfSBmcm9tIFwiLi9MaW5lTWF0ZXJpYWwuanNcIjtcbmltcG9ydCB7IFVWMSB9IGZyb20gXCIuLi9fcG9seWZpbGwvdXYxLmpzXCI7XG5jb25zdCBfdmlld3BvcnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF9zdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2VuZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3N0YXJ0NCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX2VuZDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF9zc09yaWdpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3NzT3JpZ2luMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX212TWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfbGluZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTGluZTMoKTtcbmNvbnN0IF9jbG9zZXN0UG9pbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9zcGhlcmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNwaGVyZSgpO1xuY29uc3QgX2NsaXBUb1dvcmxkVmVjdG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3I0KCk7XG5sZXQgX3JheSwgX2xpbmVXaWR0aDtcbmZ1bmN0aW9uIGdldFdvcmxkU3BhY2VIYWxmV2lkdGgoY2FtZXJhLCBkaXN0YW5jZSwgcmVzb2x1dGlvbikge1xuICBfY2xpcFRvV29ybGRWZWN0b3Iuc2V0KDAsIDAsIC1kaXN0YW5jZSwgMSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgX2NsaXBUb1dvcmxkVmVjdG9yLm11bHRpcGx5U2NhbGFyKDEgLyBfY2xpcFRvV29ybGRWZWN0b3Iudyk7XG4gIF9jbGlwVG9Xb3JsZFZlY3Rvci54ID0gX2xpbmVXaWR0aCAvIHJlc29sdXRpb24ud2lkdGg7XG4gIF9jbGlwVG9Xb3JsZFZlY3Rvci55ID0gX2xpbmVXaWR0aCAvIHJlc29sdXRpb24uaGVpZ2h0O1xuICBfY2xpcFRvV29ybGRWZWN0b3IuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSk7XG4gIF9jbGlwVG9Xb3JsZFZlY3Rvci5tdWx0aXBseVNjYWxhcigxIC8gX2NsaXBUb1dvcmxkVmVjdG9yLncpO1xuICByZXR1cm4gTWF0aC5hYnMoTWF0aC5tYXgoX2NsaXBUb1dvcmxkVmVjdG9yLngsIF9jbGlwVG9Xb3JsZFZlY3Rvci55KSk7XG59XG5mdW5jdGlvbiByYXljYXN0V29ybGRVbml0cyhsaW5lU2VnbWVudHMsIGludGVyc2VjdHMpIHtcbiAgY29uc3QgbWF0cml4V29ybGQgPSBsaW5lU2VnbWVudHMubWF0cml4V29ybGQ7XG4gIGNvbnN0IGdlb21ldHJ5ID0gbGluZVNlZ21lbnRzLmdlb21ldHJ5O1xuICBjb25zdCBpbnN0YW5jZVN0YXJ0ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbnN0YW5jZVN0YXJ0O1xuICBjb25zdCBpbnN0YW5jZUVuZCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQ7XG4gIGNvbnN0IHNlZ21lbnRDb3VudCA9IE1hdGgubWluKGdlb21ldHJ5Lmluc3RhbmNlQ291bnQsIGluc3RhbmNlU3RhcnQuY291bnQpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHNlZ21lbnRDb3VudDsgaSA8IGw7IGkrKykge1xuICAgIF9saW5lLnN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VTdGFydCwgaSk7XG4gICAgX2xpbmUuZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VFbmQsIGkpO1xuICAgIF9saW5lLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG4gICAgY29uc3QgcG9pbnRPbkxpbmUgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBfcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoX2xpbmUuc3RhcnQsIF9saW5lLmVuZCwgcG9pbnQsIHBvaW50T25MaW5lKTtcbiAgICBjb25zdCBpc0luc2lkZSA9IHBvaW50LmRpc3RhbmNlVG8ocG9pbnRPbkxpbmUpIDwgX2xpbmVXaWR0aCAqIDAuNTtcbiAgICBpZiAoaXNJbnNpZGUpIHtcbiAgICAgIGludGVyc2VjdHMucHVzaCh7XG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludE9uTGluZSxcbiAgICAgICAgZGlzdGFuY2U6IF9yYXkub3JpZ2luLmRpc3RhbmNlVG8ocG9pbnQpLFxuICAgICAgICBvYmplY3Q6IGxpbmVTZWdtZW50cyxcbiAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgZmFjZUluZGV4OiBpLFxuICAgICAgICB1djogbnVsbCxcbiAgICAgICAgW1VWMV06IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmF5Y2FzdFNjcmVlblNwYWNlKGxpbmVTZWdtZW50cywgY2FtZXJhLCBpbnRlcnNlY3RzKSB7XG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeDtcbiAgY29uc3QgbWF0ZXJpYWwgPSBsaW5lU2VnbWVudHMubWF0ZXJpYWw7XG4gIGNvbnN0IHJlc29sdXRpb24gPSBtYXRlcmlhbC5yZXNvbHV0aW9uO1xuICBjb25zdCBtYXRyaXhXb3JsZCA9IGxpbmVTZWdtZW50cy5tYXRyaXhXb3JsZDtcbiAgY29uc3QgZ2VvbWV0cnkgPSBsaW5lU2VnbWVudHMuZ2VvbWV0cnk7XG4gIGNvbnN0IGluc3RhbmNlU3RhcnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQ7XG4gIGNvbnN0IGluc3RhbmNlRW5kID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbnN0YW5jZUVuZDtcbiAgY29uc3Qgc2VnbWVudENvdW50ID0gTWF0aC5taW4oZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCwgaW5zdGFuY2VTdGFydC5jb3VudCk7XG4gIGNvbnN0IG5lYXIgPSAtY2FtZXJhLm5lYXI7XG4gIF9yYXkuYXQoMSwgX3NzT3JpZ2luKTtcbiAgX3NzT3JpZ2luLncgPSAxO1xuICBfc3NPcmlnaW4uYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuICBfc3NPcmlnaW4uYXBwbHlNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpO1xuICBfc3NPcmlnaW4ubXVsdGlwbHlTY2FsYXIoMSAvIF9zc09yaWdpbi53KTtcbiAgX3NzT3JpZ2luLnggKj0gcmVzb2x1dGlvbi54IC8gMjtcbiAgX3NzT3JpZ2luLnkgKj0gcmVzb2x1dGlvbi55IC8gMjtcbiAgX3NzT3JpZ2luLnogPSAwO1xuICBfc3NPcmlnaW4zLmNvcHkoX3NzT3JpZ2luKTtcbiAgX212TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgbWF0cml4V29ybGQpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHNlZ21lbnRDb3VudDsgaSA8IGw7IGkrKykge1xuICAgIF9zdGFydDQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZVN0YXJ0LCBpKTtcbiAgICBfZW5kNC5mcm9tQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlRW5kLCBpKTtcbiAgICBfc3RhcnQ0LncgPSAxO1xuICAgIF9lbmQ0LncgPSAxO1xuICAgIF9zdGFydDQuYXBwbHlNYXRyaXg0KF9tdk1hdHJpeCk7XG4gICAgX2VuZDQuYXBwbHlNYXRyaXg0KF9tdk1hdHJpeCk7XG4gICAgY29uc3QgaXNCZWhpbmRDYW1lcmFOZWFyID0gX3N0YXJ0NC56ID4gbmVhciAmJiBfZW5kNC56ID4gbmVhcjtcbiAgICBpZiAoaXNCZWhpbmRDYW1lcmFOZWFyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKF9zdGFydDQueiA+IG5lYXIpIHtcbiAgICAgIGNvbnN0IGRlbHRhRGlzdCA9IF9zdGFydDQueiAtIF9lbmQ0Lno7XG4gICAgICBjb25zdCB0ID0gKF9zdGFydDQueiAtIG5lYXIpIC8gZGVsdGFEaXN0O1xuICAgICAgX3N0YXJ0NC5sZXJwKF9lbmQ0LCB0KTtcbiAgICB9IGVsc2UgaWYgKF9lbmQ0LnogPiBuZWFyKSB7XG4gICAgICBjb25zdCBkZWx0YURpc3QgPSBfZW5kNC56IC0gX3N0YXJ0NC56O1xuICAgICAgY29uc3QgdCA9IChfZW5kNC56IC0gbmVhcikgLyBkZWx0YURpc3Q7XG4gICAgICBfZW5kNC5sZXJwKF9zdGFydDQsIHQpO1xuICAgIH1cbiAgICBfc3RhcnQ0LmFwcGx5TWF0cml4NChwcm9qZWN0aW9uTWF0cml4KTtcbiAgICBfZW5kNC5hcHBseU1hdHJpeDQocHJvamVjdGlvbk1hdHJpeCk7XG4gICAgX3N0YXJ0NC5tdWx0aXBseVNjYWxhcigxIC8gX3N0YXJ0NC53KTtcbiAgICBfZW5kNC5tdWx0aXBseVNjYWxhcigxIC8gX2VuZDQudyk7XG4gICAgX3N0YXJ0NC54ICo9IHJlc29sdXRpb24ueCAvIDI7XG4gICAgX3N0YXJ0NC55ICo9IHJlc29sdXRpb24ueSAvIDI7XG4gICAgX2VuZDQueCAqPSByZXNvbHV0aW9uLnggLyAyO1xuICAgIF9lbmQ0LnkgKj0gcmVzb2x1dGlvbi55IC8gMjtcbiAgICBfbGluZS5zdGFydC5jb3B5KF9zdGFydDQpO1xuICAgIF9saW5lLnN0YXJ0LnogPSAwO1xuICAgIF9saW5lLmVuZC5jb3B5KF9lbmQ0KTtcbiAgICBfbGluZS5lbmQueiA9IDA7XG4gICAgY29uc3QgcGFyYW0gPSBfbGluZS5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKF9zc09yaWdpbjMsIHRydWUpO1xuICAgIF9saW5lLmF0KHBhcmFtLCBfY2xvc2VzdFBvaW50KTtcbiAgICBjb25zdCB6UG9zID0gTWF0aFV0aWxzLmxlcnAoX3N0YXJ0NC56LCBfZW5kNC56LCBwYXJhbSk7XG4gICAgY29uc3QgaXNJbkNsaXBTcGFjZSA9IHpQb3MgPj0gLTEgJiYgelBvcyA8PSAxO1xuICAgIGNvbnN0IGlzSW5zaWRlID0gX3NzT3JpZ2luMy5kaXN0YW5jZVRvKF9jbG9zZXN0UG9pbnQpIDwgX2xpbmVXaWR0aCAqIDAuNTtcbiAgICBpZiAoaXNJbkNsaXBTcGFjZSAmJiBpc0luc2lkZSkge1xuICAgICAgX2xpbmUuc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZVN0YXJ0LCBpKTtcbiAgICAgIF9saW5lLmVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlRW5kLCBpKTtcbiAgICAgIF9saW5lLnN0YXJ0LmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG4gICAgICBfbGluZS5lbmQuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgIGNvbnN0IHBvaW50T25MaW5lID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIF9yYXkuZGlzdGFuY2VTcVRvU2VnbWVudChfbGluZS5zdGFydCwgX2xpbmUuZW5kLCBwb2ludCwgcG9pbnRPbkxpbmUpO1xuICAgICAgaW50ZXJzZWN0cy5wdXNoKHtcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50T25MaW5lLFxuICAgICAgICBkaXN0YW5jZTogX3JheS5vcmlnaW4uZGlzdGFuY2VUbyhwb2ludCksXG4gICAgICAgIG9iamVjdDogbGluZVNlZ21lbnRzLFxuICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICBmYWNlSW5kZXg6IGksXG4gICAgICAgIHV2OiBudWxsLFxuICAgICAgICBbVVYxXTogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBMaW5lU2VnbWVudHMyIGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IExpbmVTZWdtZW50c0dlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVNYXRlcmlhbCh7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMTY3NzcyMTUgfSkpIHtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIHRoaXMuaXNMaW5lU2VnbWVudHMyID0gdHJ1ZTtcbiAgICB0aGlzLnR5cGUgPSBcIkxpbmVTZWdtZW50czJcIjtcbiAgfVxuICAvLyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGJ1dCBjb3VsZCBiZSBhIG1ldGhvZCBvZiBMaW5lU2VnbWVudHNHZW9tZXRyeS4uLlxuICBjb21wdXRlTGluZURpc3RhbmNlcygpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgY29uc3QgaW5zdGFuY2VTdGFydCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VTdGFydDtcbiAgICBjb25zdCBpbnN0YW5jZUVuZCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQ7XG4gICAgY29uc3QgbGluZURpc3RhbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIGluc3RhbmNlU3RhcnQuY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgbCA9IGluc3RhbmNlU3RhcnQuY291bnQ7IGkgPCBsOyBpKyssIGogKz0gMikge1xuICAgICAgX3N0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VTdGFydCwgaSk7XG4gICAgICBfZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VFbmQsIGkpO1xuICAgICAgbGluZURpc3RhbmNlc1tqXSA9IGogPT09IDAgPyAwIDogbGluZURpc3RhbmNlc1tqIC0gMV07XG4gICAgICBsaW5lRGlzdGFuY2VzW2ogKyAxXSA9IGxpbmVEaXN0YW5jZXNbal0gKyBfc3RhcnQuZGlzdGFuY2VUbyhfZW5kKTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2VEaXN0YW5jZUJ1ZmZlciA9IG5ldyBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcihsaW5lRGlzdGFuY2VzLCAyLCAxKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJpbnN0YW5jZURpc3RhbmNlU3RhcnRcIiwgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlRGlzdGFuY2VCdWZmZXIsIDEsIDApKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJpbnN0YW5jZURpc3RhbmNlRW5kXCIsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZURpc3RhbmNlQnVmZmVyLCAxLCAxKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICBjb25zdCB3b3JsZFVuaXRzID0gdGhpcy5tYXRlcmlhbC53b3JsZFVuaXRzO1xuICAgIGNvbnN0IGNhbWVyYSA9IHJheWNhc3Rlci5jYW1lcmE7XG4gICAgaWYgKGNhbWVyYSA9PT0gbnVsbCAmJiAhd29ybGRVbml0cykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xpbmVTZWdtZW50czI6IFwiUmF5Y2FzdGVyLmNhbWVyYVwiIG5lZWRzIHRvIGJlIHNldCBpbiBvcmRlciB0byByYXljYXN0IGFnYWluc3QgTGluZVNlZ21lbnRzMiB3aGlsZSB3b3JsZFVuaXRzIGlzIHNldCB0byBmYWxzZS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLkxpbmUyICE9PSB2b2lkIDAgPyByYXljYXN0ZXIucGFyYW1zLkxpbmUyLnRocmVzaG9sZCB8fCAwIDogMDtcbiAgICBfcmF5ID0gcmF5Y2FzdGVyLnJheTtcbiAgICBjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICBfbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoICsgdGhyZXNob2xkO1xuICAgIGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkge1xuICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgfVxuICAgIF9zcGhlcmUuY29weShnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSkuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICBsZXQgc3BoZXJlTWFyZ2luO1xuICAgIGlmICh3b3JsZFVuaXRzKSB7XG4gICAgICBzcGhlcmVNYXJnaW4gPSBfbGluZVdpZHRoICogMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvU3BoZXJlID0gTWF0aC5tYXgoY2FtZXJhLm5lYXIsIF9zcGhlcmUuZGlzdGFuY2VUb1BvaW50KF9yYXkub3JpZ2luKSk7XG4gICAgICBzcGhlcmVNYXJnaW4gPSBnZXRXb3JsZFNwYWNlSGFsZldpZHRoKGNhbWVyYSwgZGlzdGFuY2VUb1NwaGVyZSwgbWF0ZXJpYWwucmVzb2x1dGlvbik7XG4gICAgfVxuICAgIF9zcGhlcmUucmFkaXVzICs9IHNwaGVyZU1hcmdpbjtcbiAgICBpZiAoX3JheS5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwpIHtcbiAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgIH1cbiAgICBfYm94LmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdCb3gpLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG4gICAgbGV0IGJveE1hcmdpbjtcbiAgICBpZiAod29ybGRVbml0cykge1xuICAgICAgYm94TWFyZ2luID0gX2xpbmVXaWR0aCAqIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzdGFuY2VUb0JveCA9IE1hdGgubWF4KGNhbWVyYS5uZWFyLCBfYm94LmRpc3RhbmNlVG9Qb2ludChfcmF5Lm9yaWdpbikpO1xuICAgICAgYm94TWFyZ2luID0gZ2V0V29ybGRTcGFjZUhhbGZXaWR0aChjYW1lcmEsIGRpc3RhbmNlVG9Cb3gsIG1hdGVyaWFsLnJlc29sdXRpb24pO1xuICAgIH1cbiAgICBfYm94LmV4cGFuZEJ5U2NhbGFyKGJveE1hcmdpbik7XG4gICAgaWYgKF9yYXkuaW50ZXJzZWN0c0JveChfYm94KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdvcmxkVW5pdHMpIHtcbiAgICAgIHJheWNhc3RXb3JsZFVuaXRzKHRoaXMsIGludGVyc2VjdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXljYXN0U2NyZWVuU3BhY2UodGhpcywgY2FtZXJhLCBpbnRlcnNlY3RzKTtcbiAgICB9XG4gIH1cbiAgb25CZWZvcmVSZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMubWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgaWYgKHVuaWZvcm1zICYmIHVuaWZvcm1zLnJlc29sdXRpb24pIHtcbiAgICAgIHJlbmRlcmVyLmdldFZpZXdwb3J0KF92aWV3cG9ydCk7XG4gICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuc2V0KF92aWV3cG9ydC56LCBfdmlld3BvcnQudyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBMaW5lU2VnbWVudHMyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZVNlZ21lbnRzMi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/lines/LineSegmentsGeometry.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineSegmentsGeometry: () => (/* binding */ LineSegmentsGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst _box = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst _vector = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nclass LineSegmentsGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer(colors, itemSize * 2, 1);\n    this.setAttribute(\"instanceColorStart\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0));\n    this.setAttribute(\"instanceColorEnd\", new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new three__WEBPACK_IMPORTED_MODULE_0__.WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box.setFromBufferAttribute(end);\n      this.boundingBox.union(_box);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          \"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\",\n          this\n        );\n      }\n    }\n  }\n  toJSON() {\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\n\n//# sourceMappingURL=LineSegmentsGeometry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpbmVzL0xpbmVTZWdtZW50c0dlb21ldHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBLO0FBQzFLLGlDQUFpQyx1Q0FBSTtBQUNyQyxvQ0FBb0MsMENBQU87QUFDM0MsbUNBQW1DLDBEQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlEQUFzQjtBQUM1RCxnQ0FBZ0MseURBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0JBQStCLDZEQUEwQjtBQUN6RCwyQ0FBMkMsNkRBQTBCO0FBQ3JFLHlDQUF5Qyw2REFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0NBQW9DLDZEQUEwQjtBQUM5RCxnREFBZ0QsNkRBQTBCO0FBQzFFLDhDQUE4Qyw2REFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUNBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbGluZXNcXExpbmVTZWdtZW50c0dlb21ldHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIFdpcmVmcmFtZUdlb21ldHJ5LCBCb3gzLCBTcGhlcmUsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92ZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNsYXNzIExpbmVTZWdtZW50c0dlb21ldHJ5IGV4dGVuZHMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaXNMaW5lU2VnbWVudHNHZW9tZXRyeSA9IHRydWU7XG4gICAgdGhpcy50eXBlID0gXCJMaW5lU2VnbWVudHNHZW9tZXRyeVwiO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMSwgMiwgMCwgMSwgMiwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIC0xLCAwLCAwLCAxLCAwLCAwLCAtMSwgLTEsIDAsIDEsIC0xLCAwXTtcbiAgICBjb25zdCB1dnMgPSBbLTEsIDIsIDEsIDIsIC0xLCAxLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAtMSwgLTIsIDEsIC0yXTtcbiAgICBjb25zdCBpbmRleCA9IFswLCAyLCAxLCAyLCAzLCAxLCAyLCA0LCAzLCA0LCA1LCAzLCA0LCA2LCA1LCA2LCA3LCA1XTtcbiAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidXZcIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG4gIH1cbiAgYXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQ7XG4gICAgY29uc3QgZW5kID0gdGhpcy5hdHRyaWJ1dGVzLmluc3RhbmNlRW5kO1xuICAgIGlmIChzdGFydCAhPT0gdm9pZCAwKSB7XG4gICAgICBzdGFydC5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIGVuZC5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIHN0YXJ0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRQb3NpdGlvbnMoYXJyYXkpIHtcbiAgICBsZXQgbGluZVNlZ21lbnRzO1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgbGluZVNlZ21lbnRzID0gYXJyYXk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgbGluZVNlZ21lbnRzID0gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlQnVmZmVyID0gbmV3IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKGxpbmVTZWdtZW50cywgNiwgMSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJpbnN0YW5jZVN0YXJ0XCIsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZUJ1ZmZlciwgMywgMCkpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiaW5zdGFuY2VFbmRcIiwgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlQnVmZmVyLCAzLCAzKSk7XG4gICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldENvbG9ycyhhcnJheSwgaXRlbVNpemUgPSAzKSB7XG4gICAgbGV0IGNvbG9ycztcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGNvbG9ycyA9IGFycmF5O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZUNvbG9yQnVmZmVyID0gbmV3IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKGNvbG9ycywgaXRlbVNpemUgKiAyLCAxKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImluc3RhbmNlQ29sb3JTdGFydFwiLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VDb2xvckJ1ZmZlciwgaXRlbVNpemUsIDApKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImluc3RhbmNlQ29sb3JFbmRcIiwgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlQ29sb3JCdWZmZXIsIGl0ZW1TaXplLCBpdGVtU2l6ZSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZyb21XaXJlZnJhbWVHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHRoaXMuc2V0UG9zaXRpb25zKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZyb21FZGdlc0dlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdGhpcy5zZXRQb3NpdGlvbnMoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnJvbU1lc2gobWVzaCkge1xuICAgIHRoaXMuZnJvbVdpcmVmcmFtZUdlb21ldHJ5KG5ldyBXaXJlZnJhbWVHZW9tZXRyeShtZXNoLmdlb21ldHJ5KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnJvbUxpbmVTZWdtZW50cyhsaW5lU2VnbWVudHMpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IGxpbmVTZWdtZW50cy5nZW9tZXRyeTtcbiAgICB0aGlzLnNldFBvc2l0aW9ucyhnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb21wdXRlQm91bmRpbmdCb3goKSB7XG4gICAgaWYgKHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuYXR0cmlidXRlcy5pbnN0YW5jZVN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuYXR0cmlidXRlcy5pbnN0YW5jZUVuZDtcbiAgICBpZiAoc3RhcnQgIT09IHZvaWQgMCAmJiBlbmQgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHN0YXJ0KTtcbiAgICAgIF9ib3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlbmQpO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC51bmlvbihfYm94KTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuICAgIGlmICh0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSB7XG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmF0dHJpYnV0ZXMuaW5zdGFuY2VTdGFydDtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQ7XG4gICAgaWYgKHN0YXJ0ICE9PSB2b2lkIDAgJiYgZW5kICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIGxldCBtYXhSYWRpdXNTcSA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBzdGFydC5jb3VudDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgX3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKHN0YXJ0LCBpKTtcbiAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKF92ZWN0b3IpKTtcbiAgICAgICAgX3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKGVuZCwgaSk7XG4gICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChfdmVjdG9yKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydChtYXhSYWRpdXNTcSk7XG4gICAgICBpZiAoaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5MaW5lU2VnbWVudHNHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIGluc3RhbmNlZCBwb3NpdGlvbiBkYXRhIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gIH1cbiAgYXBwbHlNYXRyaXgobWF0cml4KSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuTGluZVNlZ21lbnRzR2VvbWV0cnk6IGFwcGx5TWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byBhcHBseU1hdHJpeDQoKS5cIik7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIExpbmVTZWdtZW50c0dlb21ldHJ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZVNlZ21lbnRzR2VvbWV0cnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\n//# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUU7QUFDQSwwQkFBMEIseUNBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsNkJBQTZCLGdEQUFnRDtBQUM3RSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWM7QUFDdkM7QUFDQSw0QkFBNEIsa0RBQWU7QUFDM0M7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFpRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQTBDO0FBQ3pFLFlBQVk7QUFDWjtBQUNBLCtCQUErQixxREFBcUQ7QUFDcEYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbG9hZGVyc1xcRFJBQ09Mb2FkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBfdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBEUkFDT0xvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gXCJcIjtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcbiAgICB0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuICAgIHRoaXMud29ya2VyTGltaXQgPSA0O1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG4gICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBcIlwiO1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIlBPU0lUSU9OXCIsXG4gICAgICBub3JtYWw6IFwiTk9STUFMXCIsXG4gICAgICBjb2xvcjogXCJDT0xPUlwiLFxuICAgICAgdXY6IFwiVEVYX0NPT1JEXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuICAgICAgcG9zaXRpb246IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBub3JtYWw6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBjb2xvcjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIHV2OiBcIkZsb2F0MzJBcnJheVwiXG4gICAgfTtcbiAgfVxuICBzZXREZWNvZGVyUGF0aChwYXRoKSB7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RGVjb2RlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2VyTGltaXQod29ya2VyTGltaXQpIHtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVJRHM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICAgICAgdXNlVW5pcXVlSURzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihvbkxvYWQpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuICBkZWNvZGVEcmFjb0ZpbGUoYnVmZmVyLCBjYWxsYmFjaywgYXR0cmlidXRlSURzLCBhdHRyaWJ1dGVUeXBlcykge1xuICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICBhdHRyaWJ1dGVJRHM6IGF0dHJpYnV0ZUlEcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICBhdHRyaWJ1dGVUeXBlczogYXR0cmlidXRlVHlwZXMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICB1c2VVbmlxdWVJRHM6ICEhYXR0cmlidXRlSURzXG4gICAgfTtcbiAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmICh0eXBlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXNrS2V5ID0gSlNPTi5zdHJpbmdpZnkodGFza0NvbmZpZyk7XG4gICAgaWYgKF90YXNrQ2FjaGUuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldChidWZmZXIpO1xuICAgICAgaWYgKGNhY2hlZFRhc2sua2V5ID09PSB0YXNrS2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUYXNrLnByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd29ya2VyO1xuICAgIGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCsrO1xuICAgIGNvbnN0IHRhc2tDb3N0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpLnRoZW4oKF93b3JrZXIpID0+IHtcbiAgICAgIHdvcmtlciA9IF93b3JrZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG1lc3NhZ2UuZ2VvbWV0cnkpKTtcbiAgICBnZW9tZXRyeVBlbmRpbmcuY2F0Y2goKCkgPT4gdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAod29ya2VyICYmIHRhc2tJRCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3Rhc2tDYWNoZS5zZXQoYnVmZmVyLCB7XG4gICAgICBrZXk6IHRhc2tLZXksXG4gICAgICBwcm9taXNlOiBnZW9tZXRyeVBlbmRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuICB9XG4gIF9jcmVhdGVHZW9tZXRyeShnZW9tZXRyeURhdGEpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeURhdGEuaW5kZXgpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnlEYXRhLmluZGV4LmFycmF5LCAxKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgY29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgX2xvYWRMaWJyYXJ5KHVybCwgcmVzcG9uc2VUeXBlKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKHJlc3BvbnNlVHlwZSk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgcmVzb2x2ZSwgdm9pZCAwLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgdGhpcy5faW5pdERlY29kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdERlY29kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpXG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgICBjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiB8fCB0aGlzLmRlY29kZXJDb25maWcudHlwZSA9PT0gXCJqc1wiO1xuICAgIGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcbiAgICBpZiAodXNlSlMpIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fd2FzbV93cmFwcGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLndhc21cIiwgXCJhcnJheWJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBQcm9taXNlLmFsbChsaWJyYXJpZXNQZW5kaW5nKS50aGVuKChsaWJyYXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1swXTtcbiAgICAgIGlmICghdXNlSlMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnLndhc21CaW5hcnkgPSBsaWJyYXJpZXNbMV07XG4gICAgICB9XG4gICAgICBjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICBcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixcbiAgICAgICAganNDb250ZW50LFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIi8qIHdvcmtlciAqL1wiLFxuICAgICAgICBmbi5zdWJzdHJpbmcoZm4uaW5kZXhPZihcIntcIikgKyAxLCBmbi5sYXN0SW5kZXhPZihcIn1cIikpXG4gICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2JvZHldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gIH1cbiAgX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMud29ya2VyTGltaXQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyMiA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpO1xuICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0Nvc3RzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tMb2FkID0gMDtcbiAgICAgICAgd29ya2VyMi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiaW5pdFwiLCBkZWNvZGVyQ29uZmlnOiB0aGlzLmRlY29kZXJDb25maWcgfSk7XG4gICAgICAgIHdvcmtlcjIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdO1xuICAgICAgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXSA9IHRhc2tDb3N0O1xuICAgICAgd29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSk7XG4gIH1cbiAgX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKSB7XG4gICAgd29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICB9XG4gIGRlYnVnKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJUYXNrIGxvYWQ6IFwiLFxuICAgICAgdGhpcy53b3JrZXJQb29sLm1hcCgod29ya2VyKSA9PiB3b3JrZXIuX3Rhc2tMb2FkKVxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud29ya2VyUG9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy53b3JrZXJQb29sW2ldLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG4gIGxldCBkZWNvZGVyQ29uZmlnO1xuICBsZXQgZGVjb2RlclBlbmRpbmc7XG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICBkZWNvZGVyQ29uZmlnID0gbWVzc2FnZS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBkZWNvZGVyQ29uZmlnLm9uTW9kdWxlTG9hZGVkID0gZnVuY3Rpb24oZHJhY28pIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkcmFjbyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIERyYWNvRGVjb2Rlck1vZHVsZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZXNzYWdlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IG1lc3NhZ2UudGFza0NvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG4gICAgICAgICAgZGVjb2RlckJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gYXR0ci5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4KVxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXJCdWZmZXIpO1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuICAgIGxldCBkcmFjb0dlb21ldHJ5O1xuICAgIGxldCBkZWNvZGluZ1N0YXR1cztcbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBkZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoZGVjb2RlckJ1ZmZlcik7XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6IFwiICsgZGVjb2RpbmdTdGF0dXMuZXJyb3JfbXNnKCkpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdHRyaWJ1dGVJRDtcbiAgICAgIGlmICh0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcykge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVJZChkcmFjb0dlb21ldHJ5LCBkcmFjb1thdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV1dKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZUlEID09PSAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSk7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZ2VvbWV0cnkuaW5kZXggPSBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfVxuICAgIGRyYWNvLmRlc3Ryb3koZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KSB7XG4gICAgY29uc3QgbnVtRmFjZXMgPSBkcmFjb0dlb21ldHJ5Lm51bV9mYWNlcygpO1xuICAgIGNvbnN0IG51bUluZGljZXMgPSBudW1GYWNlcyAqIDM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bUluZGljZXMgKiA0O1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4geyBhcnJheTogaW5kZXgsIGl0ZW1TaXplOiAxIH07XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpO1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlLCBkYXRhVHlwZSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgYXJyYXksXG4gICAgICBpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQ4O1xuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBEUkFDT0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURSQUNPTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name)\n        console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    if (lightDef.color !== void 0)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace\n    );\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n  9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n  9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n  9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n  9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n  9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n  33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n  10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n  STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\")\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = colorSpace;\n        else\n          texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace\n      );\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(\n        three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n\n//# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwOUI7QUFDcDVCO0FBQ2xCO0FBQ0s7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsOENBQVc7QUFDckMscUJBQXFCLDhDQUFXO0FBQ2hDLE1BQU07QUFDTixxQkFBcUIsOENBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDBDQUFPO0FB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LFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFHRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbG9hZGVyc1xcR0xURkxvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIExvYWRlclV0aWxzLCBGaWxlTG9hZGVyLCBDb2xvciwgU3BvdExpZ2h0LCBQb2ludExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIFZlY3RvcjIsIE1hdHJpeDQsIFZlY3RvcjMsIFF1YXRlcm5pb24sIEluc3RhbmNlZE1lc2gsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgT2JqZWN0M0QsIFRleHR1cmVMb2FkZXIsIEltYWdlQml0bWFwTG9hZGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJlcGVhdFdyYXBwaW5nLCBQb2ludHNNYXRlcmlhbCwgTWF0ZXJpYWwsIExpbmVCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSwgUHJvcGVydHlCaW5kaW5nLCBCdWZmZXJHZW9tZXRyeSwgU2tpbm5lZE1lc2gsIE1lc2gsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgTGluZVNlZ21lbnRzLCBMaW5lLCBMaW5lTG9vcCwgUG9pbnRzLCBHcm91cCwgUGVyc3BlY3RpdmVDYW1lcmEsIE1hdGhVdGlscywgT3J0aG9ncmFwaGljQ2FtZXJhLCBTa2VsZXRvbiwgQW5pbWF0aW9uQ2xpcCwgQm9uZSwgSW50ZXJwb2xhdGVMaW5lYXIsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBGcm9udFNpZGUsIFRleHR1cmUsIFZlY3RvcktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBCb3gzLCBTcGhlcmUsIEludGVycG9sYW50IH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB0b1RyaWFuZ2xlc0RyYXdNb2RlIH0gZnJvbSBcIi4uL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlVGV4dCB9IGZyb20gXCIuLi9fcG9seWZpbGwvTG9hZGVyVXRpbHMuanNcIjtcbmNvbnN0IFNSR0JDb2xvclNwYWNlID0gXCJzcmdiXCI7XG5jb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbmNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5jb25zdCBMaW5lYXJFbmNvZGluZyA9IDNlMztcbmNsYXNzIEdMVEZMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRGlzcGVyc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaEdwdUluc3RhbmNpbmcocGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGxldCByZXNvdXJjZVBhdGg7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VQYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGF0aCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgcmVsYXRpdmVVcmwgPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChyZWxhdGl2ZVVybCwgdGhpcy5wYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgIGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NvcGUucGFyc2UoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgZnVuY3Rpb24oZ2x0Zikge1xuICAgICAgICAgICAgICBvbkxvYWQoZ2x0Zik7XG4gICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIF9vbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcikge1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRERFNMb2FkZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJyk7XG4gIH1cbiAgc2V0S1RYMkxvYWRlcihrdHgyTG9hZGVyKSB7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRNZXNob3B0RGVjb2RlcihtZXNob3B0RGVjb2Rlcikge1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2RlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spICE9PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgbGV0IGpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBtYWdpYyA9IGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgaWYgKG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb24gPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoanNvbi5hc3NldCA9PT0gdm9pZCAwIHx8IGpzb24uYXNzZXQudmVyc2lvblswXSA8IDIpIHtcbiAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoanNvbiwge1xuICAgICAgcGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCBcIlwiLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICByZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG4gICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICBrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG4gICAgICBtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuICAgIH0pO1xuICAgIHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1tpXShwYXJzZXIpO1xuICAgICAgaWYgKCFwbHVnaW4ubmFtZSlcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgcGx1Z2luIGZvdW5kOiBtaXNzaW5nIG5hbWVcIik7XG4gICAgICBwbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgIGV4dGVuc2lvbnNbcGx1Z2luLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFtpXTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKGpzb24sIHRoaXMuZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKGV4dGVuc2lvbk5hbWUpID49IDAgJiYgcGx1Z2luc1tleHRlbnNpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBwYXJzZXIuc2V0UGx1Z2lucyhwbHVnaW5zKTtcbiAgICBwYXJzZXIucGFyc2Uob25Mb2FkLCBvbkVycm9yKTtcbiAgfVxuICBwYXJzZUFzeW5jKGRhdGEsIHBhdGgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2NvcGUucGFyc2UoZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuICBsZXQgb2JqZWN0cyA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXksIG9iamVjdCkge1xuICAgICAgb2JqZWN0c1trZXldID0gb2JqZWN0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgb2JqZWN0cyA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gIEtIUl9CSU5BUllfR0xURjogXCJLSFJfYmluYXJ5X2dsVEZcIixcbiAgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046IFwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixcbiAgS0hSX0xJR0hUU19QVU5DVFVBTDogXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCIsXG4gIEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiBcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsXG4gIEtIUl9NQVRFUklBTFNfRElTUEVSU0lPTjogXCJLSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb25cIixcbiAgS0hSX01BVEVSSUFMU19JT1I6IFwiS0hSX21hdGVyaWFsc19pb3JcIixcbiAgS0hSX01BVEVSSUFMU19TSEVFTjogXCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCIsXG4gIEtIUl9NQVRFUklBTFNfU1BFQ1VMQVI6IFwiS0hSX21hdGVyaWFsc19zcGVjdWxhclwiLFxuICBLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogXCJLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFOiBcIktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIixcbiAgS0hSX01BVEVSSUFMU19BTklTT1RST1BZOiBcIktIUl9tYXRlcmlhbHNfYW5pc290cm9weVwiLFxuICBLSFJfTUFURVJJQUxTX1VOTElUOiBcIktIUl9tYXRlcmlhbHNfdW5saXRcIixcbiAgS0hSX01BVEVSSUFMU19WT0xVTUU6IFwiS0hSX21hdGVyaWFsc192b2x1bWVcIixcbiAgS0hSX1RFWFRVUkVfQkFTSVNVOiBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLFxuICBLSFJfVEVYVFVSRV9UUkFOU0ZPUk06IFwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsXG4gIEtIUl9NRVNIX1FVQU5USVpBVElPTjogXCJLSFJfbWVzaF9xdWFudGl6YXRpb25cIixcbiAgS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDogXCJLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoXCIsXG4gIEVYVF9NQVRFUklBTFNfQlVNUDogXCJFWFRfbWF0ZXJpYWxzX2J1bXBcIixcbiAgRVhUX1RFWFRVUkVfV0VCUDogXCJFWFRfdGV4dHVyZV93ZWJwXCIsXG4gIEVYVF9URVhUVVJFX0FWSUY6IFwiRVhUX3RleHR1cmVfYXZpZlwiLFxuICBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiLFxuICBFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORzogXCJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiXG59O1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcbiAgICB0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgfVxuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZXIuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbG9hZExpZ2h0KGxpZ2h0SW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwibGlnaHQ6XCIgKyBsaWdodEluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGRlcGVuZGVuY3kpXG4gICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcbiAgICBjb25zdCBsaWdodERlZiA9IGxpZ2h0RGVmc1tsaWdodEluZGV4XTtcbiAgICBsZXQgbGlnaHROb2RlO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICBpZiAobGlnaHREZWYuY29sb3IgIT09IHZvaWQgMClcbiAgICAgIGNvbG9yLnNldFJHQihsaWdodERlZi5jb2xvclswXSwgbGlnaHREZWYuY29sb3JbMV0sIGxpZ2h0RGVmLmNvbG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgY29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdm9pZCAwID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuICAgIHN3aXRjaCAobGlnaHREZWYudHlwZSkge1xuICAgICAgY2FzZSBcImRpcmVjdGlvbmFsXCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgbGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNDtcbiAgICAgICAgbGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnBlbnVtYnJhID0gMSAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiBcIiArIGxpZ2h0RGVmLnR5cGUpO1xuICAgIH1cbiAgICBsaWdodE5vZGUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShsaWdodE5vZGUsIGxpZ2h0RGVmKTtcbiAgICBpZiAobGlnaHREZWYuaW50ZW5zaXR5ICE9PSB2b2lkIDApXG4gICAgICBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuICAgIGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobGlnaHREZWYubmFtZSB8fCBcImxpZ2h0X1wiICsgbGlnaHRJbmRleCk7XG4gICAgZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZShsaWdodE5vZGUpO1xuICAgIHBhcnNlci5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZSAhPT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQoaW5kZXgpO1xuICB9XG4gIGNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsaWdodERlZiA9IG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG4gICAgaWYgKGxpZ2h0SW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQobGlnaHRJbmRleCkudGhlbihmdW5jdGlvbihsaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihzZWxmMi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZW1pc3NpdmVTdHJlbmd0aCA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5lbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIGlmIChlbWlzc2l2ZVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlSW50ZW5zaXR5ID0gZW1pc3NpdmVTdHJlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdFJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE5vcm1hbE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSkpO1xuICAgICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMihzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0RJU1BFUlNJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5kaXNwZXJzaW9uID0gZXh0ZW5zaW9uLmRpc3BlcnNpb24gIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5kaXNwZXJzaW9uIDogMDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlSU9SID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWzEwMCwgNDAwXTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TSEVFTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSAwO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuID0gMTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGNvbG9yRmFjdG9yID0gZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3I7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLnNldFJHQihjb2xvckZhY3RvclswXSwgY29sb3JGYWN0b3JbMV0sIGNvbG9yRmFjdG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Sb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidHJhbnNtaXNzaW9uTWFwXCIsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMudGhpY2tuZXNzID0gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciA6IDA7XG4gICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0aGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkRpc3RhbmNlIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcigpLnNldFJHQihcbiAgICAgIGNvbG9yQXJyYXlbMF0sXG4gICAgICBjb2xvckFycmF5WzFdLFxuICAgICAgY29sb3JBcnJheVsyXSxcbiAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSU9SO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TUEVDVUxBUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJJbnRlbnNpdHlNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRSR0IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUFURVJJQUxTX0JVTVA7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYnVtcFNjYWxlID0gZXh0ZW5zaW9uLmJ1bXBGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5idW1wRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJidW1wTWFwXCIsIGV4dGVuc2lvbi5idW1wVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weSA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGg7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb247XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFuaXNvdHJvcHlNYXBcIiwgZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfV0VCUDtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBXCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfQVZJRjtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEFWSUYgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBsb2FkQnVmZmVyVmlldyhpbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzW2luZGV4XTtcbiAgICBpZiAoYnVmZmVyVmlldy5leHRlbnNpb25zICYmIGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgZXh0ZW5zaW9uRGVmLmJ1ZmZlcik7XG4gICAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtcbiAgICAgIGlmICghZGVjb2RlciB8fCAhZGVjb2Rlci5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuICAgICAgICBjb25zdCBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkocmVzLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIpLnRoZW4oZnVuY3Rpb24ocmVzMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlczIuYnVmZmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLnJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoY291bnQgKiBzdHJpZGUpO1xuICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLFxuICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5tb2RlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYuZmlsdGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURk1lc2hHcHVJbnN0YW5jaW5nIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSF9HUFVfSU5TVEFOQ0lORztcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmICghbm9kZURlZi5leHRlbnNpb25zIHx8ICFub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCBub2RlRGVmLm1lc2ggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1tub2RlRGVmLm1lc2hdO1xuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIG1lc2hEZWYucHJpbWl0aXZlcykge1xuICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gJiYgcHJpbWl0aXZlLm1vZGUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgYXR0cmlidXRlc0RlZiA9IGV4dGVuc2lvbkRlZi5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlc0RlZikge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYXR0cmlidXRlc0RlZltrZXldKS50aGVuKChhY2Nlc3NvcikgPT4ge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFjY2Vzc29yO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHRoaXMucGFyc2VyLmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICBjb25zdCBub2RlT2JqZWN0ID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IG5vZGVPYmplY3QuaXNHcm91cCA/IG5vZGVPYmplY3QuY2hpbGRyZW4gOiBbbm9kZU9iamVjdF07XG4gICAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF0uY291bnQ7XG4gICAgICBjb25zdCBpbnN0YW5jZWRNZXNoZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gbmV3IEluc3RhbmNlZE1lc2gobWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRlcmlhbCwgY291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5UUkFOU0xBVElPTikge1xuICAgICAgICAgICAgcC5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5ST1RBVElPTikge1xuICAgICAgICAgICAgcS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuUk9UQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TQ0FMRSkge1xuICAgICAgICAgICAgcy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuU0NBTEUsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGksIG0uY29tcG9zZShwLCBxLCBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJfQ09MT1JfMFwiKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoYXR0ci5hcnJheSwgYXR0ci5pdGVtU2l6ZSwgYXR0ci5ub3JtYWxpemVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgIT09IFwiVFJBTlNMQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlJPVEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJTQ0FMRVwiKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbChpbnN0YW5jZWRNZXNoLCBtZXNoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChpbnN0YW5jZWRNZXNoKTtcbiAgICAgICAgaW5zdGFuY2VkTWVzaGVzLnB1c2goaW5zdGFuY2VkTWVzaCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZU9iamVjdC5pc0dyb3VwKSB7XG4gICAgICAgIG5vZGVPYmplY3QuY2xlYXIoKTtcbiAgICAgICAgbm9kZU9iamVjdC5hZGQoLi4uaW5zdGFuY2VkTWVzaGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VkTWVzaGVzWzBdO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9IFwiZ2xURlwiO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAxMzEzODIxNTE0LCBCSU46IDUxMzA1NjIgfTtcbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIGNvbnN0IGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICB0aGlzLmhlYWRlciA9IHtcbiAgICAgIG1hZ2ljOiBkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKSxcbiAgICAgIHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKDQsIHRydWUpLFxuICAgICAgbGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMig4LCB0cnVlKVxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuICAgIGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICB3aGlsZSAoY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04pIHtcbiAgICAgICAgY29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkZWNvZGVUZXh0KGNvbnRlbnRBcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4pIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG4gICAgICAgIHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoanNvbiwgZHJhY29Mb2FkZXIpIHtcbiAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgdGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG4gIH1cbiAgZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG4gICAgY29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3O1xuICAgIGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRocmVlQXR0cmlidXRlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgYXR0cmlidXRlVHlwZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gY29tcG9uZW50VHlwZS5uYW1lO1xuICAgICAgICBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGJ1ZmZlclZpZXdJbmRleCkudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRyYWNvTG9hZGVyLmRlY29kZURyYWNvRmlsZShcbiAgICAgICAgICBidWZmZXJWaWV3LFxuICAgICAgICAgIGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGdlb21ldHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocmVlQXR0cmlidXRlTWFwLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVNYXAsXG4gICAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcbiAgfVxuICBleHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgIGlmICgodHJhbnNmb3JtLnRleENvb3JkID09PSB2b2lkIDAgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwpICYmIHRyYW5zZm9ybS5vZmZzZXQgPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgaWYgKHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLmNoYW5uZWwgPSB0cmFuc2Zvcm0udGV4Q29vcmQ7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSh0cmFuc2Zvcm0ub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSh0cmFuc2Zvcm0uc2NhbGUpO1xuICAgIH1cbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcbiAgfVxufVxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuICBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLCB2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSwgb2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG4gICAgY29uc3QgdGQgPSB0MSAtIHQwO1xuICAgIGNvbnN0IHAgPSAodCAtIHQwKSAvIHRkO1xuICAgIGNvbnN0IHBwID0gcCAqIHA7XG4gICAgY29uc3QgcHBwID0gcHAgKiBwO1xuICAgIGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuICAgIGNvbnN0IHMyID0gLTIgKiBwcHAgKyAzICogcHA7XG4gICAgY29uc3QgczMgPSBwcHAgLSBwcDtcbiAgICBjb25zdCBzMCA9IDEgLSBzMjtcbiAgICBjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkrKykge1xuICAgICAgY29uc3QgcDAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGUyXSAqIHRkO1xuICAgICAgY29uc3QgcDEgPSB2YWx1ZXNbb2Zmc2V0MSArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTEgPSB2YWx1ZXNbb2Zmc2V0MSArIGldICogdGQ7XG4gICAgICByZXN1bHRbaV0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBfcSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUXVhdGVybmlvbigpO1xuY2xhc3MgR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IGV4dGVuZHMgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQge1xuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKTtcbiAgICBfcS5mcm9tQXJyYXkocmVzdWx0KS5ub3JtYWxpemUoKS50b0FycmF5KHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgV0VCR0xfQ09OU1RBTlRTID0ge1xuICBGTE9BVDogNTEyNixcbiAgLy9GTE9BVF9NQVQyOiAzNTY3NCxcbiAgRkxPQVRfTUFUMzogMzU2NzUsXG4gIEZMT0FUX01BVDQ6IDM1Njc2LFxuICBGTE9BVF9WRUMyOiAzNTY2NCxcbiAgRkxPQVRfVkVDMzogMzU2NjUsXG4gIEZMT0FUX1ZFQzQ6IDM1NjY2LFxuICBMSU5FQVI6IDk3MjksXG4gIFJFUEVBVDogMTA0OTcsXG4gIFNBTVBMRVJfMkQ6IDM1Njc4LFxuICBQT0lOVFM6IDAsXG4gIExJTkVTOiAxLFxuICBMSU5FX0xPT1A6IDIsXG4gIExJTkVfU1RSSVA6IDMsXG4gIFRSSUFOR0xFUzogNCxcbiAgVFJJQU5HTEVfU1RSSVA6IDUsXG4gIFRSSUFOR0xFX0ZBTjogNixcbiAgVU5TSUdORURfQllURTogNTEyMSxcbiAgVU5TSUdORURfU0hPUlQ6IDUxMjNcbn07XG5jb25zdCBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG4gIDUxMjA6IEludDhBcnJheSxcbiAgNTEyMTogVWludDhBcnJheSxcbiAgNTEyMjogSW50MTZBcnJheSxcbiAgNTEyMzogVWludDE2QXJyYXksXG4gIDUxMjU6IFVpbnQzMkFycmF5LFxuICA1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5jb25zdCBXRUJHTF9GSUxURVJTID0ge1xuICA5NzI4OiBOZWFyZXN0RmlsdGVyLFxuICA5NzI5OiBMaW5lYXJGaWx0ZXIsXG4gIDk5ODQ6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg1OiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg2OiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuICA5OTg3OiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5jb25zdCBXRUJHTF9XUkFQUElOR1MgPSB7XG4gIDMzMDcxOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAzMzY0ODogTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcbiAgMTA0OTc6IFJlcGVhdFdyYXBwaW5nXG59O1xuY29uc3QgV0VCR0xfVFlQRV9TSVpFUyA9IHtcbiAgU0NBTEFSOiAxLFxuICBWRUMyOiAyLFxuICBWRUMzOiAzLFxuICBWRUM0OiA0LFxuICBNQVQyOiA0LFxuICBNQVQzOiA5LFxuICBNQVQ0OiAxNlxufTtcbmNvbnN0IEFUVFJJQlVURVMgPSB7XG4gIFBPU0lUSU9OOiBcInBvc2l0aW9uXCIsXG4gIE5PUk1BTDogXCJub3JtYWxcIixcbiAgVEFOR0VOVDogXCJ0YW5nZW50XCIsXG4gIC8vIHV2ID0+IHV2MSwgNCB1diBjaGFubmVsc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU5NDNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1Nzg4XG4gIC4uLnZlcnNpb24gPj0gMTUyID8ge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MVwiLFxuICAgIFRFWENPT1JEXzI6IFwidXYyXCIsXG4gICAgVEVYQ09PUkRfMzogXCJ1djNcIlxuICB9IDoge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MlwiXG4gIH0sXG4gIENPTE9SXzA6IFwiY29sb3JcIixcbiAgV0VJR0hUU18wOiBcInNraW5XZWlnaHRcIixcbiAgSk9JTlRTXzA6IFwic2tpbkluZGV4XCJcbn07XG5jb25zdCBQQVRIX1BST1BFUlRJRVMgPSB7XG4gIHNjYWxlOiBcInNjYWxlXCIsXG4gIHRyYW5zbGF0aW9uOiBcInBvc2l0aW9uXCIsXG4gIHJvdGF0aW9uOiBcInF1YXRlcm5pb25cIixcbiAgd2VpZ2h0czogXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIlxufTtcbmNvbnN0IElOVEVSUE9MQVRJT04gPSB7XG4gIENVQklDU1BMSU5FOiB2b2lkIDAsXG4gIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cbiAgTElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcbiAgU1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxufTtcbmNvbnN0IEFMUEhBX01PREVTID0ge1xuICBPUEFRVUU6IFwiT1BBUVVFXCIsXG4gIE1BU0s6IFwiTUFTS1wiLFxuICBCTEVORDogXCJCTEVORFwiXG59O1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKGNhY2hlKSB7XG4gIGlmIChjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9PT0gdm9pZCAwKSB7XG4gICAgY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl0gPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgZW1pc3NpdmU6IDAsXG4gICAgICBtZXRhbG5lc3M6IDEsXG4gICAgICByb3VnaG5lc3M6IDEsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgICBzaWRlOiBGcm9udFNpZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl07XG59XG5mdW5jdGlvbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoa25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZikge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqZWN0RGVmLmV4dGVuc2lvbnMpIHtcbiAgICBpZiAoa25vd25FeHRlbnNpb25zW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyA9IG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyB8fCB7fTtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc1tuYW1lXSA9IG9iamVjdERlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShvYmplY3QsIGdsdGZEZWYpIHtcbiAgaWYgKGdsdGZEZWYuZXh0cmFzICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIGdsdGZEZWYuZXh0cmFzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9iamVjdC51c2VyRGF0YSwgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCBcIiArIGdsdGZEZWYuZXh0cmFzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgdGFyZ2V0cywgcGFyc2VyKSB7XG4gIGxldCBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaE5vcm1hbCA9IGZhbHNlO1xuICBsZXQgaGFzTW9ycGhDb2xvciA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuICAgIGlmICh0YXJnZXQuTk9STUFMICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaENvbG9yID0gdHJ1ZTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCAmJiBoYXNNb3JwaENvbG9yKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKCFoYXNNb3JwaFBvc2l0aW9uICYmICFoYXNNb3JwaE5vcm1hbCAmJiAhaGFzTW9ycGhDb2xvcilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdlb21ldHJ5KTtcbiAgY29uc3QgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG4gIGNvbnN0IHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ0NvbG9yQWNjZXNzb3JzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuUE9TSVRJT04pIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaE5vcm1hbCkge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0Lk5PUk1BTCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuTk9STUFMKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICAgICAgcGVuZGluZ05vcm1hbEFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaENvbG9yKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuQ09MT1JfMCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuQ09MT1JfMCkgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgcGVuZGluZ0NvbG9yQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdDb2xvckFjY2Vzc29ycylcbiAgXSkudGhlbihmdW5jdGlvbihhY2Nlc3NvcnMpIHtcbiAgICBjb25zdCBtb3JwaFBvc2l0aW9ucyA9IGFjY2Vzc29yc1swXTtcbiAgICBjb25zdCBtb3JwaE5vcm1hbHMgPSBhY2Nlc3NvcnNbMV07XG4gICAgY29uc3QgbW9ycGhDb2xvcnMgPSBhY2Nlc3NvcnNbMl07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcbiAgICBpZiAoaGFzTW9ycGhOb3JtYWwpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuICAgIGlmIChoYXNNb3JwaENvbG9yKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yID0gbW9ycGhDb2xvcnM7XG4gICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZikge1xuICBtZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuICBpZiAobWVzaERlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBtZXNoRGVmLndlaWdodHNbaV07XG4gICAgfVxuICB9XG4gIGlmIChtZXNoRGVmLmV4dHJhcyAmJiBBcnJheS5pc0FycmF5KG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzKSkge1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXM7XG4gICAgaWYgKG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVt0YXJnZXROYW1lc1tpXV0gPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIGV4dHJhcy50YXJnZXROYW1lcyBsZW5ndGguIElnbm9yaW5nIG5hbWVzLlwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmVEZWYpIHtcbiAgbGV0IGdlb21ldHJ5S2V5O1xuICBjb25zdCBkcmFjb0V4dGVuc2lvbiA9IHByaW1pdGl2ZURlZi5leHRlbnNpb25zICYmIHByaW1pdGl2ZURlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dO1xuICBpZiAoZHJhY29FeHRlbnNpb24pIHtcbiAgICBnZW9tZXRyeUtleSA9IFwiZHJhY286XCIgKyBkcmFjb0V4dGVuc2lvbi5idWZmZXJWaWV3ICsgXCI6XCIgKyBkcmFjb0V4dGVuc2lvbi5pbmRpY2VzICsgXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KGRyYWNvRXh0ZW5zaW9uLmF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkocHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXMpICsgXCI6XCIgKyBwcmltaXRpdmVEZWYubW9kZTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZURlZi50YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5S2V5ICs9IFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYudGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9tZXRyeUtleTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoYXR0cmlidXRlcykge1xuICBsZXQgYXR0cmlidXRlc0tleSA9IFwiXCI7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb3J0KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGF0dHJpYnV0ZXNLZXkgKz0ga2V5c1tpXSArIFwiOlwiICsgYXR0cmlidXRlc1trZXlzW2ldXSArIFwiO1wiO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzS2V5O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKGNvbnN0cnVjdG9yKSB7XG4gIHN3aXRjaCAoY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMTI3O1xuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMjU1O1xuICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMzI3Njc7XG4gICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gNjU1MzU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG5vcm1hbGl6ZWQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVVSSU1pbWVUeXBlKHVyaSkge1xuICBpZiAodXJpLnNlYXJjaCgvXFwuanBlP2coJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvanBlZy8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL2pwZWdcIjtcbiAgaWYgKHVyaS5zZWFyY2goL1xcLndlYnAoJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvd2VicC8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL3dlYnBcIjtcbiAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG59XG5jb25zdCBfaWRlbnRpdHlNYXRyaXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQoKTtcbmNsYXNzIEdMVEZQYXJzZXIge1xuICBjb25zdHJ1Y3Rvcihqc29uID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNhY2hlID0gbmV3IEdMVEZSZWdpc3RyeSgpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByaW1pdGl2ZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm1lc2hDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5jYW1lcmFDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5saWdodENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlID0ge307XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVOYW1lc1VzZWQgPSB7fTtcbiAgICBsZXQgaXNTYWZhcmkgPSBmYWxzZTtcbiAgICBsZXQgaXNGaXJlZm94ID0gZmFsc2U7XG4gICAgbGV0IGZpcmVmb3hWZXJzaW9uID0gLTE7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA9PT0gdHJ1ZTtcbiAgICAgIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMTtcbiAgICAgIGZpcmVmb3hWZXJzaW9uID0gaXNGaXJlZm94ID8gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyhbMC05XSspXFwuLylbMV0gOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc1NhZmFyaSB8fCBpc0ZpcmVmb3ggJiYgZmlyZWZveFZlcnNpb24gPCA5OCkge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgSW1hZ2VCaXRtYXBMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICB0aGlzLnRleHR1cmVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLm9wdGlvbnMucmVxdWVzdEhlYWRlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSBcInVzZS1jcmVkZW50aWFsc1wiKSB7XG4gICAgICB0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRydWUpO1xuICAgIH1cbiAgfVxuICBzZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICB9XG4gIHNldFBsdWdpbnMocGx1Z2lucykge1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG4gIH1cbiAgcGFyc2Uob25Mb2FkLCBvbkVycm9yKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgdGhpcy5jYWNoZS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuX21hcmtEZWZzICYmIGV4dC5fbWFya0RlZnMoKTtcbiAgICB9KTtcbiAgICBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5iZWZvcmVSb290ICYmIGV4dC5iZWZvcmVSb290KCk7XG4gICAgICB9KVxuICAgICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJzY2VuZVwiKSxcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcImFuaW1hdGlvblwiKSxcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcImNhbWVyYVwiKVxuICAgICAgXSk7XG4gICAgfSkudGhlbihmdW5jdGlvbihkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2NlbmU6IGRlcGVuZGVuY2llc1swXVtqc29uLnNjZW5lIHx8IDBdLFxuICAgICAgICBzY2VuZXM6IGRlcGVuZGVuY2llc1swXSxcbiAgICAgICAgYW5pbWF0aW9uczogZGVwZW5kZW5jaWVzWzFdLFxuICAgICAgICBjYW1lcmFzOiBkZXBlbmRlbmNpZXNbMl0sXG4gICAgICAgIGFzc2V0OiBqc29uLmFzc2V0LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHVzZXJEYXRhOiB7fVxuICAgICAgfTtcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCByZXN1bHQsIGpzb24pO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShyZXN1bHQsIGpzb24pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KHJlc3VsdCk7XG4gICAgICAgIH0pXG4gICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgcmVzdWx0LnNjZW5lcykge1xuICAgICAgICAgIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChvbkVycm9yKTtcbiAgfVxuICAvKipcbiAgICogTWFya3MgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZS5cbiAgICovXG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMuanNvbi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBza2luRGVmcyA9IHRoaXMuanNvbi5za2lucyB8fCBbXTtcbiAgICBjb25zdCBtZXNoRGVmcyA9IHRoaXMuanNvbi5tZXNoZXMgfHwgW107XG4gICAgZm9yIChsZXQgc2tpbkluZGV4ID0gMCwgc2tpbkxlbmd0aCA9IHNraW5EZWZzLmxlbmd0aDsgc2tpbkluZGV4IDwgc2tpbkxlbmd0aDsgc2tpbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvaW50cyA9IHNraW5EZWZzW3NraW5JbmRleF0uam9pbnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZURlZnNbam9pbnRzW2ldXS5pc0JvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzW25vZGVJbmRleF07XG4gICAgICBpZiAobm9kZURlZi5tZXNoICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlZih0aGlzLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoKTtcbiAgICAgICAgaWYgKG5vZGVEZWYuc2tpbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaERlZnNbbm9kZURlZi5tZXNoXS5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlZih0aGlzLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb3VudHMgcmVmZXJlbmNlcyB0byBzaGFyZWQgbm9kZSAvIE9iamVjdDNEIHJlc291cmNlcy4gVGhlc2UgcmVzb3VyY2VzXG4gICAqIGNhbiBiZSByZXVzZWQsIG9yIFwiaW5zdGFudGlhdGVkXCIsIGF0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBzY2VuZVxuICAgKiBoaWVyYXJjaHkuIE1lc2gsIENhbWVyYSwgYW5kIExpZ2h0IGluc3RhbmNlcyBhcmUgaW5zdGFudGlhdGVkIGFuZCBtdXN0XG4gICAqIGJlIG1hcmtlZC4gTm9uLXNjZW5lZ3JhcGggcmVzb3VyY2VzIChsaWtlIE1hdGVyaWFscywgR2VvbWV0cmllcywgYW5kXG4gICAqIFRleHR1cmVzKSBjYW4gYmUgcmV1c2VkIGRpcmVjdGx5IGFuZCBhcmUgbm90IG1hcmtlZCBoZXJlLlxuICAgKlxuICAgKiBFeGFtcGxlOiBDZXNpdW1NaWxrVHJ1Y2sgc2FtcGxlIG1vZGVsIHJldXNlcyBcIldoZWVsXCIgbWVzaGVzLlxuICAgKi9cbiAgX2FkZE5vZGVSZWYoY2FjaGUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdID09PSB2b2lkIDApIHtcbiAgICAgIGNhY2hlLnJlZnNbaW5kZXhdID0gY2FjaGUudXNlc1tpbmRleF0gPSAwO1xuICAgIH1cbiAgICBjYWNoZS5yZWZzW2luZGV4XSsrO1xuICB9XG4gIC8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGEgc2hhcmVkIHJlc291cmNlLCBjbG9uaW5nIGl0IGlmIG5lY2Vzc2FyeS4gKi9cbiAgX2dldE5vZGVSZWYoY2FjaGUsIGluZGV4LCBvYmplY3QpIHtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPD0gMSlcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgY29uc3QgcmVmID0gb2JqZWN0LmNsb25lKCk7XG4gICAgY29uc3QgdXBkYXRlTWFwcGluZ3MgPSAob3JpZ2luYWwsIGNsb25lKSA9PiB7XG4gICAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuYXNzb2NpYXRpb25zLmdldChvcmlnaW5hbCk7XG4gICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2xvbmUsIG1hcHBpbmdzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2ksIGNoaWxkXSBvZiBvcmlnaW5hbC5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgdXBkYXRlTWFwcGluZ3MoY2hpbGQsIGNsb25lLmNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZU1hcHBpbmdzKG9iamVjdCwgcmVmKTtcbiAgICByZWYubmFtZSArPSBcIl9pbnN0YW5jZV9cIiArIGNhY2hlLnVzZXNbaW5kZXhdKys7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuICBfaW52b2tlT25lKGZ1bmMpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO1xuICAgIGV4dGVuc2lvbnMucHVzaCh0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaW52b2tlQWxsKGZ1bmMpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO1xuICAgIGV4dGVuc2lvbnMudW5zaGlmdCh0aGlzKTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcGVuZGluZy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgc3BlY2lmaWVkIGRlcGVuZGVuY3kgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0R8TWF0ZXJpYWx8VEhSRUUuVGV4dHVyZXxBbmltYXRpb25DbGlwfEFycmF5QnVmZmVyfE9iamVjdD59XG4gICAqL1xuICBnZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSB0eXBlICsgXCI6XCIgKyBpbmRleDtcbiAgICBsZXQgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic2NlbmVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2NlbmUoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWROb2RlICYmIGV4dC5sb2FkTm9kZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXNoXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1lc2ggJiYgZXh0LmxvYWRNZXNoKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFjY2Vzc29yXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFjY2Vzc29yKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclZpZXdcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQnVmZmVyVmlldyAmJiBleHQubG9hZEJ1ZmZlclZpZXcoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZEJ1ZmZlcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXRlcmlhbFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNYXRlcmlhbCAmJiBleHQubG9hZE1hdGVyaWFsKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHR1cmVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkVGV4dHVyZSAmJiBleHQubG9hZFRleHR1cmUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2tpblwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTa2luKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFuaW1hdGlvblwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRBbmltYXRpb24gJiYgZXh0LmxvYWRBbmltYXRpb24oaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FtZXJhXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZENhbWVyYShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQgIT0gdGhpcyAmJiBleHQuZ2V0RGVwZW5kZW5jeSAmJiBleHQuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY2llcyh0eXBlKSB7XG4gICAgbGV0IGRlcGVuZGVuY2llcyA9IHRoaXMuY2FjaGUuZ2V0KHR5cGUpO1xuICAgIGlmICghZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZGVmcyA9IHRoaXMuanNvblt0eXBlICsgKHR5cGUgPT09IFwibWVzaFwiID8gXCJlc1wiIDogXCJzXCIpXSB8fCBbXTtcbiAgICAgIGRlcGVuZGVuY2llcyA9IFByb21pc2UuYWxsKFxuICAgICAgICBkZWZzLm1hcChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLmNhY2hlLmFkZCh0eXBlLCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyKGJ1ZmZlckluZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyRGVmID0gdGhpcy5qc29uLmJ1ZmZlcnNbYnVmZmVySW5kZXhdO1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZmlsZUxvYWRlcjtcbiAgICBpZiAoYnVmZmVyRGVmLnR5cGUgJiYgYnVmZmVyRGVmLnR5cGUgIT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogXCIgKyBidWZmZXJEZWYudHlwZSArIFwiIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyRGVmLnVyaSA9PT0gdm9pZCAwICYmIGJ1ZmZlckluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uYm9keSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGgpLCByZXNvbHZlLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXJWaWV3KGJ1ZmZlclZpZXdJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdEZWYgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbYnVmZmVyVmlld0luZGV4XTtcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyXCIsIGJ1ZmZlclZpZXdEZWYuYnVmZmVyKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZUxlbmd0aCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYWNjZXNzb3JzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY2Nlc3NvckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyQXR0cmlidXRlfEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlPn1cbiAgICovXG4gIGxvYWRBY2Nlc3NvcihhY2Nlc3NvckluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGFjY2Vzc29yRGVmID0gdGhpcy5qc29uLmFjY2Vzc29yc1thY2Nlc3NvckluZGV4XTtcbiAgICBpZiAoYWNjZXNzb3JEZWYuYnVmZmVyVmlldyA9PT0gdm9pZCAwICYmIGFjY2Vzc29yRGVmLnNwYXJzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbYWNjZXNzb3JEZWYudHlwZV07XG4gICAgICBjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nQnVmZmVyVmlld3MgPSBbXTtcbiAgICBpZiAoYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3KSk7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnVmZmVyVmlldykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZ0J1ZmZlclZpZXdzKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXdzKSB7XG4gICAgICBjb25zdCBidWZmZXJWaWV3ID0gYnVmZmVyVmlld3NbMF07XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbYWNjZXNzb3JEZWYudHlwZV07XG4gICAgICBjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3QgZWxlbWVudEJ5dGVzID0gVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGFjY2Vzc29yRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVTdHJpZGUgPSBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDAgPyBqc29uLmJ1ZmZlclZpZXdzW2FjY2Vzc29yRGVmLmJ1ZmZlclZpZXddLmJ5dGVTdHJpZGUgOiB2b2lkIDA7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGxldCBhcnJheSwgYnVmZmVyQXR0cmlidXRlO1xuICAgICAgaWYgKGJ5dGVTdHJpZGUgJiYgYnl0ZVN0cmlkZSAhPT0gaXRlbUJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGliU2xpY2UgPSBNYXRoLmZsb29yKGJ5dGVPZmZzZXQgLyBieXRlU3RyaWRlKTtcbiAgICAgICAgY29uc3QgaWJDYWNoZUtleSA9IFwiSW50ZXJsZWF2ZWRCdWZmZXI6XCIgKyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICsgXCI6XCIgKyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlICsgXCI6XCIgKyBpYlNsaWNlICsgXCI6XCIgKyBhY2Nlc3NvckRlZi5jb3VudDtcbiAgICAgICAgbGV0IGliID0gcGFyc2VyLmNhY2hlLmdldChpYkNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFpYikge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgaWJTbGljZSAqIGJ5dGVTdHJpZGUsIGFjY2Vzc29yRGVmLmNvdW50ICogYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgaWIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIoYXJyYXksIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIHBhcnNlci5jYWNoZS5hZGQoaWJDYWNoZUtleSwgaWIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICBpYixcbiAgICAgICAgICBpdGVtU2l6ZSxcbiAgICAgICAgICBieXRlT2Zmc2V0ICUgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyxcbiAgICAgICAgICBub3JtYWxpemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVyVmlldyA9PT0gbnVsbCkge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBieXRlT2Zmc2V0LCBhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgaXRlbVNpemVJbmRpY2VzID0gV0VCR0xfVFlQRV9TSVpFUy5TQ0FMQVI7XG4gICAgICAgIGNvbnN0IFR5cGVkQXJyYXlJbmRpY2VzID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmNvbXBvbmVudFR5cGVdO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0SW5kaWNlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldFZhbHVlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBzcGFyc2VJbmRpY2VzID0gbmV3IFR5cGVkQXJyYXlJbmRpY2VzKFxuICAgICAgICAgIGJ1ZmZlclZpZXdzWzFdLFxuICAgICAgICAgIGJ5dGVPZmZzZXRJbmRpY2VzLFxuICAgICAgICAgIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBzcGFyc2VWYWx1ZXMgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3c1syXSwgYnl0ZU9mZnNldFZhbHVlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICBpZiAoYnVmZmVyVmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSxcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSxcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBzcGFyc2VJbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHNwYXJzZUluZGljZXNbaV07XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFgoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemVdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMilcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRZKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAzKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFooaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAyXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDQpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0VyhpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDNdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyQXR0cmlidXRlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjdGV4dHVyZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLlRleHR1cmV8bnVsbD59XG4gICAqL1xuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VJbmRleCA9IHRleHR1cmVEZWYuc291cmNlO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2VEZWYudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gb3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlRGVmLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpO1xuICB9XG4gIGxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gKHNvdXJjZURlZi51cmkgfHwgc291cmNlRGVmLmJ1ZmZlclZpZXcpICsgXCI6XCIgKyB0ZXh0dXJlRGVmLnNhbXBsZXI7XG4gICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubG9hZEltYWdlU291cmNlKHNvdXJjZUluZGV4LCBsb2FkZXIpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgdGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGV4dHVyZS5uYW1lID0gdGV4dHVyZURlZi5uYW1lIHx8IHNvdXJjZURlZi5uYW1lIHx8IFwiXCI7XG4gICAgICBpZiAodGV4dHVyZS5uYW1lID09PSBcIlwiICYmIHR5cGVvZiBzb3VyY2VEZWYudXJpID09PSBcInN0cmluZ1wiICYmIHNvdXJjZURlZi51cmkuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvXCIpID09PSBmYWxzZSkge1xuICAgICAgICB0ZXh0dXJlLm5hbWUgPSBzb3VyY2VEZWYudXJpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBqc29uLnNhbXBsZXJzIHx8IHt9O1xuICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW3RleHR1cmVEZWYuc2FtcGxlcl0gfHwge307XG4gICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5tYWdGaWx0ZXJdIHx8IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1pbkZpbHRlcl0gfHwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS53cmFwUyA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBTXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHRleHR1cmUud3JhcFQgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwVF0gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCB7IHRleHR1cmVzOiB0ZXh0dXJlSW5kZXggfSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgbG9hZEltYWdlU291cmNlKHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdLnRoZW4oKHRleHR1cmUpID0+IHRleHR1cmUuY2xvbmUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcbiAgICBsZXQgc291cmNlVVJJID0gc291cmNlRGVmLnVyaSB8fCBcIlwiO1xuICAgIGxldCBpc09iamVjdFVSTCA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICBzb3VyY2VVUkkgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgc291cmNlRGVmLmJ1ZmZlclZpZXcpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlldykge1xuICAgICAgICBpc09iamVjdFVSTCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyVmlld10sIHsgdHlwZTogc291cmNlRGVmLm1pbWVUeXBlIH0pO1xuICAgICAgICBzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4gc291cmNlVVJJO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VEZWYudXJpID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEltYWdlIFwiICsgc291cmNlSW5kZXggKyBcIiBpcyBtaXNzaW5nIFVSSSBhbmQgYnVmZmVyVmlld1wiKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShzb3VyY2VVUkkpLnRoZW4oZnVuY3Rpb24oc291cmNlVVJJMikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgb25Mb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgaWYgKGxvYWRlci5pc0ltYWdlQml0bWFwTG9hZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgb25Mb2FkID0gZnVuY3Rpb24oaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShpbWFnZUJpdG1hcCk7XG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dHVyZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKHNvdXJjZVVSSTIsIG9wdGlvbnMucGF0aCksIG9uTG9hZCwgdm9pZCAwLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoaXNPYmplY3RVUkwgPT09IHRydWUpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzb3VyY2VVUkkpO1xuICAgICAgfVxuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSh0ZXh0dXJlLCBzb3VyY2VEZWYpO1xuICAgICAgdGV4dHVyZS51c2VyRGF0YS5taW1lVHlwZSA9IHNvdXJjZURlZi5taW1lVHlwZSB8fCBnZXRJbWFnZVVSSU1pbWVUeXBlKHNvdXJjZURlZi51cmkpO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBDb3VsZG4ndCBsb2FkIHRleHR1cmVcIiwgc291cmNlVVJJKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgYXNzaWducyBhIHRleHR1cmUgdG8gdGhlIGdpdmVuIG1hdGVyaWFsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbFBhcmFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwRGVmXG4gICAqIEByZXR1cm4ge1Byb21pc2U8VGV4dHVyZT59XG4gICAqL1xuICBhc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBtYXBOYW1lLCBtYXBEZWYsIGNvbG9yU3BhY2UpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJ0ZXh0dXJlXCIsIG1hcERlZi5pbmRleCkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoIXRleHR1cmUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKG1hcERlZi50ZXhDb29yZCAhPT0gdm9pZCAwICYmIG1hcERlZi50ZXhDb29yZCA+IDApIHtcbiAgICAgICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICAgICAgdGV4dHVyZS5jaGFubmVsID0gbWFwRGVmLnRleENvb3JkO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBtYXBEZWYuZXh0ZW5zaW9ucyAhPT0gdm9pZCAwID8gbWFwRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dIDogdm9pZCAwO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgZ2x0ZlJlZmVyZW5jZSA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KHRleHR1cmUpO1xuICAgICAgICAgIHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0uZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIGdsdGZSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29sb3JTcGFjZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3JTcGFjZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjb2xvclNwYWNlID0gY29sb3JTcGFjZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgICAgaWYgKFwiY29sb3JTcGFjZVwiIGluIHRleHR1cmUpXG4gICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gY29sb3JTcGFjZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXNbbWFwTmFtZV0gPSB0ZXh0dXJlO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbnMgZmluYWwgbWF0ZXJpYWwgdG8gYSBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuIFRoZSBpbnN0YW5jZVxuICAgKiBhbHJlYWR5IGhhcyBhIG1hdGVyaWFsIChnZW5lcmF0ZWQgZnJvbSB0aGUgZ2xURiBtYXRlcmlhbCBvcHRpb25zIGFsb25lKVxuICAgKiBidXQgcmV1c2Ugb2YgdGhlIHNhbWUgZ2xURiBtYXRlcmlhbCBtYXkgcmVxdWlyZSBtdWx0aXBsZSB0aHJlZWpzIG1hdGVyaWFsc1xuICAgKiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgcHJpbWl0aXZlIHR5cGVzLCBkZWZpbmVzLCBldGMuIE5ldyBtYXRlcmlhbHMgd2lsbFxuICAgKiBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSwgYW5kIHJldXNlZCBmcm9tIGEgY2FjaGUuXG4gICAqIEBwYXJhbSAge09iamVjdDNEfSBtZXNoIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS5cbiAgICovXG4gIGFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcbiAgICBsZXQgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuICAgIGNvbnN0IHVzZURlcml2YXRpdmVUYW5nZW50cyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VGbGF0U2hhZGluZyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsID09PSB2b2lkIDA7XG4gICAgaWYgKG1lc2guaXNQb2ludHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJQb2ludHNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIXBvaW50c01hdGVyaWFsKSB7XG4gICAgICAgIHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwocG9pbnRzTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHNNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuICAgIH0gZWxzZSBpZiAobWVzaC5pc0xpbmUpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJMaW5lQmFzaWNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgbGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwobGluZU1hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGxpbmVNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcbiAgICB9XG4gICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cyB8fCB1c2VWZXJ0ZXhDb2xvcnMgfHwgdXNlRmxhdFNoYWRpbmcpIHtcbiAgICAgIGxldCBjYWNoZUtleSA9IFwiQ2xvbmVkTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkICsgXCI6XCI7XG4gICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKVxuICAgICAgICBjYWNoZUtleSArPSBcImRlcml2YXRpdmUtdGFuZ2VudHM6XCI7XG4gICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICBjYWNoZUtleSArPSBcInZlcnRleC1jb2xvcnM6XCI7XG4gICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZmxhdC1zaGFkaW5nOlwiO1xuICAgICAgbGV0IGNhY2hlZE1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFjYWNoZWRNYXRlcmlhbCkge1xuICAgICAgICBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cykge1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgY2FjaGVkTWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2FjaGVkTWF0ZXJpYWwsIHRoaXMuYXNzb2NpYXRpb25zLmdldChtYXRlcmlhbCkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcbiAgICB9XG4gICAgbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZSgpIHtcbiAgICByZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWF0ZXJpYWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXRlcmlhbEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWF0ZXJpYWw+fVxuICAgKi9cbiAgbG9hZE1hdGVyaWFsKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IGpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGxldCBtYXRlcmlhbFR5cGU7XG4gICAgY29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcbiAgICBjb25zdCBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBpZiAobWF0ZXJpYWxFeHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF0pIHtcbiAgICAgIGNvbnN0IGttdUV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXTtcbiAgICAgIG1hdGVyaWFsVHlwZSA9IGttdUV4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoKTtcbiAgICAgIHBlbmRpbmcucHVzaChrbXVFeHRlbnNpb24uZXh0ZW5kUGFyYW1zKG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3Iuc2V0UkdCKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMucm91Z2huZXNzID0gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgOiAxO1xuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtZXRhbG5lc3NNYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJyb3VnaG5lc3NNYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFR5cGUgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuZ2V0TWF0ZXJpYWxUeXBlICYmIGV4dC5nZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyAmJiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2lkZSA9IERvdWJsZVNpZGU7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhTW9kZSA9IG1hdGVyaWFsRGVmLmFscGhhTW9kZSB8fCBBTFBIQV9NT0RFUy5PUEFRVUU7XG4gICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuQkxFTkQpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLk1BU0spIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYWxwaGFUZXN0ID0gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgIT09IHZvaWQgMCA/IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmIDogMC41O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJub3JtYWxNYXBcIiwgbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSkpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZS5zZXQoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW9NYXBcIiwgbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSkpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hb01hcEludGVuc2l0eSA9IG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IGVtaXNzaXZlRmFjdG9yID0gbWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3I7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLnNldFJHQihcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMF0sXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzFdLFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclsyXSxcbiAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiZW1pc3NpdmVNYXBcIiwgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZShtYXRlcmlhbFBhcmFtcyk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubmFtZSlcbiAgICAgICAgbWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsRGVmLm5hbWU7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtYXRlcmlhbCwgeyBtYXRlcmlhbHM6IG1hdGVyaWFsSW5kZXggfSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgLyoqIFdoZW4gT2JqZWN0M0QgaW5zdGFuY2VzIGFyZSB0YXJnZXRlZCBieSBhbmltYXRpb24sIHRoZXkgbmVlZCB1bmlxdWUgbmFtZXMuICovXG4gIGNyZWF0ZVVuaXF1ZU5hbWUob3JpZ2luYWxOYW1lKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKG9yaWdpbmFsTmFtZSB8fCBcIlwiKTtcbiAgICBpZiAoc2FuaXRpemVkTmFtZSBpbiB0aGlzLm5vZGVOYW1lc1VzZWQpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lICsgXCJfXCIgKyArK3RoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdID0gMDtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNnZW9tZXRyeVxuICAgKlxuICAgKiBDcmVhdGVzIEJ1ZmZlckdlb21ldHJpZXMgZnJvbSBwcmltaXRpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEdMVEYuUHJpbWl0aXZlPn0gcHJpbWl0aXZlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEJ1ZmZlckdlb21ldHJ5Pj59XG4gICAqL1xuICBsb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wcmltaXRpdmVDYWNoZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dLmRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikudGhlbihmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICByZXR1cm4gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmUpO1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBwZW5kaW5nLnB1c2goY2FjaGVkLnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGdlb21ldHJ5UHJvbWlzZTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dKSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0geyBwcmltaXRpdmUsIHByb21pc2U6IGdlb21ldHJ5UHJvbWlzZSB9O1xuICAgICAgICBwZW5kaW5nLnB1c2goZ2VvbWV0cnlQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21lc2hlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWVzaEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXB8TWVzaHxTa2lubmVkTWVzaD59XG4gICAqL1xuICBsb2FkTWVzaChtZXNoSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbWVzaEluZGV4XTtcbiAgICBjb25zdCBwcmltaXRpdmVzID0gbWVzaERlZi5wcmltaXRpdmVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCA9PT0gdm9pZCAwID8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKHRoaXMuY2FjaGUpIDogdGhpcy5nZXREZXBlbmRlbmN5KFwibWF0ZXJpYWxcIiwgcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCk7XG4gICAgICBwZW5kaW5nLnB1c2gobWF0ZXJpYWwpO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSByZXN1bHRzLnNsaWNlKDAsIHJlc3VsdHMubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbWVzaGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgICBsZXQgbWVzaDtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbaV07XG4gICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOIHx8IHByaW1pdGl2ZS5tb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlID8gbmV3IFNraW5uZWRNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCkgOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIGlmIChtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lc2gubm9ybWFsaXplU2tpbldlaWdodHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVApIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVGYW5EcmF3TW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORVMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9TVFJJUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9MT09QKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lTG9vcChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuUE9JTlRTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBQb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogXCIgKyBwcmltaXRpdmUubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXBkYXRlTW9ycGhUYXJnZXRzKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICB9XG4gICAgICAgIG1lc2gubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG1lc2hEZWYubmFtZSB8fCBcIm1lc2hfXCIgKyBtZXNoSW5kZXgpO1xuICAgICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2gsIHByaW1pdGl2ZSk7XG4gICAgICAgIHBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpO1xuICAgICAgICBtZXNoZXMucHVzaChtZXNoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1lc2hlc1tpXSwge1xuICAgICAgICAgIG1lc2hlczogbWVzaEluZGV4LFxuICAgICAgICAgIHByaW1pdGl2ZXM6IGlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoZXNbMF0sIG1lc2hEZWYpO1xuICAgICAgICByZXR1cm4gbWVzaGVzWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBncm91cCwgbWVzaERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChncm91cCwgeyBtZXNoZXM6IG1lc2hJbmRleCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwLmFkZChtZXNoZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjY2FtZXJhc1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2FtZXJhSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5DYW1lcmE+fVxuICAgKi9cbiAgbG9hZENhbWVyYShjYW1lcmFJbmRleCkge1xuICAgIGxldCBjYW1lcmE7XG4gICAgY29uc3QgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbY2FtZXJhSW5kZXhdO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNhbWVyYURlZltjYW1lcmFEZWYudHlwZV07XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgY2FtZXJhIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwicGVyc3BlY3RpdmVcIikge1xuICAgICAgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKFxuICAgICAgICBNYXRoVXRpbHMucmFkVG9EZWcocGFyYW1zLnlmb3YpLFxuICAgICAgICBwYXJhbXMuYXNwZWN0UmF0aW8gfHwgMSxcbiAgICAgICAgcGFyYW1zLnpuZWFyIHx8IDEsXG4gICAgICAgIHBhcmFtcy56ZmFyIHx8IDJlNlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNhbWVyYURlZi50eXBlID09PSBcIm9ydGhvZ3JhcGhpY1wiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKC1wYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtcGFyYW1zLnltYWcsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIpO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLm5hbWUpXG4gICAgICBjYW1lcmEubmFtZSA9IHRoaXMuY3JlYXRlVW5pcXVlTmFtZShjYW1lcmFEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShjYW1lcmEsIGNhbWVyYURlZik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFNrZWxldG9uPn1cbiAgICovXG4gIGxvYWRTa2luKHNraW5JbmRleCkge1xuICAgIGNvbnN0IHNraW5EZWYgPSB0aGlzLmpzb24uc2tpbnNbc2tpbkluZGV4XTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc2tpbkRlZi5qb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuX2xvYWROb2RlU2hhbGxvdyhza2luRGVmLmpvaW50c1tpXSkpO1xuICAgIH1cbiAgICBpZiAoc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBpbnZlcnNlQmluZE1hdHJpY2VzID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IGpvaW50Tm9kZXMgPSByZXN1bHRzO1xuICAgICAgY29uc3QgYm9uZXMgPSBbXTtcbiAgICAgIGNvbnN0IGJvbmVJbnZlcnNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbaV07XG4gICAgICAgIGlmIChqb2ludE5vZGUpIHtcbiAgICAgICAgICBib25lcy5wdXNoKGpvaW50Tm9kZSk7XG4gICAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgICBpZiAoaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF0LmZyb21BcnJheShpbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBpICogMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib25lSW52ZXJzZXMucHVzaChtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRGVmLmpvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2tlbGV0b24oYm9uZXMsIGJvbmVJbnZlcnNlcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuICAgKi9cbiAgbG9hZEFuaW1hdGlvbihhbmltYXRpb25JbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbYW5pbWF0aW9uSW5kZXhdO1xuICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25EZWYubmFtZSA/IGFuaW1hdGlvbkRlZi5uYW1lIDogXCJhbmltYXRpb25fXCIgKyBhbmltYXRpb25JbmRleDtcbiAgICBjb25zdCBwZW5kaW5nTm9kZXMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1NhbXBsZXJzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1RhcmdldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVsc1tpXTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBhbmltYXRpb25EZWYuc2FtcGxlcnNbY2hhbm5lbC5zYW1wbGVyXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoYW5uZWwudGFyZ2V0O1xuICAgICAgY29uc3QgbmFtZSA9IHRhcmdldC5ub2RlO1xuICAgICAgY29uc3QgaW5wdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5pbnB1dF0gOiBzYW1wbGVyLmlucHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIub3V0cHV0XSA6IHNhbXBsZXIub3V0cHV0O1xuICAgICAgaWYgKHRhcmdldC5ub2RlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcGVuZGluZ05vZGVzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBuYW1lKSk7XG4gICAgICBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBpbnB1dCkpO1xuICAgICAgcGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIG91dHB1dCkpO1xuICAgICAgcGVuZGluZ1NhbXBsZXJzLnB1c2goc2FtcGxlcik7XG4gICAgICBwZW5kaW5nVGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nTm9kZXMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ0lucHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1NhbXBsZXJzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdUYXJnZXRzKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBub2RlcyA9IGRlcGVuZGVuY2llc1swXTtcbiAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzFdO1xuICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzJdO1xuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBkZXBlbmRlbmNpZXNbM107XG4gICAgICBjb25zdCB0YXJnZXRzID0gZGVwZW5kZW5jaWVzWzRdO1xuICAgICAgY29uc3QgdHJhY2tzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvciA9IGlucHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW2ldO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZS51cGRhdGVNYXRyaXgpIHtcbiAgICAgICAgICBub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRUcmFja3MgPSBwYXJzZXIuX2NyZWF0ZUFuaW1hdGlvblRyYWNrcyhub2RlLCBpbnB1dEFjY2Vzc29yLCBvdXRwdXRBY2Nlc3Nvciwgc2FtcGxlciwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGNyZWF0ZWRUcmFja3MpIHtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNyZWF0ZWRUcmFja3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHRyYWNrcy5wdXNoKGNyZWF0ZWRUcmFja3Nba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGFuaW1hdGlvbk5hbWUsIHZvaWQgMCwgdHJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZURlZi5tZXNoID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJtZXNoXCIsIG5vZGVEZWYubWVzaCkudGhlbihmdW5jdGlvbihtZXNoKSB7XG4gICAgICBjb25zdCBub2RlID0gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCwgbWVzaCk7XG4gICAgICBpZiAobm9kZURlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKCFvLmlzTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgby5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBub2RlRGVmLndlaWdodHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbm9kZXMtYW5kLWhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fVxuICAgKi9cbiAgbG9hZE5vZGUobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZVBlbmRpbmcgPSBwYXJzZXIuX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpO1xuICAgIGNvbnN0IGNoaWxkUGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuRGVmID0gbm9kZURlZi5jaGlsZHJlbiB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbkRlZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjaGlsZFBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgY2hpbGRyZW5EZWZbaV0pKTtcbiAgICB9XG4gICAgY29uc3Qgc2tlbGV0b25QZW5kaW5nID0gbm9kZURlZi5za2luID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcInNraW5cIiwgbm9kZURlZi5za2luKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW25vZGVQZW5kaW5nLCBQcm9taXNlLmFsbChjaGlsZFBlbmRpbmcpLCBza2VsZXRvblBlbmRpbmddKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSByZXN1bHRzWzBdO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSByZXN1bHRzWzFdO1xuICAgICAgY29uc3Qgc2tlbGV0b24gPSByZXN1bHRzWzJdO1xuICAgICAgaWYgKHNrZWxldG9uICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obWVzaCkge1xuICAgICAgICAgIGlmICghbWVzaC5pc1NraW5uZWRNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIG1lc2guYmluZChza2VsZXRvbiwgX2lkZW50aXR5TWF0cml4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYWRkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8vIC5fbG9hZE5vZGVTaGFsbG93KCkgcGFyc2VzIGEgc2luZ2xlIG5vZGUuXG4gIC8vIHNraW4gYW5kIGNoaWxkIG5vZGVzIGFyZSBjcmVhdGVkIGFuZCBhZGRlZCBpbiAubG9hZE5vZGUoKSAobm8gJ18nIHByZWZpeCkuXG4gIF9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShub2RlRGVmLm5hbWUpIDogXCJcIjtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgbWVzaFByb21pc2UgPSBwYXJzZXIuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZU1lc2ggJiYgZXh0LmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCk7XG4gICAgfSk7XG4gICAgaWYgKG1lc2hQcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gobWVzaFByb21pc2UpO1xuICAgIH1cbiAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImNhbWVyYVwiLCBub2RlRGVmLmNhbWVyYSkudGhlbihmdW5jdGlvbihjYW1lcmEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQgJiYgZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgfSk7XG4gICAgdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSA9IFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ob2JqZWN0cykge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAobm9kZURlZi5pc0JvbmUgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBCb25lKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICBub2RlID0gbmV3IEdyb3VwKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5vZGUgPSBvYmplY3RzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBPYmplY3QzRCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgIT09IG9iamVjdHNbMF0pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZS5hZGQob2JqZWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLm5hbWUpIHtcbiAgICAgICAgbm9kZS51c2VyRGF0YS5uYW1lID0gbm9kZURlZi5uYW1lO1xuICAgICAgICBub2RlLm5hbWUgPSBub2RlTmFtZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5tYXRyaXggIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBtYXRyaXguZnJvbUFycmF5KG5vZGVEZWYubWF0cml4KTtcbiAgICAgICAgbm9kZS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlRGVmLnRyYW5zbGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uLmZyb21BcnJheShub2RlRGVmLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheShub2RlRGVmLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5zY2FsZS5mcm9tQXJyYXkobm9kZURlZi5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VyLmFzc29jaWF0aW9ucy5oYXMobm9kZSkpIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobm9kZSwge30pO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZSkubm9kZXMgPSBub2RlSW5kZXg7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cbiAgICovXG4gIGxvYWRTY2VuZShzY2VuZUluZGV4KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbc2NlbmVJbmRleF07XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIGlmIChzY2VuZURlZi5uYW1lKVxuICAgICAgc2NlbmUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKHNjZW5lRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBpZiAoc2NlbmVEZWYuZXh0ZW5zaW9ucylcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSBzY2VuZURlZi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZUlkcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5vZGVJZHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgc2NlbmUuYWRkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZHVjZUFzc29jaWF0aW9ucyA9IChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZHVjZWRBc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwYXJzZXIuYXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIE1hdGVyaWFsIHx8IGtleSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnRyYXZlcnNlKChub2RlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcHBpbmdzID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZTIpO1xuICAgICAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChub2RlMiwgbWFwcGluZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWR1Y2VkQXNzb2NpYXRpb25zO1xuICAgICAgfTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMgPSByZWR1Y2VBc3NvY2lhdGlvbnMoc2NlbmUpO1xuICAgICAgcmV0dXJuIHNjZW5lO1xuICAgIH0pO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25UcmFja3Mobm9kZSwgaW5wdXRBY2Nlc3Nvciwgb3V0cHV0QWNjZXNzb3IsIHNhbXBsZXIsIHRhcmdldCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBub2RlLm5hbWUgPyBub2RlLm5hbWUgOiBub2RlLnV1aWQ7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBbXTtcbiAgICBpZiAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMpIHtcbiAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzKSB7XG4gICAgICAgICAgdGFyZ2V0TmFtZXMucHVzaChvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0TmFtZXMucHVzaCh0YXJnZXROYW1lKTtcbiAgICB9XG4gICAgbGV0IFR5cGVkS2V5ZnJhbWVUcmFjaztcbiAgICBzd2l0Y2ggKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0pIHtcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLndlaWdodHM6XG4gICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucm90YXRpb246XG4gICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnBvc2l0aW9uOlxuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMuc2NhbGU6XG4gICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3dpdGNoIChvdXRwdXRBY2Nlc3Nvci5pdGVtU2l6ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBzYW1wbGVyLmludGVycG9sYXRpb24gIT09IHZvaWQgMCA/IElOVEVSUE9MQVRJT05bc2FtcGxlci5pbnRlcnBvbGF0aW9uXSA6IEludGVycG9sYXRlTGluZWFyO1xuICAgIGNvbnN0IG91dHB1dEFycmF5ID0gdGhpcy5fZ2V0QXJyYXlGcm9tQWNjZXNzb3Iob3V0cHV0QWNjZXNzb3IpO1xuICAgIGZvciAobGV0IGogPSAwLCBqbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gbmV3IFR5cGVkS2V5ZnJhbWVUcmFjayhcbiAgICAgICAgdGFyZ2V0TmFtZXNbal0gKyBcIi5cIiArIFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0sXG4gICAgICAgIGlucHV0QWNjZXNzb3IuYXJyYXksXG4gICAgICAgIG91dHB1dEFycmF5LFxuICAgICAgICBpbnRlcnBvbGF0aW9uXG4gICAgICApO1xuICAgICAgaWYgKHNhbXBsZXIuaW50ZXJwb2xhdGlvbiA9PT0gXCJDVUJJQ1NQTElORVwiKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUN1YmljU3BsaW5lVHJhY2tJbnRlcnBvbGFudCh0cmFjayk7XG4gICAgICB9XG4gICAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0cmFja3M7XG4gIH1cbiAgX2dldEFycmF5RnJvbUFjY2Vzc29yKGFjY2Vzc29yKSB7XG4gICAgbGV0IG91dHB1dEFycmF5ID0gYWNjZXNzb3IuYXJyYXk7XG4gICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKG91dHB1dEFycmF5LmNvbnN0cnVjdG9yKTtcbiAgICAgIGNvbnN0IHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0QXJyYXkubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG91dHB1dEFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgc2NhbGVkW2pdID0gb3V0cHV0QXJyYXlbal0gKiBzY2FsZTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEFycmF5ID0gc2NhbGVkO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gIH1cbiAgX2NyZWF0ZUN1YmljU3BsaW5lVHJhY2tJbnRlcnBvbGFudCh0cmFjaykge1xuICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKHJlc3VsdCkge1xuICAgICAgY29uc3QgaW50ZXJwb2xhbnRUeXBlID0gdGhpcyBpbnN0YW5jZW9mIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID8gR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IDogR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQ7XG4gICAgICByZXR1cm4gbmV3IGludGVycG9sYW50VHlwZSh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSAvIDMsIHJlc3VsdCk7XG4gICAgfTtcbiAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgYm94ID0gbmV3IEJveDMoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW2F0dHJpYnV0ZXMuUE9TSVRJT05dO1xuICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICBib3guc2V0KG5ldyBWZWN0b3IzKG1pblswXSwgbWluWzFdLCBtaW5bMl0pLCBuZXcgVmVjdG9yMyhtYXhbMF0sIG1heFsxXSwgbWF4WzJdKSk7XG4gICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICBib3gubWluLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgYm94Lm1heC5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gcHJpbWl0aXZlRGVmLnRhcmdldHM7XG4gIGlmICh0YXJnZXRzICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBtYXhEaXNwbGFjZW1lbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW3RhcmdldC5QT1NJVElPTl07XG4gICAgICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgICAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WChNYXRoLm1heChNYXRoLmFicyhtaW5bMF0pLCBNYXRoLmFicyhtYXhbMF0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFkoTWF0aC5tYXgoTWF0aC5hYnMobWluWzFdKSwgTWF0aC5hYnMobWF4WzFdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRaKE1hdGgubWF4KE1hdGguYWJzKG1pblsyXSksIE1hdGguYWJzKG1heFsyXSkpKTtcbiAgICAgICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1heERpc3BsYWNlbWVudC5tYXgodmVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJveC5leHBhbmRCeVZlY3RvcihtYXhEaXNwbGFjZW1lbnQpO1xuICB9XG4gIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gYm94O1xuICBjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gIGJveC5nZXRDZW50ZXIoc3BoZXJlLmNlbnRlcik7XG4gIHNwaGVyZS5yYWRpdXMgPSBib3gubWluLmRpc3RhbmNlVG8oYm94Lm1heCkgLyAyO1xuICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IHNwaGVyZTtcbn1cbmZ1bmN0aW9uIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgcGVuZGluZyA9IFtdO1xuICBmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhY2Nlc3NvckluZGV4LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYWNjZXNzb3JJbmRleCkudGhlbihmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGdsdGZBdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2dsdGZBdHRyaWJ1dGVOYW1lXSB8fCBnbHRmQXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aHJlZUF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcylcbiAgICAgIGNvbnRpbnVlO1xuICAgIHBlbmRpbmcucHVzaChhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhdHRyaWJ1dGVzW2dsdGZBdHRyaWJ1dGVOYW1lXSwgdGhyZWVBdHRyaWJ1dGVOYW1lKSk7XG4gIH1cbiAgaWYgKHByaW1pdGl2ZURlZi5pbmRpY2VzICE9PSB2b2lkIDAgJiYgIWdlb21ldHJ5LmluZGV4KSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHByaW1pdGl2ZURlZi5pbmRpY2VzKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yMikge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoYWNjZXNzb3IyKTtcbiAgICB9KTtcbiAgICBwZW5kaW5nLnB1c2goYWNjZXNzb3IpO1xuICB9XG4gIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoZ2VvbWV0cnksIHByaW1pdGl2ZURlZik7XG4gIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB2b2lkIDAgPyBhZGRNb3JwaFRhcmdldHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIpIDogZ2VvbWV0cnk7XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgR0xURkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMVEZMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/SVGLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/SVGLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGLoader: () => (/* binding */ SVGLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst COLOR_SPACE_SVG = \"srgb\";\nconst SVGLoader = /* @__PURE__ */ (() => {\n  class SVGLoader2 extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager) {\n      super(manager);\n      this.defaultDPI = 90;\n      this.defaultUnit = \"px\";\n    }\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(\n        url,\n        function(text) {\n          try {\n            onLoad(scope.parse(text));\n          } catch (e) {\n            if (onError) {\n              onError(e);\n            } else {\n              console.error(e);\n            }\n            scope.manager.itemError(url);\n          }\n        },\n        onProgress,\n        onError\n      );\n    }\n    parse(text) {\n      const scope = this;\n      function parseNode(node, style) {\n        if (node.nodeType !== 1)\n          return;\n        const transform = getNodeTransform(node);\n        let isDefsNode = false;\n        let path = null;\n        switch (node.nodeName) {\n          case \"svg\":\n            style = parseStyle(node, style);\n            break;\n          case \"style\":\n            parseCSSStylesheet(node);\n            break;\n          case \"g\":\n            style = parseStyle(node, style);\n            break;\n          case \"path\":\n            style = parseStyle(node, style);\n            if (node.hasAttribute(\"d\"))\n              path = parsePathNode(node);\n            break;\n          case \"rect\":\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n          case \"polygon\":\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n          case \"polyline\":\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n          case \"circle\":\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n          case \"ellipse\":\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n          case \"line\":\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n          case \"defs\":\n            isDefsNode = true;\n            break;\n          case \"use\":\n            style = parseStyle(node, style);\n            const href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n            const usedNodeId = href.substring(1);\n            const usedNode = node.viewportElement.getElementById(usedNodeId);\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n            break;\n        }\n        if (path) {\n          if (style.fill !== void 0 && style.fill !== \"none\") {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n          }\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = { node, style };\n        }\n        const childNodes = node.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n          const node2 = childNodes[i];\n          if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n            continue;\n          }\n          parseNode(node2, style);\n        }\n        if (transform) {\n          transformStack.pop();\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n      function parsePathNode(node) {\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const control = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const firstPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        let isFirstPoint = true;\n        let doSetFirstPoint = false;\n        const d = node.getAttribute(\"d\");\n        if (d === \"\" || d === \"none\")\n          return null;\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i];\n          const type = command.charAt(0);\n          const data2 = command.slice(1).trim();\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n          let numbers;\n          switch (type) {\n            case \"M\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"H\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"V\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"L\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"C\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  numbers[j + 5]\n                );\n                control.x = numbers[j + 2];\n                control.y = numbers[j + 3];\n                point.x = numbers[j + 4];\n                point.y = numbers[j + 5];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"S\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3]\n                );\n                control.x = numbers[j + 0];\n                control.y = numbers[j + 1];\n                point.x = numbers[j + 2];\n                point.y = numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"Q\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                control.x = numbers[j + 0];\n                control.y = numbers[j + 1];\n                point.x = numbers[j + 2];\n                point.y = numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"T\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x);\n                const ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"A\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)\n                  continue;\n                const start = point.clone();\n                point.x = numbers[j + 5];\n                point.y = numbers[j + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point\n                );\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"m\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0];\n                point.y += numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"h\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"v\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"l\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0];\n                point.y += numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"c\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                  point.x + numbers[j + 4],\n                  point.y + numbers[j + 5]\n                );\n                control.x = point.x + numbers[j + 2];\n                control.y = point.y + numbers[j + 3];\n                point.x += numbers[j + 4];\n                point.y += numbers[j + 5];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"s\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3]\n                );\n                control.x = point.x + numbers[j + 0];\n                control.y = point.y + numbers[j + 1];\n                point.x += numbers[j + 2];\n                point.y += numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"q\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3]\n                );\n                control.x = point.x + numbers[j + 0];\n                control.y = point.y + numbers[j + 1];\n                point.x += numbers[j + 2];\n                point.y += numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"t\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x);\n                const ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = point.x + numbers[j + 0];\n                point.y = point.y + numbers[j + 1];\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"a\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0)\n                  continue;\n                const start = point.clone();\n                point.x += numbers[j + 5];\n                point.y += numbers[j + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point\n                );\n                if (j === 0 && doSetFirstPoint === true)\n                  firstPoint.copy(point);\n              }\n              break;\n            case \"Z\":\n            case \"z\":\n              path.currentPath.autoClose = true;\n              if (path.currentPath.curves.length > 0) {\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n              break;\n            default:\n              console.warn(command);\n          }\n          doSetFirstPoint = false;\n        }\n        return path;\n      }\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n          return;\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1)\n            continue;\n          const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());\n          for (let j = 0; j < selectorList.length; j++) {\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== \"\"));\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n          }\n        }\n      }\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          path.lineTo(end.x, end.y);\n          return;\n        }\n        x_axis_rotation = x_axis_rotation * Math.PI / 180;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        const dx2 = (start.x - end.x) / 2;\n        const dy2 = (start.y - end.y) / 2;\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n        let rxs = rx * rx;\n        let rys = ry * ry;\n        const x1ps = x1p * x1p;\n        const y1ps = y1p * y1p;\n        const cr = x1ps / rxs + y1ps / rys;\n        if (cr > 1) {\n          const s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n        const dq = rxs * y1ps + rys * x1ps;\n        const pq = (rxs * rys - dq) / dq;\n        let q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag)\n          q = -q;\n        const cxp = q * rx * y1p / ry;\n        const cyp = -q * ry * x1p / rx;\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy;\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n        if (ux * vy - uy * vx < 0)\n          ang = -ang;\n        return ang;\n      }\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n        const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n        const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n        const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n        const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n        const bci = 1 - 0.551915024494;\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.moveTo(x + rx, y);\n        path.lineTo(x + w - rx, y);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n        }\n        path.lineTo(x + w, y + h - ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n        }\n        path.lineTo(x + rx, y + h);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n        }\n        path.lineTo(x, y + ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n        }\n        return path;\n      }\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a);\n          const y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        let index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a);\n          const y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        let index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n        const subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n        const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n        const subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n        const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n        const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n        const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n        const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseStyle(node, style) {\n        style = Object.assign({}, style);\n        let stylesheetStyles = {};\n        if (node.hasAttribute(\"class\")) {\n          const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i) => i.trim());\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n          }\n        }\n        if (node.hasAttribute(\"id\")) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n        }\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === void 0)\n            adjustFunction = function copy(v) {\n              if (v.startsWith(\"url\"))\n                console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n              return v;\n            };\n          if (node.hasAttribute(svgName))\n            style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName])\n            style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== \"\")\n            style[jsName] = adjustFunction(node.style[svgName]);\n        }\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n        addStyle(\"fill\", \"fill\");\n        addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n        addStyle(\"fill-rule\", \"fillRule\");\n        addStyle(\"opacity\", \"opacity\", clamp);\n        addStyle(\"stroke\", \"stroke\");\n        addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n        addStyle(\"stroke-width\", \"strokeWidth\", positive);\n        addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n        addStyle(\"stroke-linecap\", \"strokeLineCap\");\n        addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n        addStyle(\"visibility\", \"visibility\");\n        return style;\n      }\n      function getReflection(a, b) {\n        return a - (b - a);\n      }\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== \"string\") {\n          throw new TypeError(\"Invalid input: \" + typeof input);\n        }\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        };\n        const SEP = 0;\n        const INT = 1;\n        const FLOAT = 2;\n        const EXP = 3;\n        let state = SEP;\n        let seenComma = true;\n        let number = \"\", exponent = \"\";\n        const result = [];\n        function throwSyntaxError(current2, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n          error.partial = partial;\n          throw error;\n        }\n        function newNumber() {\n          if (number !== \"\") {\n            if (exponent === \"\")\n              result.push(Number(number));\n            else\n              result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n          number = \"\";\n          exponent = \"\";\n        }\n        let current;\n        const length = input.length;\n        for (let i = 0; i < length; i++) {\n          current = input[i];\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          }\n          if (state === SEP) {\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            }\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            }\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n              seenComma = true;\n            }\n          }\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n            if (RE.SIGN.test(current)) {\n              if (exponent === \"\") {\n                exponent += current;\n                continue;\n              }\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          }\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        newNumber();\n        return result;\n      }\n      const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n      function parseFloatWithUnits(string) {\n        let theUnit = \"px\";\n        if (typeof string === \"string\" || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i];\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n        let scale = void 0;\n        if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n          scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n          if (scale < 0) {\n            scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n          }\n        }\n        return scale * parseFloat(string);\n      }\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n          return null;\n        }\n        const transform = parseNodeTransform(node);\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n      function parseNodeTransform(node) {\n        const transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n        const currentTransform2 = tempTransform0;\n        if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n          const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n          const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n          transform.translate(tx, ty);\n        }\n        if (node.hasAttribute(\"transform\")) {\n          const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim();\n            if (transformText === \"\")\n              continue;\n            const openParPos = transformText.indexOf(\"(\");\n            const closeParPos = transformText.length;\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos);\n              const array = parseFloats(transformText.slice(openParPos + 1));\n              currentTransform2.identity();\n              switch (transformType) {\n                case \"translate\":\n                  if (array.length >= 1) {\n                    const tx = array[0];\n                    let ty = 0;\n                    if (array.length >= 2) {\n                      ty = array[1];\n                    }\n                    currentTransform2.translate(tx, ty);\n                  }\n                  break;\n                case \"rotate\":\n                  if (array.length >= 1) {\n                    let angle = 0;\n                    let cx = 0;\n                    let cy = 0;\n                    angle = array[0] * Math.PI / 180;\n                    if (array.length >= 3) {\n                      cx = array[1];\n                      cy = array[2];\n                    }\n                    tempTransform1.makeTranslation(-cx, -cy);\n                    tempTransform2.makeRotation(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.makeTranslation(cx, cy);\n                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n                  break;\n                case \"scale\":\n                  if (array.length >= 1) {\n                    const scaleX = array[0];\n                    let scaleY = scaleX;\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n                    currentTransform2.scale(scaleX, scaleY);\n                  }\n                  break;\n                case \"skewX\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"skewY\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"matrix\":\n                  if (array.length === 6) {\n                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n                  break;\n              }\n            }\n            transform.premultiply(currentTransform2);\n          }\n        }\n        return transform;\n      }\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n        function transfEllipseGeneric(curve) {\n          const a = curve.xRadius;\n          const b = curve.yRadius;\n          const cosTheta = Math.cos(curve.aRotation);\n          const sinTheta = Math.sin(curve.aRotation);\n          const v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(a * cosTheta, a * sinTheta, 0);\n          const v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b * sinTheta, b * cosTheta, 0);\n          const f1 = v1.applyMatrix3(m);\n          const f2 = v2.applyMatrix3(m);\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n          const mFInv = tempTransform1.copy(mF).invert();\n          const mFInvT = tempTransform2.copy(mFInv).transpose();\n          const mQ = mFInvT.multiply(mFInv);\n          const mQe = mQ.elements;\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n          const rt1sqrt = Math.sqrt(ed.rt1);\n          const rt2sqrt = Math.sqrt(ed.rt2);\n          curve.xRadius = 1 / rt1sqrt;\n          curve.yRadius = 1 / rt2sqrt;\n          curve.aRotation = Math.atan2(ed.sn, ed.cs);\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF);\n            const transformAngle = (phi) => {\n              const { x: cosR, y: sinR } = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);\n              return Math.atan2(sinR, cosR);\n            };\n            curve.aStartAngle = transformAngle(curve.aStartAngle);\n            curve.aEndAngle = transformAngle(curve.aEndAngle);\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise;\n            }\n          }\n        }\n        function transfEllipseNoSkew(curve) {\n          const sx = getTransformScaleX(m);\n          const sy = getTransformScaleY(m);\n          curve.xRadius *= sx;\n          curve.yRadius *= sy;\n          const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n          curve.aRotation += theta;\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1;\n            curve.aEndAngle *= -1;\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n        const subPaths = path.subPaths;\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i];\n          const curves = subPath.curves;\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j];\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve);\n              } else {\n                transfEllipseNoSkew(curve);\n              }\n            }\n          }\n        }\n      }\n      function isTransformFlipped(m) {\n        const te = m.elements;\n        return te[0] * te[4] - te[1] * te[3] < 0;\n      }\n      function isTransformSkewed(m) {\n        const te = m.elements;\n        const basisDot = te[0] * te[3] + te[1] * te[4];\n        if (basisDot === 0)\n          return false;\n        const sx = getTransformScaleX(m);\n        const sy = getTransformScaleY(m);\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n      }\n      function getTransformScaleX(m) {\n        const te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n      function getTransformScaleY(m) {\n        const te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      }\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t;\n        const sm = A + C;\n        const df = A - C;\n        const rt = Math.sqrt(df * df + 4 * B * B);\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt);\n          t = 1 / rt1;\n          rt2 = A * t * C - B * t * B;\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt);\n        } else {\n          rt1 = 0.5 * rt;\n          rt2 = -0.5 * rt;\n        }\n        if (df > 0) {\n          cs = df + rt;\n        } else {\n          cs = df - rt;\n        }\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = -2 * B / cs;\n          sn = 1 / Math.sqrt(1 + t * t);\n          cs = t * sn;\n        } else if (Math.abs(B) === 0) {\n          cs = 1;\n          sn = 0;\n        } else {\n          t = -0.5 * cs / B;\n          cs = 1 / Math.sqrt(1 + t * t);\n          sn = t * cs;\n        }\n        if (df > 0) {\n          t = cs;\n          cs = -sn;\n          sn = t;\n        }\n        return { rt1, rt2, cs, sn };\n      }\n      const paths = [];\n      const stylesheets = {};\n      const transformStack = [];\n      const tempTransform0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempTransform1 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempTransform2 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempTransform3 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const tempV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const currentTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n      parseNode(xml.documentElement, {\n        fill: \"#000\",\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4\n      });\n      const data = { paths, xml: xml.documentElement };\n      return data;\n    }\n    static createShapes(shapePath) {\n      const BIGNUMBER = 999999999;\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x;\n        const x2 = a1.x;\n        const x3 = b0.x;\n        const x4 = b1.x;\n        const y1 = a0.y;\n        const y2 = a1.y;\n        const y3 = b0.y;\n        const y4 = b1.y;\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        const t1 = nom1 / denom;\n        const t2 = nom2 / denom;\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1;\n              return { x: point.x, y: point.y, t: classifyResult.t };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return { x, y, t: classifyResult.t };\n            }\n          }\n          return null;\n        } else {\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1;\n              return { x: point.x, y: point.y, t: classifyResult.t };\n            }\n          }\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n          return { x, y, t: t1 };\n        }\n      }\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x;\n        const ay = edgeEnd.y - edgeStart.y;\n        const bx = p.x - edgeStart.x;\n        const by = p.y - edgeStart.y;\n        const sa = ax * by - bx * ay;\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n        let t;\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = [];\n        const intersections = [];\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1];\n          const path1EdgeEnd = path1[index];\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1];\n            const path2EdgeEnd = path2[index2];\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n            if (intersection !== null && intersectionsRaw.find(\n              (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON\n            ) === void 0) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(intersection.x, intersection.y));\n            }\n          }\n        }\n        return intersections;\n      }\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        boundingBox.getCenter(center);\n        const allIntersections = [];\n        paths.forEach((path) => {\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points);\n            intersections.forEach((p) => {\n              allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });\n            });\n          }\n        });\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n      function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n        if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n          _fillRule = \"nonzero\";\n        }\n        const centerBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        const scanline = [\n          new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scanlineMinX2, centerBoundingBox.y),\n          new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scanlineMaxX2, centerBoundingBox.y)\n        ];\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x;\n        });\n        const baseIntersections = [];\n        const otherIntersections = [];\n        scanlineIntersections.forEach((i2) => {\n          if (i2.identifier === simplePath.identifier) {\n            baseIntersections.push(i2);\n          } else {\n            otherIntersections.push(i2);\n          }\n        });\n        const firstXOfPath = baseIntersections[0].point.x;\n        const stack = [];\n        let i = 0;\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n          i++;\n        }\n        stack.push(simplePath.identifier);\n        if (_fillRule === \"evenodd\") {\n          const isHole = stack.length % 2 === 0 ? true : false;\n          const isHoleFor = stack[stack.length - 2];\n          return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n        } else if (_fillRule === \"nonzero\") {\n          let isHole = true;\n          let isHoleFor = null;\n          let lastCWValue = null;\n          for (let i2 = 0; i2 < stack.length; i2++) {\n            const identifier = stack[i2];\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW;\n              isHole = false;\n              isHoleFor = identifier;\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW;\n              isHole = true;\n            }\n          }\n          return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      }\n      let scanlineMinX = BIGNUMBER;\n      let scanlineMaxX = -BIGNUMBER;\n      let simplePaths = shapePath.subPaths.map((p) => {\n        const points = p.getPoints();\n        let maxY = -BIGNUMBER;\n        let minY = BIGNUMBER;\n        let maxX = -BIGNUMBER;\n        let minX = BIGNUMBER;\n        for (let i = 0; i < points.length; i++) {\n          const p2 = points[i];\n          if (p2.y > maxY) {\n            maxY = p2.y;\n          }\n          if (p2.y < minY) {\n            minY = p2.y;\n          }\n          if (p2.x > maxX) {\n            maxX = p2.x;\n          }\n          if (p2.x < minX) {\n            minX = p2.x;\n          }\n        }\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n        return {\n          curves: p.curves,\n          points,\n          isCW: three__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new three__WEBPACK_IMPORTED_MODULE_0__.Box2(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(minX, minY), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier;\n      }\n      const isAHole = simplePaths.map(\n        (p) => isHoleTo(\n          p,\n          simplePaths,\n          scanlineMinX,\n          scanlineMaxX,\n          shapePath.userData ? shapePath.userData.style.fillRule : void 0\n        )\n      );\n      const shapesToReturn = [];\n      simplePaths.forEach((p) => {\n        const amIAHole = isAHole[p.identifier];\n        if (!amIAHole.isHole) {\n          const shape = new three__WEBPACK_IMPORTED_MODULE_0__.Shape();\n          shape.curves = p.curves;\n          const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n          holes.forEach((h) => {\n            const hole = simplePaths[h.identifier];\n            const path = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n            path.curves = hole.curves;\n            shape.holes.push(path);\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      width = width !== void 0 ? width : 1;\n      color = color !== void 0 ? color : \"#000\";\n      lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n      lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n      miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      if (SVGLoader2.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n      const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n      geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      const tempV2_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_6 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const tempV2_7 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const lastPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const lastPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const point0L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const point0R = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const currentPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const currentPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const nextPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const nextPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const innerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const outerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n      minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n      points = removeDuplicatedPoints(points);\n      const numPoints = points.length;\n      if (numPoints < 2)\n        return 0;\n      const isClosed = points[0].equals(points[numPoints - 1]);\n      let currentPoint;\n      let previousPoint = points[0];\n      let nextPoint;\n      const strokeWidth2 = style.strokeWidth / 2;\n      const deltaU = 1 / (numPoints - 1);\n      let u0 = 0, u1;\n      let innerSideModified;\n      let joinIsOnLeftSide;\n      let isMiter;\n      let initialJoinIsOnLeftSide = false;\n      let numVertices = 0;\n      let currentCoordinate = vertexOffset * 3;\n      let currentCoordinateUV = vertexOffset * 2;\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint];\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            nextPoint = points[1];\n          } else\n            nextPoint = void 0;\n        } else {\n          nextPoint = points[iPoint + 1];\n        }\n        const normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n        if (nextPoint !== void 0) {\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n          if (iPoint === 1)\n            initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          const dot = Math.abs(normal1.dot(tempV2_3));\n          if (dot > Number.EPSILON) {\n            const miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            const miterLength2 = tempV2_5.length();\n            const segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            const segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext);\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              makeSegmentTriangles();\n            }\n            switch (style.strokeLineJoin) {\n              case \"bevel\":\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n              case \"round\":\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n                break;\n              case \"miter\":\n              case \"miter-clip\":\n              default:\n                const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                if (miterFraction < 1) {\n                  if (style.strokeLineJoin !== \"miter-clip\") {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                  isMiter = true;\n                }\n                break;\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n        if (!isClosed && iPoint === numPoints - 1) {\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        }\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n      if (!isClosed) {\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        let lastOuter = outerPoint;\n        let lastInner = innerPoint;\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n      return numVertices;\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n          currentCoordinate += 3;\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n        numVertices += 3;\n      }\n      function makeCircularSector(center, p1, p2, u, v) {\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        let angle = Math.PI;\n        const dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1)\n          angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 0);\n        addVertex(currentPointR, u1, 1);\n      }\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u, 1);\n            addVertex(innerPoint, u, 0);\n            addVertex(nextPointR, u, 1);\n          }\n        } else {\n          if (joinIsOnLeftSide2) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n        switch (style.strokeLineCap) {\n          case \"round\":\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n            break;\n          case \"square\":\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              const vl = vertices.length;\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n            break;\n        }\n      }\n      function removeDuplicatedPoints(points2) {\n        let dupPoints = false;\n        for (let i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n        if (!dupPoints)\n          return points2;\n        const newPoints = [];\n        newPoints.push(points2[0]);\n        for (let i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n            newPoints.push(points2[i]);\n          }\n        }\n        newPoints.push(points2[points2.length - 1]);\n        return newPoints;\n      }\n    }\n  }\n  return SVGLoader2;\n})();\n\n//# sourceMappingURL=SVGLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvU1ZHTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdKO0FBQ3hKO0FBQ0E7QUFDQSwyQkFBMkIseUNBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEMsMEJBQTBCLDBDQUFPO0FBQ2pDLDRCQUE0QiwwQ0FBTztBQUNuQywrQkFBK0IsMENBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUFJO0FBQ2hDO0FBQ0EseUJBQXlCLDRDQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQUk7QUFDaEM7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFHQztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcbG9hZGVyc1xcU1ZHTG9hZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgRmlsZUxvYWRlciwgTWF0cml4MywgVmVjdG9yMiwgVmVjdG9yMywgU2hhcGVVdGlscywgQm94MiwgU2hhcGUsIFBhdGgsIEJ1ZmZlckdlb21ldHJ5LCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBTaGFwZVBhdGggfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IENPTE9SX1NQQUNFX1NWRyA9IFwic3JnYlwiO1xuY29uc3QgU1ZHTG9hZGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGNsYXNzIFNWR0xvYWRlcjIgZXh0ZW5kcyBMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgICAgdGhpcy5kZWZhdWx0RFBJID0gOTA7XG4gICAgICB0aGlzLmRlZmF1bHRVbml0ID0gXCJweFwiO1xuICAgIH1cbiAgICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcihzY29wZS5tYW5hZ2VyKTtcbiAgICAgIGxvYWRlci5zZXRQYXRoKHNjb3BlLnBhdGgpO1xuICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoc2NvcGUucmVxdWVzdEhlYWRlcik7XG4gICAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHNjb3BlLndpdGhDcmVkZW50aWFscyk7XG4gICAgICBsb2FkZXIubG9hZChcbiAgICAgICAgdXJsLFxuICAgICAgICBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9uTG9hZChzY29wZS5wYXJzZSh0ZXh0KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgb25FcnJvclxuICAgICAgKTtcbiAgICB9XG4gICAgcGFyc2UodGV4dCkge1xuICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gcGFyc2VOb2RlKG5vZGUsIHN0eWxlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0Tm9kZVRyYW5zZm9ybShub2RlKTtcbiAgICAgICAgbGV0IGlzRGVmc05vZGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICBwYXJzZUNTU1N0eWxlc2hlZXQobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKFwiZFwiKSlcbiAgICAgICAgICAgICAgcGF0aCA9IHBhcnNlUGF0aE5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXJzZVJlY3ROb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBwYXRoID0gcGFyc2VQb2x5Z29uTm9kZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJwb2x5bGluZVwiOlxuICAgICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXJzZVBvbHlsaW5lTm9kZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBwYXRoID0gcGFyc2VDaXJjbGVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgICBwYXRoID0gcGFyc2VFbGxpcHNlTm9kZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgcGF0aCA9IHBhcnNlTGluZU5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVmc1wiOlxuICAgICAgICAgICAgaXNEZWZzTm9kZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidXNlXCI6XG4gICAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IG5vZGUuZ2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIFwiaHJlZlwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgY29uc3QgdXNlZE5vZGVJZCA9IGhyZWYuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgY29uc3QgdXNlZE5vZGUgPSBub2RlLnZpZXdwb3J0RWxlbWVudC5nZXRFbGVtZW50QnlJZCh1c2VkTm9kZUlkKTtcbiAgICAgICAgICAgIGlmICh1c2VkTm9kZSkge1xuICAgICAgICAgICAgICBwYXJzZU5vZGUodXNlZE5vZGUsIHN0eWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNWR0xvYWRlcjogJ3VzZSBub2RlJyByZWZlcmVuY2VzIG5vbi1leGlzdGVudCBub2RlIGlkOiBcIiArIHVzZWROb2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICBpZiAoc3R5bGUuZmlsbCAhPT0gdm9pZCAwICYmIHN0eWxlLmZpbGwgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBwYXRoLmNvbG9yLnNldFN0eWxlKHN0eWxlLmZpbGwsIENPTE9SX1NQQUNFX1NWRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zZm9ybVBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICBwYXRoLnVzZXJEYXRhID0geyBub2RlLCBzdHlsZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUyID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBpZiAoaXNEZWZzTm9kZSAmJiBub2RlMi5ub2RlTmFtZSAhPT0gXCJzdHlsZVwiICYmIG5vZGUyLm5vZGVOYW1lICE9PSBcImRlZnNcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlTm9kZShub2RlMiwgc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS5jb3B5KHRyYW5zZm9ybVN0YWNrW3RyYW5zZm9ybVN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VQYXRoTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgY29uc3QgY29udHJvbCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgICBsZXQgaXNGaXJzdFBvaW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkXCIpO1xuICAgICAgICBpZiAoZCA9PT0gXCJcIiB8fCBkID09PSBcIm5vbmVcIilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgY29tbWFuZHMgPSBkLm1hdGNoKC9bYS1kZi16XVteYS1kZi16XSovZ2kpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbW1hbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gY29tbWFuZC5jaGFyQXQoMCk7XG4gICAgICAgICAgY29uc3QgZGF0YTIgPSBjb21tYW5kLnNsaWNlKDEpLnRyaW0oKTtcbiAgICAgICAgICBpZiAoaXNGaXJzdFBvaW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkb1NldEZpcnN0UG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgaXNGaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBudW1iZXJzO1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbal07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDYpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAwXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMl0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAzXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDRdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgNV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IG51bWJlcnNbaiArIDJdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IG51bWJlcnNbaiArIDNdO1xuICAgICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyA0XTtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgNV07XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgIGdldFJlZmxlY3Rpb24ocG9pbnQueCwgY29udHJvbC54KSxcbiAgICAgICAgICAgICAgICAgIGdldFJlZmxlY3Rpb24ocG9pbnQueSwgY29udHJvbC55KSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDBdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnggPSBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gbnVtYmVyc1tqICsgMl07XG4gICAgICAgICAgICAgICAgcG9pbnQueSA9IG51bWJlcnNbaiArIDNdO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8obnVtYmVyc1tqICsgMF0sIG51bWJlcnNbaiArIDFdLCBudW1iZXJzW2ogKyAyXSwgbnVtYmVyc1tqICsgM10pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueSA9IG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ4ID0gZ2V0UmVmbGVjdGlvbihwb2ludC54LCBjb250cm9sLngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ5ID0gZ2V0UmVmbGVjdGlvbihwb2ludC55LCBjb250cm9sLnkpO1xuICAgICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIG51bWJlcnNbaiArIDBdLCBudW1iZXJzW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcng7XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gcnk7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyLCBbMywgNF0sIDcpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyc1tqICsgNV0gPT0gcG9pbnQueCAmJiBudW1iZXJzW2ogKyA2XSA9PSBwb2ludC55KVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwb2ludC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyA1XTtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgNl07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhcnNlQXJjQ29tbWFuZChcbiAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2pdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgNF0sXG4gICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcGF0aC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMClcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbal07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbal07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDYpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMF0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMl0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgM10sXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgNF0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgNV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50LnggKyBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyA0XTtcbiAgICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbaiArIDVdO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICBnZXRSZWZsZWN0aW9uKHBvaW50LngsIGNvbnRyb2wueCksXG4gICAgICAgICAgICAgICAgICBnZXRSZWZsZWN0aW9uKHBvaW50LnksIGNvbnRyb2wueSksXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMF0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMl0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgM11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50LnggKyBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbaiArIDNdO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMF0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMl0sXG4gICAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgM11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50LnggKyBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbaiArIDNdO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByeCA9IGdldFJlZmxlY3Rpb24ocG9pbnQueCwgY29udHJvbC54KTtcbiAgICAgICAgICAgICAgICBjb25zdCByeSA9IGdldFJlZmxlY3Rpb24ocG9pbnQueSwgY29udHJvbC55KTtcbiAgICAgICAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8ocngsIHJ5LCBwb2ludC54ICsgbnVtYmVyc1tqICsgMF0sIHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgY29udHJvbC54ID0gcng7XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gcnk7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IHBvaW50LnggKyBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gcG9pbnQueSArIG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIsIFszLCA0XSwgNyk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNykge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXJzW2ogKyA1XSA9PSAwICYmIG51bWJlcnNbaiArIDZdID09IDApXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHBvaW50LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyA1XTtcbiAgICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbaiArIDZdO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgY29udHJvbC55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBwYXJzZUFyY0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyc1tqICsgMl0sXG4gICAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAzXSxcbiAgICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDRdLFxuICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICBwb2ludFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgICBwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChwYXRoLmN1cnJlbnRQYXRoLmN1cnZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuY29weShmaXJzdFBvaW50KTtcbiAgICAgICAgICAgICAgICBwYXRoLmN1cnJlbnRQYXRoLmN1cnJlbnRQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgICAgICBpc0ZpcnN0UG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbW1hbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb1NldEZpcnN0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ1NTU3R5bGVzaGVldChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5zaGVldCB8fCAhbm9kZS5zaGVldC5jc3NSdWxlcyB8fCAhbm9kZS5zaGVldC5jc3NSdWxlcy5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuc2hlZXQuY3NzUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzdHlsZXNoZWV0ID0gbm9kZS5zaGVldC5jc3NSdWxlc1tpXTtcbiAgICAgICAgICBpZiAoc3R5bGVzaGVldC50eXBlICE9PSAxKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0b3JMaXN0ID0gc3R5bGVzaGVldC5zZWxlY3RvclRleHQuc3BsaXQoLywvZ20pLmZpbHRlcihCb29sZWFuKS5tYXAoKGkyKSA9PiBpMi50cmltKCkpO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VsZWN0b3JMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9ucyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzdHlsZXNoZWV0LnN0eWxlKS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSBcIlwiKSk7XG4gICAgICAgICAgICBzdHlsZXNoZWV0c1tzZWxlY3Rvckxpc3Rbal1dID0gT2JqZWN0LmFzc2lnbihzdHlsZXNoZWV0c1tzZWxlY3Rvckxpc3Rbal1dIHx8IHt9LCBkZWZpbml0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZUFyY0NvbW1hbmQocGF0aCwgcngsIHJ5LCB4X2F4aXNfcm90YXRpb24sIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChyeCA9PSAwIHx8IHJ5ID09IDApIHtcbiAgICAgICAgICBwYXRoLmxpbmVUbyhlbmQueCwgZW5kLnkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB4X2F4aXNfcm90YXRpb24gPSB4X2F4aXNfcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgICAgICAgcnkgPSBNYXRoLmFicyhyeSk7XG4gICAgICAgIGNvbnN0IGR4MiA9IChzdGFydC54IC0gZW5kLngpIC8gMjtcbiAgICAgICAgY29uc3QgZHkyID0gKHN0YXJ0LnkgLSBlbmQueSkgLyAyO1xuICAgICAgICBjb25zdCB4MXAgPSBNYXRoLmNvcyh4X2F4aXNfcm90YXRpb24pICogZHgyICsgTWF0aC5zaW4oeF9heGlzX3JvdGF0aW9uKSAqIGR5MjtcbiAgICAgICAgY29uc3QgeTFwID0gLU1hdGguc2luKHhfYXhpc19yb3RhdGlvbikgKiBkeDIgKyBNYXRoLmNvcyh4X2F4aXNfcm90YXRpb24pICogZHkyO1xuICAgICAgICBsZXQgcnhzID0gcnggKiByeDtcbiAgICAgICAgbGV0IHJ5cyA9IHJ5ICogcnk7XG4gICAgICAgIGNvbnN0IHgxcHMgPSB4MXAgKiB4MXA7XG4gICAgICAgIGNvbnN0IHkxcHMgPSB5MXAgKiB5MXA7XG4gICAgICAgIGNvbnN0IGNyID0geDFwcyAvIHJ4cyArIHkxcHMgLyByeXM7XG4gICAgICAgIGlmIChjciA+IDEpIHtcbiAgICAgICAgICBjb25zdCBzID0gTWF0aC5zcXJ0KGNyKTtcbiAgICAgICAgICByeCA9IHMgKiByeDtcbiAgICAgICAgICByeSA9IHMgKiByeTtcbiAgICAgICAgICByeHMgPSByeCAqIHJ4O1xuICAgICAgICAgIHJ5cyA9IHJ5ICogcnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHEgPSByeHMgKiB5MXBzICsgcnlzICogeDFwcztcbiAgICAgICAgY29uc3QgcHEgPSAocnhzICogcnlzIC0gZHEpIC8gZHE7XG4gICAgICAgIGxldCBxID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHBxKSk7XG4gICAgICAgIGlmIChsYXJnZV9hcmNfZmxhZyA9PT0gc3dlZXBfZmxhZylcbiAgICAgICAgICBxID0gLXE7XG4gICAgICAgIGNvbnN0IGN4cCA9IHEgKiByeCAqIHkxcCAvIHJ5O1xuICAgICAgICBjb25zdCBjeXAgPSAtcSAqIHJ5ICogeDFwIC8gcng7XG4gICAgICAgIGNvbnN0IGN4ID0gTWF0aC5jb3MoeF9heGlzX3JvdGF0aW9uKSAqIGN4cCAtIE1hdGguc2luKHhfYXhpc19yb3RhdGlvbikgKiBjeXAgKyAoc3RhcnQueCArIGVuZC54KSAvIDI7XG4gICAgICAgIGNvbnN0IGN5ID0gTWF0aC5zaW4oeF9heGlzX3JvdGF0aW9uKSAqIGN4cCArIE1hdGguY29zKHhfYXhpc19yb3RhdGlvbikgKiBjeXAgKyAoc3RhcnQueSArIGVuZC55KSAvIDI7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gc3ZnQW5nbGUoMSwgMCwgKHgxcCAtIGN4cCkgLyByeCwgKHkxcCAtIGN5cCkgLyByeSk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gc3ZnQW5nbGUoKHgxcCAtIGN4cCkgLyByeCwgKHkxcCAtIGN5cCkgLyByeSwgKC14MXAgLSBjeHApIC8gcngsICgteTFwIC0gY3lwKSAvIHJ5KSAlIChNYXRoLlBJICogMik7XG4gICAgICAgIHBhdGguY3VycmVudFBhdGguYWJzZWxsaXBzZShjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHRoZXRhICsgZGVsdGEsIHN3ZWVwX2ZsYWcgPT09IDAsIHhfYXhpc19yb3RhdGlvbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdmdBbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICAgICAgICBjb25zdCBkb3QgPSB1eCAqIHZ4ICsgdXkgKiB2eTtcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KHV4ICogdXggKyB1eSAqIHV5KSAqIE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG4gICAgICAgIGxldCBhbmcgPSBNYXRoLmFjb3MoTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGRvdCAvIGxlbikpKTtcbiAgICAgICAgaWYgKHV4ICogdnkgLSB1eSAqIHZ4IDwgMClcbiAgICAgICAgICBhbmcgPSAtYW5nO1xuICAgICAgICByZXR1cm4gYW5nO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VSZWN0Tm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ5XCIpIHx8IDApO1xuICAgICAgICBjb25zdCByeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyeFwiKSB8fCBub2RlLmdldEF0dHJpYnV0ZShcInJ5XCIpIHx8IDApO1xuICAgICAgICBjb25zdCByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyeVwiKSB8fCBub2RlLmdldEF0dHJpYnV0ZShcInJ4XCIpIHx8IDApO1xuICAgICAgICBjb25zdCB3ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpKTtcbiAgICAgICAgY29uc3QgaCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIikpO1xuICAgICAgICBjb25zdCBiY2kgPSAxIC0gMC41NTE5MTUwMjQ0OTQ7XG4gICAgICAgIGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgICAgIHBhdGgubW92ZVRvKHggKyByeCwgeSk7XG4gICAgICAgIHBhdGgubGluZVRvKHggKyB3IC0gcngsIHkpO1xuICAgICAgICBpZiAocnggIT09IDAgfHwgcnkgIT09IDApIHtcbiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oeCArIHcgLSByeCAqIGJjaSwgeSwgeCArIHcsIHkgKyByeSAqIGJjaSwgeCArIHcsIHkgKyByeSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcnkpO1xuICAgICAgICBpZiAocnggIT09IDAgfHwgcnkgIT09IDApIHtcbiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gcnkgKiBiY2ksIHggKyB3IC0gcnggKiBiY2ksIHkgKyBoLCB4ICsgdyAtIHJ4LCB5ICsgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC5saW5lVG8oeCArIHJ4LCB5ICsgaCk7XG4gICAgICAgIGlmIChyeCAhPT0gMCB8fCByeSAhPT0gMCkge1xuICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4ICsgcnggKiBiY2ksIHkgKyBoLCB4LCB5ICsgaCAtIHJ5ICogYmNpLCB4LCB5ICsgaCAtIHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgICBpZiAocnggIT09IDAgfHwgcnkgIT09IDApIHtcbiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oeCwgeSArIHJ5ICogYmNpLCB4ICsgcnggKiBiY2ksIHksIHggKyByeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZVBvbHlnb25Ob2RlKG5vZGUpIHtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IobWF0Y2gsIGEsIGIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhhKTtcbiAgICAgICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhiKTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWdleCA9IC8oWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pKD86LHxcXHMpKFsrLV0/XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KS9nO1xuICAgICAgICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBub2RlLmdldEF0dHJpYnV0ZShcInBvaW50c1wiKS5yZXBsYWNlKHJlZ2V4LCBpdGVyYXRvcik7XG4gICAgICAgIHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZVBvbHlsaW5lTm9kZShub2RlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG1hdGNoLCBhLCBiKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoYSk7XG4gICAgICAgICAgY29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoYik7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBwYXRoLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnZXggPSAvKFsrLV0/XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KSg/Oix8XFxzKShbKy1dP1xcZCpcXC4/XFxkKyg/OmVbKy1dP1xcZCspPykvZztcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbm9kZS5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikucmVwbGFjZShyZWdleCwgaXRlcmF0b3IpO1xuICAgICAgICBwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2lyY2xlTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiY3hcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiY3lcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiclwiKSB8fCAwKTtcbiAgICAgICAgY29uc3Qgc3VicGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIHN1YnBhdGguYWJzYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgICAgcGF0aC5zdWJQYXRocy5wdXNoKHN1YnBhdGgpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlRWxsaXBzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcImN4XCIpIHx8IDApO1xuICAgICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcImN5XCIpIHx8IDApO1xuICAgICAgICBjb25zdCByeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyeFwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgcnkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwicnlcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHN1YnBhdGggPSBuZXcgUGF0aCgpO1xuICAgICAgICBzdWJwYXRoLmFic2VsbGlwc2UoeCwgeSwgcngsIHJ5LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgICAgIHBhdGguc3ViUGF0aHMucHVzaChzdWJwYXRoKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZUxpbmVOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgeDEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieDFcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHkxID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInkxXCIpIHx8IDApO1xuICAgICAgICBjb25zdCB4MiA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ4MlwiKSB8fCAwKTtcbiAgICAgICAgY29uc3QgeTIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieTJcIikgfHwgMCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgICAgIHBhdGgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIHBhdGgubGluZVRvKHgyLCB5Mik7XG4gICAgICAgIHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VTdHlsZShub2RlLCBzdHlsZSkge1xuICAgICAgICBzdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlKTtcbiAgICAgICAgbGV0IHN0eWxlc2hlZXRTdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKFwiY2xhc3NcIikpIHtcbiAgICAgICAgICBjb25zdCBjbGFzc1NlbGVjdG9ycyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikuc3BsaXQoL1xccy8pLmZpbHRlcihCb29sZWFuKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZXNoZWV0U3R5bGVzID0gT2JqZWN0LmFzc2lnbihzdHlsZXNoZWV0U3R5bGVzLCBzdHlsZXNoZWV0c1tcIi5cIiArIGNsYXNzU2VsZWN0b3JzW2ldXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShcImlkXCIpKSB7XG4gICAgICAgICAgc3R5bGVzaGVldFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oc3R5bGVzaGVldFN0eWxlcywgc3R5bGVzaGVldHNbXCIjXCIgKyBub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkU3R5bGUoc3ZnTmFtZSwganNOYW1lLCBhZGp1c3RGdW5jdGlvbikge1xuICAgICAgICAgIGlmIChhZGp1c3RGdW5jdGlvbiA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgYWRqdXN0RnVuY3Rpb24gPSBmdW5jdGlvbiBjb3B5KHYpIHtcbiAgICAgICAgICAgICAgaWYgKHYuc3RhcnRzV2l0aChcInVybFwiKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTVkdMb2FkZXI6IHVybCBhY2Nlc3MgaW4gYXR0cmlidXRlcyBpcyBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKHN2Z05hbWUpKVxuICAgICAgICAgICAgc3R5bGVbanNOYW1lXSA9IGFkanVzdEZ1bmN0aW9uKG5vZGUuZ2V0QXR0cmlidXRlKHN2Z05hbWUpKTtcbiAgICAgICAgICBpZiAoc3R5bGVzaGVldFN0eWxlc1tzdmdOYW1lXSlcbiAgICAgICAgICAgIHN0eWxlW2pzTmFtZV0gPSBhZGp1c3RGdW5jdGlvbihzdHlsZXNoZWV0U3R5bGVzW3N2Z05hbWVdKTtcbiAgICAgICAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlW3N2Z05hbWVdICE9PSBcIlwiKVxuICAgICAgICAgICAgc3R5bGVbanNOYW1lXSA9IGFkanVzdEZ1bmN0aW9uKG5vZGUuc3R5bGVbc3ZnTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsYW1wKHYpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdFdpdGhVbml0cyh2KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aXZlKHYpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgcGFyc2VGbG9hdFdpdGhVbml0cyh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkU3R5bGUoXCJmaWxsXCIsIFwiZmlsbFwiKTtcbiAgICAgICAgYWRkU3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCJmaWxsT3BhY2l0eVwiLCBjbGFtcCk7XG4gICAgICAgIGFkZFN0eWxlKFwiZmlsbC1ydWxlXCIsIFwiZmlsbFJ1bGVcIik7XG4gICAgICAgIGFkZFN0eWxlKFwib3BhY2l0eVwiLCBcIm9wYWNpdHlcIiwgY2xhbXApO1xuICAgICAgICBhZGRTdHlsZShcInN0cm9rZVwiLCBcInN0cm9rZVwiKTtcbiAgICAgICAgYWRkU3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZU9wYWNpdHlcIiwgY2xhbXApO1xuICAgICAgICBhZGRTdHlsZShcInN0cm9rZS13aWR0aFwiLCBcInN0cm9rZVdpZHRoXCIsIHBvc2l0aXZlKTtcbiAgICAgICAgYWRkU3R5bGUoXCJzdHJva2UtbGluZWpvaW5cIiwgXCJzdHJva2VMaW5lSm9pblwiKTtcbiAgICAgICAgYWRkU3R5bGUoXCJzdHJva2UtbGluZWNhcFwiLCBcInN0cm9rZUxpbmVDYXBcIik7XG4gICAgICAgIGFkZFN0eWxlKFwic3Ryb2tlLW1pdGVybGltaXRcIiwgXCJzdHJva2VNaXRlckxpbWl0XCIsIHBvc2l0aXZlKTtcbiAgICAgICAgYWRkU3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJpbGl0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UmVmbGVjdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gKGIgLSBhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXRzKGlucHV0LCBmbGFncywgc3RyaWRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBpbnB1dDogXCIgKyB0eXBlb2YgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFJFID0ge1xuICAgICAgICAgIFNFUEFSQVRPUjogL1sgXFx0XFxyXFxuXFwsLlxcLStdLyxcbiAgICAgICAgICBXSElURVNQQUNFOiAvWyBcXHRcXHJcXG5dLyxcbiAgICAgICAgICBESUdJVDogL1tcXGRdLyxcbiAgICAgICAgICBTSUdOOiAvWy0rXS8sXG4gICAgICAgICAgUE9JTlQ6IC9cXC4vLFxuICAgICAgICAgIENPTU1BOiAvLC8sXG4gICAgICAgICAgRVhQOiAvZS9pLFxuICAgICAgICAgIEZMQUdTOiAvWzAxXS9cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgU0VQID0gMDtcbiAgICAgICAgY29uc3QgSU5UID0gMTtcbiAgICAgICAgY29uc3QgRkxPQVQgPSAyO1xuICAgICAgICBjb25zdCBFWFAgPSAzO1xuICAgICAgICBsZXQgc3RhdGUgPSBTRVA7XG4gICAgICAgIGxldCBzZWVuQ29tbWEgPSB0cnVlO1xuICAgICAgICBsZXQgbnVtYmVyID0gXCJcIiwgZXhwb25lbnQgPSBcIlwiO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gdGhyb3dTeW50YXhFcnJvcihjdXJyZW50MiwgaSwgcGFydGlhbCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGNoYXJhY3RlciBcIicgKyBjdXJyZW50MiArICdcIiBhdCBpbmRleCAnICsgaSArIFwiLlwiKTtcbiAgICAgICAgICBlcnJvci5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXdOdW1iZXIoKSB7XG4gICAgICAgICAgaWYgKG51bWJlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSBcIlwiKVxuICAgICAgICAgICAgICByZXN1bHQucHVzaChOdW1iZXIobnVtYmVyKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKE51bWJlcihudW1iZXIpICogTWF0aC5wb3coMTAsIE51bWJlcihleHBvbmVudCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyID0gXCJcIjtcbiAgICAgICAgICBleHBvbmVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnQgPSBpbnB1dFtpXTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmbGFncykgJiYgZmxhZ3MuaW5jbHVkZXMocmVzdWx0Lmxlbmd0aCAlIHN0cmlkZSkgJiYgUkUuRkxBR1MudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgc3RhdGUgPSBJTlQ7XG4gICAgICAgICAgICBudW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgICAgbmV3TnVtYmVyKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBTRVApIHtcbiAgICAgICAgICAgIGlmIChSRS5XSElURVNQQUNFLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuRElHSVQudGVzdChjdXJyZW50KSB8fCBSRS5TSUdOLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBJTlQ7XG4gICAgICAgICAgICAgIG51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJFLlBPSU5ULnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBGTE9BVDtcbiAgICAgICAgICAgICAgbnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuQ09NTUEudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBpZiAoc2VlbkNvbW1hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dTeW50YXhFcnJvcihjdXJyZW50LCBpLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlZW5Db21tYSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gSU5UKSB7XG4gICAgICAgICAgICBpZiAoUkUuRElHSVQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gY3VycmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuUE9JTlQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gY3VycmVudDtcbiAgICAgICAgICAgICAgc3RhdGUgPSBGTE9BVDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkUuRVhQLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBFWFA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJFLlNJR04udGVzdChjdXJyZW50KSAmJiBudW1iZXIubGVuZ3RoID09PSAxICYmIFJFLlNJR04udGVzdChudW1iZXJbMF0pKSB7XG4gICAgICAgICAgICAgIHRocm93U3ludGF4RXJyb3IoY3VycmVudCwgaSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBGTE9BVCkge1xuICAgICAgICAgICAgaWYgKFJFLkRJR0lULnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJFLkVYUC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gRVhQO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSRS5QT0lOVC50ZXN0KGN1cnJlbnQpICYmIG51bWJlcltudW1iZXIubGVuZ3RoIC0gMV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgIHRocm93U3ludGF4RXJyb3IoY3VycmVudCwgaSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBFWFApIHtcbiAgICAgICAgICAgIGlmIChSRS5ESUdJVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIGV4cG9uZW50ICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJFLlNJR04udGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBleHBvbmVudCArPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChleHBvbmVudC5sZW5ndGggPT09IDEgJiYgUkUuU0lHTi50ZXN0KGV4cG9uZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93U3ludGF4RXJyb3IoY3VycmVudCwgaSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUkUuV0hJVEVTUEFDRS50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICAgIHN0YXRlID0gU0VQO1xuICAgICAgICAgICAgc2VlbkNvbW1hID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChSRS5DT01NQS50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICAgIHN0YXRlID0gU0VQO1xuICAgICAgICAgICAgc2VlbkNvbW1hID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJFLlNJR04udGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgbmV3TnVtYmVyKCk7XG4gICAgICAgICAgICBzdGF0ZSA9IElOVDtcbiAgICAgICAgICAgIG51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChSRS5QT0lOVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICAgIHN0YXRlID0gRkxPQVQ7XG4gICAgICAgICAgICBudW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd1N5bnRheEVycm9yKGN1cnJlbnQsIGksIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld051bWJlcigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgY29uc3QgdW5pdHMgPSBbXCJtbVwiLCBcImNtXCIsIFwiaW5cIiwgXCJwdFwiLCBcInBjXCIsIFwicHhcIl07XG4gICAgICBjb25zdCB1bml0Q29udmVyc2lvbiA9IHtcbiAgICAgICAgbW06IHtcbiAgICAgICAgICBtbTogMSxcbiAgICAgICAgICBjbTogMC4xLFxuICAgICAgICAgIGluOiAxIC8gMjUuNCxcbiAgICAgICAgICBwdDogNzIgLyAyNS40LFxuICAgICAgICAgIHBjOiA2IC8gMjUuNCxcbiAgICAgICAgICBweDogLTFcbiAgICAgICAgfSxcbiAgICAgICAgY206IHtcbiAgICAgICAgICBtbTogMTAsXG4gICAgICAgICAgY206IDEsXG4gICAgICAgICAgaW46IDEgLyAyLjU0LFxuICAgICAgICAgIHB0OiA3MiAvIDIuNTQsXG4gICAgICAgICAgcGM6IDYgLyAyLjU0LFxuICAgICAgICAgIHB4OiAtMVxuICAgICAgICB9LFxuICAgICAgICBpbjoge1xuICAgICAgICAgIG1tOiAyNS40LFxuICAgICAgICAgIGNtOiAyLjU0LFxuICAgICAgICAgIGluOiAxLFxuICAgICAgICAgIHB0OiA3MixcbiAgICAgICAgICBwYzogNixcbiAgICAgICAgICBweDogLTFcbiAgICAgICAgfSxcbiAgICAgICAgcHQ6IHtcbiAgICAgICAgICBtbTogMjUuNCAvIDcyLFxuICAgICAgICAgIGNtOiAyLjU0IC8gNzIsXG4gICAgICAgICAgaW46IDEgLyA3MixcbiAgICAgICAgICBwdDogMSxcbiAgICAgICAgICBwYzogNiAvIDcyLFxuICAgICAgICAgIHB4OiAtMVxuICAgICAgICB9LFxuICAgICAgICBwYzoge1xuICAgICAgICAgIG1tOiAyNS40IC8gNixcbiAgICAgICAgICBjbTogMi41NCAvIDYsXG4gICAgICAgICAgaW46IDEgLyA2LFxuICAgICAgICAgIHB0OiA3MiAvIDYsXG4gICAgICAgICAgcGM6IDEsXG4gICAgICAgICAgcHg6IC0xXG4gICAgICAgIH0sXG4gICAgICAgIHB4OiB7XG4gICAgICAgICAgcHg6IDFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXRXaXRoVW5pdHMoc3RyaW5nKSB7XG4gICAgICAgIGxldCB0aGVVbml0ID0gXCJweFwiO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gXCJzdHJpbmdcIiB8fCBzdHJpbmcgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHVuaXRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdSA9IHVuaXRzW2ldO1xuICAgICAgICAgICAgaWYgKHN0cmluZy5lbmRzV2l0aCh1KSkge1xuICAgICAgICAgICAgICB0aGVVbml0ID0gdTtcbiAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZygwLCBzdHJpbmcubGVuZ3RoIC0gdS5sZW5ndGgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjYWxlID0gdm9pZCAwO1xuICAgICAgICBpZiAodGhlVW5pdCA9PT0gXCJweFwiICYmIHNjb3BlLmRlZmF1bHRVbml0ICE9PSBcInB4XCIpIHtcbiAgICAgICAgICBzY2FsZSA9IHVuaXRDb252ZXJzaW9uW1wiaW5cIl1bc2NvcGUuZGVmYXVsdFVuaXRdIC8gc2NvcGUuZGVmYXVsdERQSTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZSA9IHVuaXRDb252ZXJzaW9uW3RoZVVuaXRdW3Njb3BlLmRlZmF1bHRVbml0XTtcbiAgICAgICAgICBpZiAoc2NhbGUgPCAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHVuaXRDb252ZXJzaW9uW3RoZVVuaXRdW1wiaW5cIl0gKiBzY29wZS5kZWZhdWx0RFBJO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbGUgKiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXROb2RlVHJhbnNmb3JtKG5vZGUpIHtcbiAgICAgICAgaWYgKCEobm9kZS5oYXNBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikgfHwgbm9kZS5ub2RlTmFtZSA9PT0gXCJ1c2VcIiAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJ4XCIpIHx8IG5vZGUuaGFzQXR0cmlidXRlKFwieVwiKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gcGFyc2VOb2RlVHJhbnNmb3JtKG5vZGUpO1xuICAgICAgICBpZiAodHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRyYW5zZm9ybS5wcmVtdWx0aXBseSh0cmFuc2Zvcm1TdGFja1t0cmFuc2Zvcm1TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRyYW5zZm9ybS5jb3B5KHRyYW5zZm9ybSk7XG4gICAgICAgIHRyYW5zZm9ybVN0YWNrLnB1c2godHJhbnNmb3JtKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlTm9kZVRyYW5zZm9ybShub2RlKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyBNYXRyaXgzKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0yID0gdGVtcFRyYW5zZm9ybTA7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBcInVzZVwiICYmIChub2RlLmhhc0F0dHJpYnV0ZShcInhcIikgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoXCJ5XCIpKSkge1xuICAgICAgICAgIGNvbnN0IHR4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInhcIikpO1xuICAgICAgICAgIGNvbnN0IHR5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInlcIikpO1xuICAgICAgICAgIHRyYW5zZm9ybS50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1zVGV4dHMgPSBub2RlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKS5zcGxpdChcIilcIik7XG4gICAgICAgICAgZm9yIChsZXQgdEluZGV4ID0gdHJhbnNmb3Jtc1RleHRzLmxlbmd0aCAtIDE7IHRJbmRleCA+PSAwOyB0SW5kZXgtLSkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGV4dCA9IHRyYW5zZm9ybXNUZXh0c1t0SW5kZXhdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1UZXh0ID09PSBcIlwiKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5QYXJQb3MgPSB0cmFuc2Zvcm1UZXh0LmluZGV4T2YoXCIoXCIpO1xuICAgICAgICAgICAgY29uc3QgY2xvc2VQYXJQb3MgPSB0cmFuc2Zvcm1UZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvcGVuUGFyUG9zID4gMCAmJiBvcGVuUGFyUG9zIDwgY2xvc2VQYXJQb3MpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVHlwZSA9IHRyYW5zZm9ybVRleHQuc2xpY2UoMCwgb3BlblBhclBvcyk7XG4gICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gcGFyc2VGbG9hdHModHJhbnNmb3JtVGV4dC5zbGljZShvcGVuUGFyUG9zICsgMSkpO1xuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi5pZGVudGl0eSgpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zZm9ybVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNsYXRlXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhcnJheVswXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHkgPSBhcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3RhdGVcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IGFycmF5WzBdICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3ggPSBhcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICBjeSA9IGFycmF5WzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2Zvcm0xLm1ha2VUcmFuc2xhdGlvbigtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2Zvcm0yLm1ha2VSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2Zvcm0zLm11bHRpcGx5TWF0cmljZXModGVtcFRyYW5zZm9ybTIsIHRlbXBUcmFuc2Zvcm0xKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zZm9ybTEubWFrZVRyYW5zbGF0aW9uKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLm11bHRpcGx5TWF0cmljZXModGVtcFRyYW5zZm9ybTEsIHRlbXBUcmFuc2Zvcm0zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsZVwiOlxuICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IGFycmF5WzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGVZID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSBhcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2tld1hcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybTIuc2V0KDEsIE1hdGgudGFuKGFycmF5WzBdICogTWF0aC5QSSAvIDE4MCksIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNrZXdZXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnNldCgxLCAwLCAwLCBNYXRoLnRhbihhcnJheVswXSAqIE1hdGguUEkgLyAxODApLCAxLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybTIuc2V0KGFycmF5WzBdLCBhcnJheVsyXSwgYXJyYXlbNF0sIGFycmF5WzFdLCBhcnJheVszXSwgYXJyYXlbNV0sIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybS5wcmVtdWx0aXBseShjdXJyZW50VHJhbnNmb3JtMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIG0pIHtcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmVmVjMih2Mikge1xuICAgICAgICAgIHRlbXBWMy5zZXQodjIueCwgdjIueSwgMSkuYXBwbHlNYXRyaXgzKG0pO1xuICAgICAgICAgIHYyLnNldCh0ZW1wVjMueCwgdGVtcFYzLnkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zZkVsbGlwc2VHZW5lcmljKGN1cnZlKSB7XG4gICAgICAgICAgY29uc3QgYSA9IGN1cnZlLnhSYWRpdXM7XG4gICAgICAgICAgY29uc3QgYiA9IGN1cnZlLnlSYWRpdXM7XG4gICAgICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyhjdXJ2ZS5hUm90YXRpb24pO1xuICAgICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4oY3VydmUuYVJvdGF0aW9uKTtcbiAgICAgICAgICBjb25zdCB2MSA9IG5ldyBWZWN0b3IzKGEgKiBjb3NUaGV0YSwgYSAqIHNpblRoZXRhLCAwKTtcbiAgICAgICAgICBjb25zdCB2MiA9IG5ldyBWZWN0b3IzKC1iICogc2luVGhldGEsIGIgKiBjb3NUaGV0YSwgMCk7XG4gICAgICAgICAgY29uc3QgZjEgPSB2MS5hcHBseU1hdHJpeDMobSk7XG4gICAgICAgICAgY29uc3QgZjIgPSB2Mi5hcHBseU1hdHJpeDMobSk7XG4gICAgICAgICAgY29uc3QgbUYgPSB0ZW1wVHJhbnNmb3JtMC5zZXQoZjEueCwgZjIueCwgMCwgZjEueSwgZjIueSwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgY29uc3QgbUZJbnYgPSB0ZW1wVHJhbnNmb3JtMS5jb3B5KG1GKS5pbnZlcnQoKTtcbiAgICAgICAgICBjb25zdCBtRkludlQgPSB0ZW1wVHJhbnNmb3JtMi5jb3B5KG1GSW52KS50cmFuc3Bvc2UoKTtcbiAgICAgICAgICBjb25zdCBtUSA9IG1GSW52VC5tdWx0aXBseShtRkludik7XG4gICAgICAgICAgY29uc3QgbVFlID0gbVEuZWxlbWVudHM7XG4gICAgICAgICAgY29uc3QgZWQgPSBlaWdlbkRlY29tcG9zaXRpb24obVFlWzBdLCBtUWVbMV0sIG1RZVs0XSk7XG4gICAgICAgICAgY29uc3QgcnQxc3FydCA9IE1hdGguc3FydChlZC5ydDEpO1xuICAgICAgICAgIGNvbnN0IHJ0MnNxcnQgPSBNYXRoLnNxcnQoZWQucnQyKTtcbiAgICAgICAgICBjdXJ2ZS54UmFkaXVzID0gMSAvIHJ0MXNxcnQ7XG4gICAgICAgICAgY3VydmUueVJhZGl1cyA9IDEgLyBydDJzcXJ0O1xuICAgICAgICAgIGN1cnZlLmFSb3RhdGlvbiA9IE1hdGguYXRhbjIoZWQuc24sIGVkLmNzKTtcbiAgICAgICAgICBjb25zdCBpc0Z1bGxFbGxpcHNlID0gKGN1cnZlLmFFbmRBbmdsZSAtIGN1cnZlLmFTdGFydEFuZ2xlKSAlICgyICogTWF0aC5QSSkgPCBOdW1iZXIuRVBTSUxPTjtcbiAgICAgICAgICBpZiAoIWlzRnVsbEVsbGlwc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1Ec3FydCA9IHRlbXBUcmFuc2Zvcm0xLnNldChydDFzcXJ0LCAwLCAwLCAwLCBydDJzcXJ0LCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IG1SVCA9IHRlbXBUcmFuc2Zvcm0yLnNldChlZC5jcywgZWQuc24sIDAsIC1lZC5zbiwgZWQuY3MsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgY29uc3QgbURSRiA9IG1Ec3FydC5tdWx0aXBseShtUlQpLm11bHRpcGx5KG1GKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybUFuZ2xlID0gKHBoaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IHg6IGNvc1IsIHk6IHNpblIgfSA9IG5ldyBWZWN0b3IzKE1hdGguY29zKHBoaSksIE1hdGguc2luKHBoaSksIDApLmFwcGx5TWF0cml4MyhtRFJGKTtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoc2luUiwgY29zUik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3VydmUuYVN0YXJ0QW5nbGUgPSB0cmFuc2Zvcm1BbmdsZShjdXJ2ZS5hU3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBjdXJ2ZS5hRW5kQW5nbGUgPSB0cmFuc2Zvcm1BbmdsZShjdXJ2ZS5hRW5kQW5nbGUpO1xuICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtRmxpcHBlZChtKSkge1xuICAgICAgICAgICAgICBjdXJ2ZS5hQ2xvY2t3aXNlID0gIWN1cnZlLmFDbG9ja3dpc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zZkVsbGlwc2VOb1NrZXcoY3VydmUpIHtcbiAgICAgICAgICBjb25zdCBzeCA9IGdldFRyYW5zZm9ybVNjYWxlWChtKTtcbiAgICAgICAgICBjb25zdCBzeSA9IGdldFRyYW5zZm9ybVNjYWxlWShtKTtcbiAgICAgICAgICBjdXJ2ZS54UmFkaXVzICo9IHN4O1xuICAgICAgICAgIGN1cnZlLnlSYWRpdXMgKj0gc3k7XG4gICAgICAgICAgY29uc3QgdGhldGEgPSBzeCA+IE51bWJlci5FUFNJTE9OID8gTWF0aC5hdGFuMihtLmVsZW1lbnRzWzFdLCBtLmVsZW1lbnRzWzBdKSA6IE1hdGguYXRhbjIoLW0uZWxlbWVudHNbM10sIG0uZWxlbWVudHNbNF0pO1xuICAgICAgICAgIGN1cnZlLmFSb3RhdGlvbiArPSB0aGV0YTtcbiAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1GbGlwcGVkKG0pKSB7XG4gICAgICAgICAgICBjdXJ2ZS5hU3RhcnRBbmdsZSAqPSAtMTtcbiAgICAgICAgICAgIGN1cnZlLmFFbmRBbmdsZSAqPSAtMTtcbiAgICAgICAgICAgIGN1cnZlLmFDbG9ja3dpc2UgPSAhY3VydmUuYUNsb2Nrd2lzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViUGF0aHMgPSBwYXRoLnN1YlBhdGhzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGNvbnN0IHN1YlBhdGggPSBzdWJQYXRoc1tpXTtcbiAgICAgICAgICBjb25zdCBjdXJ2ZXMgPSBzdWJQYXRoLmN1cnZlcztcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnZlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY3VydmUgPSBjdXJ2ZXNbal07XG4gICAgICAgICAgICBpZiAoY3VydmUuaXNMaW5lQ3VydmUpIHtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MSk7XG4gICAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZS5pc0N1YmljQmV6aWVyQ3VydmUpIHtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MCk7XG4gICAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjEpO1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYyKTtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52Myk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnZlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUpIHtcbiAgICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MCk7XG4gICAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjEpO1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VydmUuaXNFbGxpcHNlQ3VydmUpIHtcbiAgICAgICAgICAgICAgdGVtcFYyLnNldChjdXJ2ZS5hWCwgY3VydmUuYVkpO1xuICAgICAgICAgICAgICB0cmFuc2ZWZWMyKHRlbXBWMik7XG4gICAgICAgICAgICAgIGN1cnZlLmFYID0gdGVtcFYyLng7XG4gICAgICAgICAgICAgIGN1cnZlLmFZID0gdGVtcFYyLnk7XG4gICAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybVNrZXdlZChtKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZkVsbGlwc2VHZW5lcmljKGN1cnZlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZFbGxpcHNlTm9Ta2V3KGN1cnZlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXNUcmFuc2Zvcm1GbGlwcGVkKG0pIHtcbiAgICAgICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gdGVbMF0gKiB0ZVs0XSAtIHRlWzFdICogdGVbM10gPCAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXNUcmFuc2Zvcm1Ta2V3ZWQobSkge1xuICAgICAgICBjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGJhc2lzRG90ID0gdGVbMF0gKiB0ZVszXSArIHRlWzFdICogdGVbNF07XG4gICAgICAgIGlmIChiYXNpc0RvdCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN4ID0gZ2V0VHJhbnNmb3JtU2NhbGVYKG0pO1xuICAgICAgICBjb25zdCBzeSA9IGdldFRyYW5zZm9ybVNjYWxlWShtKTtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGJhc2lzRG90IC8gKHN4ICogc3kpKSA+IE51bWJlci5FUFNJTE9OO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVYKG0pIHtcbiAgICAgICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRlWzBdICogdGVbMF0gKyB0ZVsxXSAqIHRlWzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVNjYWxlWShtKSB7XG4gICAgICAgIGNvbnN0IHRlID0gbS5lbGVtZW50cztcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0ZVszXSAqIHRlWzNdICsgdGVbNF0gKiB0ZVs0XSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlaWdlbkRlY29tcG9zaXRpb24oQSwgQiwgQykge1xuICAgICAgICBsZXQgcnQxLCBydDIsIGNzLCBzbiwgdDtcbiAgICAgICAgY29uc3Qgc20gPSBBICsgQztcbiAgICAgICAgY29uc3QgZGYgPSBBIC0gQztcbiAgICAgICAgY29uc3QgcnQgPSBNYXRoLnNxcnQoZGYgKiBkZiArIDQgKiBCICogQik7XG4gICAgICAgIGlmIChzbSA+IDApIHtcbiAgICAgICAgICBydDEgPSAwLjUgKiAoc20gKyBydCk7XG4gICAgICAgICAgdCA9IDEgLyBydDE7XG4gICAgICAgICAgcnQyID0gQSAqIHQgKiBDIC0gQiAqIHQgKiBCO1xuICAgICAgICB9IGVsc2UgaWYgKHNtIDwgMCkge1xuICAgICAgICAgIHJ0MiA9IDAuNSAqIChzbSAtIHJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydDEgPSAwLjUgKiBydDtcbiAgICAgICAgICBydDIgPSAtMC41ICogcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRmID4gMCkge1xuICAgICAgICAgIGNzID0gZGYgKyBydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcyA9IGRmIC0gcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKGNzKSA+IDIgKiBNYXRoLmFicyhCKSkge1xuICAgICAgICAgIHQgPSAtMiAqIEIgLyBjcztcbiAgICAgICAgICBzbiA9IDEgLyBNYXRoLnNxcnQoMSArIHQgKiB0KTtcbiAgICAgICAgICBjcyA9IHQgKiBzbjtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhCKSA9PT0gMCkge1xuICAgICAgICAgIGNzID0gMTtcbiAgICAgICAgICBzbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IC0wLjUgKiBjcyAvIEI7XG4gICAgICAgICAgY3MgPSAxIC8gTWF0aC5zcXJ0KDEgKyB0ICogdCk7XG4gICAgICAgICAgc24gPSB0ICogY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRmID4gMCkge1xuICAgICAgICAgIHQgPSBjcztcbiAgICAgICAgICBjcyA9IC1zbjtcbiAgICAgICAgICBzbiA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcnQxLCBydDIsIGNzLCBzbiB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgIGNvbnN0IHN0eWxlc2hlZXRzID0ge307XG4gICAgICBjb25zdCB0cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgICAgY29uc3QgdGVtcFRyYW5zZm9ybTAgPSBuZXcgTWF0cml4MygpO1xuICAgICAgY29uc3QgdGVtcFRyYW5zZm9ybTEgPSBuZXcgTWF0cml4MygpO1xuICAgICAgY29uc3QgdGVtcFRyYW5zZm9ybTIgPSBuZXcgTWF0cml4MygpO1xuICAgICAgY29uc3QgdGVtcFRyYW5zZm9ybTMgPSBuZXcgTWF0cml4MygpO1xuICAgICAgY29uc3QgdGVtcFYyID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IHRlbXBWMyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcbiAgICAgIGNvbnN0IHhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJpbWFnZS9zdmcreG1sXCIpO1xuICAgICAgcGFyc2VOb2RlKHhtbC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgZmlsbDogXCIjMDAwXCIsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlTGluZUpvaW46IFwibWl0ZXJcIixcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogXCJidXR0XCIsXG4gICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6IDRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IHsgcGF0aHMsIHhtbDogeG1sLmRvY3VtZW50RWxlbWVudCB9O1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTaGFwZXMoc2hhcGVQYXRoKSB7XG4gICAgICBjb25zdCBCSUdOVU1CRVIgPSA5OTk5OTk5OTk7XG4gICAgICBjb25zdCBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUgPSB7XG4gICAgICAgIE9SSUdJTjogMCxcbiAgICAgICAgREVTVElOQVRJT046IDEsXG4gICAgICAgIEJFVFdFRU46IDIsXG4gICAgICAgIExFRlQ6IDMsXG4gICAgICAgIFJJR0hUOiA0LFxuICAgICAgICBCRUhJTkQ6IDUsXG4gICAgICAgIEJFWU9ORDogNlxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsYXNzaWZ5UmVzdWx0ID0ge1xuICAgICAgICBsb2M6IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5PUklHSU4sXG4gICAgICAgIHQ6IDBcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBmaW5kRWRnZUludGVyc2VjdGlvbihhMCwgYTEsIGIwLCBiMSkge1xuICAgICAgICBjb25zdCB4MSA9IGEwLng7XG4gICAgICAgIGNvbnN0IHgyID0gYTEueDtcbiAgICAgICAgY29uc3QgeDMgPSBiMC54O1xuICAgICAgICBjb25zdCB4NCA9IGIxLng7XG4gICAgICAgIGNvbnN0IHkxID0gYTAueTtcbiAgICAgICAgY29uc3QgeTIgPSBhMS55O1xuICAgICAgICBjb25zdCB5MyA9IGIwLnk7XG4gICAgICAgIGNvbnN0IHk0ID0gYjEueTtcbiAgICAgICAgY29uc3Qgbm9tMSA9ICh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKTtcbiAgICAgICAgY29uc3Qgbm9tMiA9ICh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKTtcbiAgICAgICAgY29uc3QgZGVub20gPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG4gICAgICAgIGNvbnN0IHQxID0gbm9tMSAvIGRlbm9tO1xuICAgICAgICBjb25zdCB0MiA9IG5vbTIgLyBkZW5vbTtcbiAgICAgICAgaWYgKGRlbm9tID09PSAwICYmIG5vbTEgIT09IDAgfHwgdDEgPD0gMCB8fCB0MSA+PSAxIHx8IHQyIDwgMCB8fCB0MiA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChub20xID09PSAwICYmIGRlbm9tID09PSAwKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIGNsYXNzaWZ5UG9pbnQoaSA9PT0gMCA/IGIwIDogYjEsIGEwLCBhMSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NpZnlSZXN1bHQubG9jID09IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5PUklHSU4pIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBpID09PSAwID8gYjAgOiBiMTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSwgdDogY2xhc3NpZnlSZXN1bHQudCB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFVFdFRU4pIHtcbiAgICAgICAgICAgICAgY29uc3QgeCA9ICsoeDEgKyBjbGFzc2lmeVJlc3VsdC50ICogKHgyIC0geDEpKS50b1ByZWNpc2lvbigxMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHkgPSArKHkxICsgY2xhc3NpZnlSZXN1bHQudCAqICh5MiAtIHkxKSkudG9QcmVjaXNpb24oMTApO1xuICAgICAgICAgICAgICByZXR1cm4geyB4LCB5LCB0OiBjbGFzc2lmeVJlc3VsdC50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICBjbGFzc2lmeVBvaW50KGkgPT09IDAgPyBiMCA6IGIxLCBhMCwgYTEpO1xuICAgICAgICAgICAgaWYgKGNsYXNzaWZ5UmVzdWx0LmxvYyA9PSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gaSA9PT0gMCA/IGIwIDogYjE7XG4gICAgICAgICAgICAgIHJldHVybiB7IHg6IHBvaW50LngsIHk6IHBvaW50LnksIHQ6IGNsYXNzaWZ5UmVzdWx0LnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeCA9ICsoeDEgKyB0MSAqICh4MiAtIHgxKSkudG9QcmVjaXNpb24oMTApO1xuICAgICAgICAgIGNvbnN0IHkgPSArKHkxICsgdDEgKiAoeTIgLSB5MSkpLnRvUHJlY2lzaW9uKDEwKTtcbiAgICAgICAgICByZXR1cm4geyB4LCB5LCB0OiB0MSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGFzc2lmeVBvaW50KHAsIGVkZ2VTdGFydCwgZWRnZUVuZCkge1xuICAgICAgICBjb25zdCBheCA9IGVkZ2VFbmQueCAtIGVkZ2VTdGFydC54O1xuICAgICAgICBjb25zdCBheSA9IGVkZ2VFbmQueSAtIGVkZ2VTdGFydC55O1xuICAgICAgICBjb25zdCBieCA9IHAueCAtIGVkZ2VTdGFydC54O1xuICAgICAgICBjb25zdCBieSA9IHAueSAtIGVkZ2VTdGFydC55O1xuICAgICAgICBjb25zdCBzYSA9IGF4ICogYnkgLSBieCAqIGF5O1xuICAgICAgICBpZiAocC54ID09PSBlZGdlU3RhcnQueCAmJiBwLnkgPT09IGVkZ2VTdGFydC55KSB7XG4gICAgICAgICAgY2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTjtcbiAgICAgICAgICBjbGFzc2lmeVJlc3VsdC50ID0gMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAueCA9PT0gZWRnZUVuZC54ICYmIHAueSA9PT0gZWRnZUVuZC55KSB7XG4gICAgICAgICAgY2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkRFU1RJTkFUSU9OO1xuICAgICAgICAgIGNsYXNzaWZ5UmVzdWx0LnQgPSAxO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2EgPCAtTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuTEVGVDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuUklHSFQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheCAqIGJ4IDwgMCB8fCBheSAqIGJ5IDwgMCkge1xuICAgICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5CRUhJTkQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkpIDwgTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkge1xuICAgICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5CRVlPTkQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0O1xuICAgICAgICBpZiAoYXggIT09IDApIHtcbiAgICAgICAgICB0ID0gYnggLyBheDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gYnkgLyBheTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVUV0VFTjtcbiAgICAgICAgY2xhc3NpZnlSZXN1bHQudCA9IHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKHBhdGgxLCBwYXRoMikge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25zUmF3ID0gW107XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IHBhdGgxLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHBhdGgxRWRnZVN0YXJ0ID0gcGF0aDFbaW5kZXggLSAxXTtcbiAgICAgICAgICBjb25zdCBwYXRoMUVkZ2VFbmQgPSBwYXRoMVtpbmRleF07XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXgyID0gMTsgaW5kZXgyIDwgcGF0aDIubGVuZ3RoOyBpbmRleDIrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0aDJFZGdlU3RhcnQgPSBwYXRoMltpbmRleDIgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGgyRWRnZUVuZCA9IHBhdGgyW2luZGV4Ml07XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBmaW5kRWRnZUludGVyc2VjdGlvbihwYXRoMUVkZ2VTdGFydCwgcGF0aDFFZGdlRW5kLCBwYXRoMkVkZ2VTdGFydCwgcGF0aDJFZGdlRW5kKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IG51bGwgJiYgaW50ZXJzZWN0aW9uc1Jhdy5maW5kKFxuICAgICAgICAgICAgICAoaSkgPT4gaS50IDw9IGludGVyc2VjdGlvbi50ICsgTnVtYmVyLkVQU0lMT04gJiYgaS50ID49IGludGVyc2VjdGlvbi50IC0gTnVtYmVyLkVQU0lMT05cbiAgICAgICAgICAgICkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zUmF3LnB1c2goaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKG5ldyBWZWN0b3IyKGludGVyc2VjdGlvbi54LCBpbnRlcnNlY3Rpb24ueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNjYW5saW5lSW50ZXJzZWN0aW9ucyhzY2FubGluZSwgYm91bmRpbmdCb3gsIHBhdGhzKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmdldENlbnRlcihjZW50ZXIpO1xuICAgICAgICBjb25zdCBhbGxJbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICBpZiAocGF0aC5ib3VuZGluZ0JveC5jb250YWluc1BvaW50KGNlbnRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBnZXRJbnRlcnNlY3Rpb25zKHNjYW5saW5lLCBwYXRoLnBvaW50cyk7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgICAgYWxsSW50ZXJzZWN0aW9ucy5wdXNoKHsgaWRlbnRpZmllcjogcGF0aC5pZGVudGlmaWVyLCBpc0NXOiBwYXRoLmlzQ1csIHBvaW50OiBwIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWxsSW50ZXJzZWN0aW9ucy5zb3J0KChpMSwgaTIpID0+IHtcbiAgICAgICAgICByZXR1cm4gaTEucG9pbnQueCAtIGkyLnBvaW50Lng7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWxsSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGlzSG9sZVRvKHNpbXBsZVBhdGgsIGFsbFBhdGhzLCBzY2FubGluZU1pblgyLCBzY2FubGluZU1heFgyLCBfZmlsbFJ1bGUpIHtcbiAgICAgICAgaWYgKF9maWxsUnVsZSA9PT0gbnVsbCB8fCBfZmlsbFJ1bGUgPT09IHZvaWQgMCB8fCBfZmlsbFJ1bGUgPT09IFwiXCIpIHtcbiAgICAgICAgICBfZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZW50ZXJCb3VuZGluZ0JveCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIHNpbXBsZVBhdGguYm91bmRpbmdCb3guZ2V0Q2VudGVyKGNlbnRlckJvdW5kaW5nQm94KTtcbiAgICAgICAgY29uc3Qgc2NhbmxpbmUgPSBbXG4gICAgICAgICAgbmV3IFZlY3RvcjIoc2NhbmxpbmVNaW5YMiwgY2VudGVyQm91bmRpbmdCb3gueSksXG4gICAgICAgICAgbmV3IFZlY3RvcjIoc2NhbmxpbmVNYXhYMiwgY2VudGVyQm91bmRpbmdCb3gueSlcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgc2NhbmxpbmVJbnRlcnNlY3Rpb25zID0gZ2V0U2NhbmxpbmVJbnRlcnNlY3Rpb25zKHNjYW5saW5lLCBzaW1wbGVQYXRoLmJvdW5kaW5nQm94LCBhbGxQYXRocyk7XG4gICAgICAgIHNjYW5saW5lSW50ZXJzZWN0aW9ucy5zb3J0KChpMSwgaTIpID0+IHtcbiAgICAgICAgICByZXR1cm4gaTEucG9pbnQueCAtIGkyLnBvaW50Lng7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYXNlSW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBvdGhlckludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgc2NhbmxpbmVJbnRlcnNlY3Rpb25zLmZvckVhY2goKGkyKSA9PiB7XG4gICAgICAgICAgaWYgKGkyLmlkZW50aWZpZXIgPT09IHNpbXBsZVBhdGguaWRlbnRpZmllcikge1xuICAgICAgICAgICAgYmFzZUludGVyc2VjdGlvbnMucHVzaChpMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVySW50ZXJzZWN0aW9ucy5wdXNoKGkyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaXJzdFhPZlBhdGggPSBiYXNlSW50ZXJzZWN0aW9uc1swXS5wb2ludC54O1xuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgb3RoZXJJbnRlcnNlY3Rpb25zLmxlbmd0aCAmJiBvdGhlckludGVyc2VjdGlvbnNbaV0ucG9pbnQueCA8IGZpcnN0WE9mUGF0aCkge1xuICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBvdGhlckludGVyc2VjdGlvbnNbaV0uaWRlbnRpZmllcikge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gob3RoZXJJbnRlcnNlY3Rpb25zW2ldLmlkZW50aWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChzaW1wbGVQYXRoLmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoX2ZpbGxSdWxlID09PSBcImV2ZW5vZGRcIikge1xuICAgICAgICAgIGNvbnN0IGlzSG9sZSA9IHN0YWNrLmxlbmd0aCAlIDIgPT09IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgY29uc3QgaXNIb2xlRm9yID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgICAgcmV0dXJuIHsgaWRlbnRpZmllcjogc2ltcGxlUGF0aC5pZGVudGlmaWVyLCBpc0hvbGUsIGZvcjogaXNIb2xlRm9yIH07XG4gICAgICAgIH0gZWxzZSBpZiAoX2ZpbGxSdWxlID09PSBcIm5vbnplcm9cIikge1xuICAgICAgICAgIGxldCBpc0hvbGUgPSB0cnVlO1xuICAgICAgICAgIGxldCBpc0hvbGVGb3IgPSBudWxsO1xuICAgICAgICAgIGxldCBsYXN0Q1dWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHN0YWNrLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHN0YWNrW2kyXTtcbiAgICAgICAgICAgIGlmIChpc0hvbGUpIHtcbiAgICAgICAgICAgICAgbGFzdENXVmFsdWUgPSBhbGxQYXRoc1tpZGVudGlmaWVyXS5pc0NXO1xuICAgICAgICAgICAgICBpc0hvbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaXNIb2xlRm9yID0gaWRlbnRpZmllcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdENXVmFsdWUgIT09IGFsbFBhdGhzW2lkZW50aWZpZXJdLmlzQ1cpIHtcbiAgICAgICAgICAgICAgbGFzdENXVmFsdWUgPSBhbGxQYXRoc1tpZGVudGlmaWVyXS5pc0NXO1xuICAgICAgICAgICAgICBpc0hvbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBpZGVudGlmaWVyOiBzaW1wbGVQYXRoLmlkZW50aWZpZXIsIGlzSG9sZSwgZm9yOiBpc0hvbGVGb3IgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZpbGwtcnVsZTogXCInICsgX2ZpbGxSdWxlICsgJ1wiIGlzIGN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBzY2FubGluZU1pblggPSBCSUdOVU1CRVI7XG4gICAgICBsZXQgc2NhbmxpbmVNYXhYID0gLUJJR05VTUJFUjtcbiAgICAgIGxldCBzaW1wbGVQYXRocyA9IHNoYXBlUGF0aC5zdWJQYXRocy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gcC5nZXRQb2ludHMoKTtcbiAgICAgICAgbGV0IG1heFkgPSAtQklHTlVNQkVSO1xuICAgICAgICBsZXQgbWluWSA9IEJJR05VTUJFUjtcbiAgICAgICAgbGV0IG1heFggPSAtQklHTlVNQkVSO1xuICAgICAgICBsZXQgbWluWCA9IEJJR05VTUJFUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwMiA9IHBvaW50c1tpXTtcbiAgICAgICAgICBpZiAocDIueSA+IG1heFkpIHtcbiAgICAgICAgICAgIG1heFkgPSBwMi55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocDIueSA8IG1pblkpIHtcbiAgICAgICAgICAgIG1pblkgPSBwMi55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocDIueCA+IG1heFgpIHtcbiAgICAgICAgICAgIG1heFggPSBwMi54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocDIueCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSBwMi54O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbmxpbmVNYXhYIDw9IG1heFgpIHtcbiAgICAgICAgICBzY2FubGluZU1heFggPSBtYXhYICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbmxpbmVNaW5YID49IG1pblgpIHtcbiAgICAgICAgICBzY2FubGluZU1pblggPSBtaW5YIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGN1cnZlczogcC5jdXJ2ZXMsXG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIGlzQ1c6IFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UocG9pbnRzKSxcbiAgICAgICAgICBpZGVudGlmaWVyOiAtMSxcbiAgICAgICAgICBib3VuZGluZ0JveDogbmV3IEJveDIobmV3IFZlY3RvcjIobWluWCwgbWluWSksIG5ldyBWZWN0b3IyKG1heFgsIG1heFkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBzaW1wbGVQYXRocyA9IHNpbXBsZVBhdGhzLmZpbHRlcigoc3ApID0+IHNwLnBvaW50cy5sZW5ndGggPiAxKTtcbiAgICAgIGZvciAobGV0IGlkZW50aWZpZXIgPSAwOyBpZGVudGlmaWVyIDwgc2ltcGxlUGF0aHMubGVuZ3RoOyBpZGVudGlmaWVyKyspIHtcbiAgICAgICAgc2ltcGxlUGF0aHNbaWRlbnRpZmllcl0uaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0FIb2xlID0gc2ltcGxlUGF0aHMubWFwKFxuICAgICAgICAocCkgPT4gaXNIb2xlVG8oXG4gICAgICAgICAgcCxcbiAgICAgICAgICBzaW1wbGVQYXRocyxcbiAgICAgICAgICBzY2FubGluZU1pblgsXG4gICAgICAgICAgc2NhbmxpbmVNYXhYLFxuICAgICAgICAgIHNoYXBlUGF0aC51c2VyRGF0YSA/IHNoYXBlUGF0aC51c2VyRGF0YS5zdHlsZS5maWxsUnVsZSA6IHZvaWQgMFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgY29uc3Qgc2hhcGVzVG9SZXR1cm4gPSBbXTtcbiAgICAgIHNpbXBsZVBhdGhzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgY29uc3QgYW1JQUhvbGUgPSBpc0FIb2xlW3AuaWRlbnRpZmllcl07XG4gICAgICAgIGlmICghYW1JQUhvbGUuaXNIb2xlKSB7XG4gICAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKTtcbiAgICAgICAgICBzaGFwZS5jdXJ2ZXMgPSBwLmN1cnZlcztcbiAgICAgICAgICBjb25zdCBob2xlcyA9IGlzQUhvbGUuZmlsdGVyKChoKSA9PiBoLmlzSG9sZSAmJiBoLmZvciA9PT0gcC5pZGVudGlmaWVyKTtcbiAgICAgICAgICBob2xlcy5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob2xlID0gc2ltcGxlUGF0aHNbaC5pZGVudGlmaWVyXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aCgpO1xuICAgICAgICAgICAgcGF0aC5jdXJ2ZXMgPSBob2xlLmN1cnZlcztcbiAgICAgICAgICAgIHNoYXBlLmhvbGVzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2hhcGVzVG9SZXR1cm4ucHVzaChzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNoYXBlc1RvUmV0dXJuO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U3Ryb2tlU3R5bGUod2lkdGgsIGNvbG9yLCBsaW5lSm9pbiwgbGluZUNhcCwgbWl0ZXJMaW1pdCkge1xuICAgICAgd2lkdGggPSB3aWR0aCAhPT0gdm9pZCAwID8gd2lkdGggOiAxO1xuICAgICAgY29sb3IgPSBjb2xvciAhPT0gdm9pZCAwID8gY29sb3IgOiBcIiMwMDBcIjtcbiAgICAgIGxpbmVKb2luID0gbGluZUpvaW4gIT09IHZvaWQgMCA/IGxpbmVKb2luIDogXCJtaXRlclwiO1xuICAgICAgbGluZUNhcCA9IGxpbmVDYXAgIT09IHZvaWQgMCA/IGxpbmVDYXAgOiBcImJ1dHRcIjtcbiAgICAgIG1pdGVyTGltaXQgPSBtaXRlckxpbWl0ICE9PSB2b2lkIDAgPyBtaXRlckxpbWl0IDogNDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogbGluZUpvaW4sXG4gICAgICAgIHN0cm9rZUxpbmVDYXA6IGxpbmVDYXAsXG4gICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6IG1pdGVyTGltaXRcbiAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBwb2ludHNUb1N0cm9rZShwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlKSB7XG4gICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgY29uc3Qgbm9ybWFscyA9IFtdO1xuICAgICAgY29uc3QgdXZzID0gW107XG4gICAgICBpZiAoU1ZHTG9hZGVyMi5wb2ludHNUb1N0cm9rZVdpdGhCdWZmZXJzKHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UsIHZlcnRpY2VzLCBub3JtYWxzLCB1dnMpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwidXZcIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG4gICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgfVxuICAgIHN0YXRpYyBwb2ludHNUb1N0cm9rZVdpdGhCdWZmZXJzKHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UsIHZlcnRpY2VzLCBub3JtYWxzLCB1dnMsIHZlcnRleE9mZnNldCkge1xuICAgICAgY29uc3QgdGVtcFYyXzEgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYyXzIgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYyXzMgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYyXzQgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYyXzUgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYyXzYgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgdGVtcFYyXzcgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgbGFzdFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBsYXN0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IHBvaW50MEwgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgcG9pbnQwUiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBjdXJyZW50UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgbmV4dFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBuZXh0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGNvbnN0IGlubmVyUG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3Qgb3V0ZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBhcmNEaXZpc2lvbnMgPSBhcmNEaXZpc2lvbnMgIT09IHZvaWQgMCA/IGFyY0RpdmlzaW9ucyA6IDEyO1xuICAgICAgbWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZSAhPT0gdm9pZCAwID8gbWluRGlzdGFuY2UgOiAxZS0zO1xuICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4T2Zmc2V0ICE9PSB2b2lkIDAgPyB2ZXJ0ZXhPZmZzZXQgOiAwO1xuICAgICAgcG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyhwb2ludHMpO1xuICAgICAgY29uc3QgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIGlmIChudW1Qb2ludHMgPCAyKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNvbnN0IGlzQ2xvc2VkID0gcG9pbnRzWzBdLmVxdWFscyhwb2ludHNbbnVtUG9pbnRzIC0gMV0pO1xuICAgICAgbGV0IGN1cnJlbnRQb2ludDtcbiAgICAgIGxldCBwcmV2aW91c1BvaW50ID0gcG9pbnRzWzBdO1xuICAgICAgbGV0IG5leHRQb2ludDtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoMiA9IHN0eWxlLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGRlbHRhVSA9IDEgLyAobnVtUG9pbnRzIC0gMSk7XG4gICAgICBsZXQgdTAgPSAwLCB1MTtcbiAgICAgIGxldCBpbm5lclNpZGVNb2RpZmllZDtcbiAgICAgIGxldCBqb2luSXNPbkxlZnRTaWRlO1xuICAgICAgbGV0IGlzTWl0ZXI7XG4gICAgICBsZXQgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcbiAgICAgIGxldCBudW1WZXJ0aWNlcyA9IDA7XG4gICAgICBsZXQgY3VycmVudENvb3JkaW5hdGUgPSB2ZXJ0ZXhPZmZzZXQgKiAzO1xuICAgICAgbGV0IGN1cnJlbnRDb29yZGluYXRlVVYgPSB2ZXJ0ZXhPZmZzZXQgKiAyO1xuICAgICAgZ2V0Tm9ybWFsKHBvaW50c1swXSwgcG9pbnRzWzFdLCB0ZW1wVjJfMSkubXVsdGlwbHlTY2FsYXIoc3Ryb2tlV2lkdGgyKTtcbiAgICAgIGxhc3RQb2ludEwuY29weShwb2ludHNbMF0pLnN1Yih0ZW1wVjJfMSk7XG4gICAgICBsYXN0UG9pbnRSLmNvcHkocG9pbnRzWzBdKS5hZGQodGVtcFYyXzEpO1xuICAgICAgcG9pbnQwTC5jb3B5KGxhc3RQb2ludEwpO1xuICAgICAgcG9pbnQwUi5jb3B5KGxhc3RQb2ludFIpO1xuICAgICAgZm9yIChsZXQgaVBvaW50ID0gMTsgaVBvaW50IDwgbnVtUG9pbnRzOyBpUG9pbnQrKykge1xuICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbaVBvaW50XTtcbiAgICAgICAgaWYgKGlQb2ludCA9PT0gbnVtUG9pbnRzIC0gMSkge1xuICAgICAgICAgIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWzFdO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgbmV4dFBvaW50ID0gdm9pZCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpUG9pbnQgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWwxID0gdGVtcFYyXzE7XG4gICAgICAgIGdldE5vcm1hbChwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5vcm1hbDEpO1xuICAgICAgICB0ZW1wVjJfMy5jb3B5KG5vcm1hbDEpLm11bHRpcGx5U2NhbGFyKHN0cm9rZVdpZHRoMik7XG4gICAgICAgIGN1cnJlbnRQb2ludEwuY29weShjdXJyZW50UG9pbnQpLnN1Yih0ZW1wVjJfMyk7XG4gICAgICAgIGN1cnJlbnRQb2ludFIuY29weShjdXJyZW50UG9pbnQpLmFkZCh0ZW1wVjJfMyk7XG4gICAgICAgIHUxID0gdTAgKyBkZWx0YVU7XG4gICAgICAgIGlubmVyU2lkZU1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIGlmIChuZXh0UG9pbnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGdldE5vcm1hbChjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgdGVtcFYyXzIpO1xuICAgICAgICAgIHRlbXBWMl8zLmNvcHkodGVtcFYyXzIpLm11bHRpcGx5U2NhbGFyKHN0cm9rZVdpZHRoMik7XG4gICAgICAgICAgbmV4dFBvaW50TC5jb3B5KGN1cnJlbnRQb2ludCkuc3ViKHRlbXBWMl8zKTtcbiAgICAgICAgICBuZXh0UG9pbnRSLmNvcHkoY3VycmVudFBvaW50KS5hZGQodGVtcFYyXzMpO1xuICAgICAgICAgIGpvaW5Jc09uTGVmdFNpZGUgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWMl8zLnN1YlZlY3RvcnMobmV4dFBvaW50LCBwcmV2aW91c1BvaW50KTtcbiAgICAgICAgICBpZiAobm9ybWFsMS5kb3QodGVtcFYyXzMpIDwgMCkge1xuICAgICAgICAgICAgam9pbklzT25MZWZ0U2lkZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaVBvaW50ID09PSAxKVxuICAgICAgICAgICAgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgPSBqb2luSXNPbkxlZnRTaWRlO1xuICAgICAgICAgIHRlbXBWMl8zLnN1YlZlY3RvcnMobmV4dFBvaW50LCBjdXJyZW50UG9pbnQpO1xuICAgICAgICAgIHRlbXBWMl8zLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIGNvbnN0IGRvdCA9IE1hdGguYWJzKG5vcm1hbDEuZG90KHRlbXBWMl8zKSk7XG4gICAgICAgICAgaWYgKGRvdCA+IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgICAgICBjb25zdCBtaXRlclNpZGUgPSBzdHJva2VXaWR0aDIgLyBkb3Q7XG4gICAgICAgICAgICB0ZW1wVjJfMy5tdWx0aXBseVNjYWxhcigtbWl0ZXJTaWRlKTtcbiAgICAgICAgICAgIHRlbXBWMl80LnN1YlZlY3RvcnMoY3VycmVudFBvaW50LCBwcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgIHRlbXBWMl81LmNvcHkodGVtcFYyXzQpLnNldExlbmd0aChtaXRlclNpZGUpLmFkZCh0ZW1wVjJfMyk7XG4gICAgICAgICAgICBpbm5lclBvaW50LmNvcHkodGVtcFYyXzUpLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgY29uc3QgbWl0ZXJMZW5ndGgyID0gdGVtcFYyXzUubGVuZ3RoKCk7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50TGVuZ3RoUHJldiA9IHRlbXBWMl80Lmxlbmd0aCgpO1xuICAgICAgICAgICAgdGVtcFYyXzQuZGl2aWRlU2NhbGFyKHNlZ21lbnRMZW5ndGhQcmV2KTtcbiAgICAgICAgICAgIHRlbXBWMl82LnN1YlZlY3RvcnMobmV4dFBvaW50LCBjdXJyZW50UG9pbnQpO1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudExlbmd0aE5leHQgPSB0ZW1wVjJfNi5sZW5ndGgoKTtcbiAgICAgICAgICAgIHRlbXBWMl82LmRpdmlkZVNjYWxhcihzZWdtZW50TGVuZ3RoTmV4dCk7XG4gICAgICAgICAgICBpZiAodGVtcFYyXzQuZG90KGlubmVyUG9pbnQpIDwgc2VnbWVudExlbmd0aFByZXYgJiYgdGVtcFYyXzYuZG90KGlubmVyUG9pbnQpIDwgc2VnbWVudExlbmd0aE5leHQpIHtcbiAgICAgICAgICAgICAgaW5uZXJTaWRlTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ZXJQb2ludC5jb3B5KHRlbXBWMl81KS5hZGQoY3VycmVudFBvaW50KTtcbiAgICAgICAgICAgIGlubmVyUG9pbnQuYWRkKGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgICBpc01pdGVyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaW5uZXJTaWRlTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnRSLmNvcHkoaW5uZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50Ui5jb3B5KGlubmVyUG9pbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRQb2ludEwuY29weShpbm5lclBvaW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRMLmNvcHkoaW5uZXJQb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHN0eWxlLnN0cm9rZUxpbmVKb2luKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJiZXZlbFwiOlxuICAgICAgICAgICAgICAgIG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbihqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgICAgICAgICAgICBjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICBtYWtlQ2lyY3VsYXJTZWN0b3IoY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBuZXh0UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1ha2VDaXJjdWxhclNlY3RvcihjdXJyZW50UG9pbnQsIG5leHRQb2ludFIsIGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtaXRlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwibWl0ZXItY2xpcFwiOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IG1pdGVyRnJhY3Rpb24gPSBzdHJva2VXaWR0aDIgKiBzdHlsZS5zdHJva2VNaXRlckxpbWl0IC8gbWl0ZXJMZW5ndGgyO1xuICAgICAgICAgICAgICAgIGlmIChtaXRlckZyYWN0aW9uIDwgMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZUxpbmVKb2luICE9PSBcIm1pdGVyLWNsaXBcIikge1xuICAgICAgICAgICAgICAgICAgICBtYWtlU2VnbWVudFdpdGhCZXZlbEpvaW4oam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBWMl82LnN1YlZlY3RvcnMob3V0ZXJQb2ludCwgY3VycmVudFBvaW50TCkubXVsdGlwbHlTY2FsYXIobWl0ZXJGcmFjdGlvbikuYWRkKGN1cnJlbnRQb2ludEwpO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBWMl83LnN1YlZlY3RvcnMob3V0ZXJQb2ludCwgbmV4dFBvaW50TCkubXVsdGlwbHlTY2FsYXIobWl0ZXJGcmFjdGlvbikuYWRkKG5leHRQb2ludEwpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl82LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl82LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl83LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl83LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wVjJfNi5zdWJWZWN0b3JzKG91dGVyUG9pbnQsIGN1cnJlbnRQb2ludFIpLm11bHRpcGx5U2NhbGFyKG1pdGVyRnJhY3Rpb24pLmFkZChjdXJyZW50UG9pbnRSKTtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wVjJfNy5zdWJWZWN0b3JzKG91dGVyUG9pbnQsIG5leHRQb2ludFIpLm11bHRpcGx5U2NhbGFyKG1pdGVyRnJhY3Rpb24pLmFkZChuZXh0UG9pbnRSKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNywgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNywgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGlubmVyU2lkZU1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnRMLmNvcHkob3V0ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50Ui5jb3B5KG91dGVyUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG91dGVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNNaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDbG9zZWQgJiYgaVBvaW50ID09PSBudW1Qb2ludHMgLSAxKSB7XG4gICAgICAgICAgYWRkQ2FwR2VvbWV0cnkocG9pbnRzWzBdLCBwb2ludDBMLCBwb2ludDBSLCBqb2luSXNPbkxlZnRTaWRlLCB0cnVlLCB1MCk7XG4gICAgICAgIH1cbiAgICAgICAgdTAgPSB1MTtcbiAgICAgICAgcHJldmlvdXNQb2ludCA9IGN1cnJlbnRQb2ludDtcbiAgICAgICAgbGFzdFBvaW50TC5jb3B5KG5leHRQb2ludEwpO1xuICAgICAgICBsYXN0UG9pbnRSLmNvcHkobmV4dFBvaW50Uik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ2xvc2VkKSB7XG4gICAgICAgIGFkZENhcEdlb21ldHJ5KGN1cnJlbnRQb2ludCwgY3VycmVudFBvaW50TCwgY3VycmVudFBvaW50Uiwgam9pbklzT25MZWZ0U2lkZSwgZmFsc2UsIHUxKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJTaWRlTW9kaWZpZWQgJiYgdmVydGljZXMpIHtcbiAgICAgICAgbGV0IGxhc3RPdXRlciA9IG91dGVyUG9pbnQ7XG4gICAgICAgIGxldCBsYXN0SW5uZXIgPSBpbm5lclBvaW50O1xuICAgICAgICBpZiAoaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgIT09IGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICBsYXN0T3V0ZXIgPSBpbm5lclBvaW50O1xuICAgICAgICAgIGxhc3RJbm5lciA9IG91dGVyUG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICBpZiAoaXNNaXRlciB8fCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgbGFzdElubmVyLnRvQXJyYXkodmVydGljZXMsIDAgKiAzKTtcbiAgICAgICAgICAgIGxhc3RJbm5lci50b0FycmF5KHZlcnRpY2VzLCAzICogMyk7XG4gICAgICAgICAgICBpZiAoaXNNaXRlcikge1xuICAgICAgICAgICAgICBsYXN0T3V0ZXIudG9BcnJheSh2ZXJ0aWNlcywgMSAqIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNNaXRlciB8fCAhaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgIGxhc3RJbm5lci50b0FycmF5KHZlcnRpY2VzLCAxICogMyk7XG4gICAgICAgICAgICBsYXN0SW5uZXIudG9BcnJheSh2ZXJ0aWNlcywgMyAqIDMpO1xuICAgICAgICAgICAgaWYgKGlzTWl0ZXIpIHtcbiAgICAgICAgICAgICAgbGFzdE91dGVyLnRvQXJyYXkodmVydGljZXMsIDAgKiAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1WZXJ0aWNlcztcbiAgICAgIGZ1bmN0aW9uIGdldE5vcm1hbChwMSwgcDIsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuc3ViVmVjdG9ycyhwMiwgcDEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnNldCgtcmVzdWx0LnksIHJlc3VsdC54KS5ub3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFkZFZlcnRleChwb3NpdGlvbiwgdSwgdikge1xuICAgICAgICBpZiAodmVydGljZXMpIHtcbiAgICAgICAgICB2ZXJ0aWNlc1tjdXJyZW50Q29vcmRpbmF0ZV0gPSBwb3NpdGlvbi54O1xuICAgICAgICAgIHZlcnRpY2VzW2N1cnJlbnRDb29yZGluYXRlICsgMV0gPSBwb3NpdGlvbi55O1xuICAgICAgICAgIHZlcnRpY2VzW2N1cnJlbnRDb29yZGluYXRlICsgMl0gPSAwO1xuICAgICAgICAgIGlmIChub3JtYWxzKSB7XG4gICAgICAgICAgICBub3JtYWxzW2N1cnJlbnRDb29yZGluYXRlXSA9IDA7XG4gICAgICAgICAgICBub3JtYWxzW2N1cnJlbnRDb29yZGluYXRlICsgMV0gPSAwO1xuICAgICAgICAgICAgbm9ybWFsc1tjdXJyZW50Q29vcmRpbmF0ZSArIDJdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudENvb3JkaW5hdGUgKz0gMztcbiAgICAgICAgICBpZiAodXZzKSB7XG4gICAgICAgICAgICB1dnNbY3VycmVudENvb3JkaW5hdGVVVl0gPSB1O1xuICAgICAgICAgICAgdXZzW2N1cnJlbnRDb29yZGluYXRlVVYgKyAxXSA9IHY7XG4gICAgICAgICAgICBjdXJyZW50Q29vcmRpbmF0ZVVWICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bVZlcnRpY2VzICs9IDM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYWtlQ2lyY3VsYXJTZWN0b3IoY2VudGVyLCBwMSwgcDIsIHUsIHYpIHtcbiAgICAgICAgdGVtcFYyXzEuY29weShwMSkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHRlbXBWMl8yLmNvcHkocDIpLnN1YihjZW50ZXIpLm5vcm1hbGl6ZSgpO1xuICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLlBJO1xuICAgICAgICBjb25zdCBkb3QgPSB0ZW1wVjJfMS5kb3QodGVtcFYyXzIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZG90KSA8IDEpXG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmFicyhNYXRoLmFjb3MoZG90KSk7XG4gICAgICAgIGFuZ2xlIC89IGFyY0RpdmlzaW9ucztcbiAgICAgICAgdGVtcFYyXzMuY29weShwMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGFyY0RpdmlzaW9ucyAtIDE7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgdGVtcFYyXzQuY29weSh0ZW1wVjJfMykucm90YXRlQXJvdW5kKGNlbnRlciwgYW5nbGUpO1xuICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfMywgdSwgdik7XG4gICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl80LCB1LCB2KTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY2VudGVyLCB1LCAwLjUpO1xuICAgICAgICAgIHRlbXBWMl8zLmNvcHkodGVtcFYyXzQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNCwgdSwgdik7XG4gICAgICAgIGFkZFZlcnRleChwMiwgdSwgdik7XG4gICAgICAgIGFkZFZlcnRleChjZW50ZXIsIHUsIDAuNSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYWtlU2VnbWVudFRyaWFuZ2xlcygpIHtcbiAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbihqb2luSXNPbkxlZnRTaWRlMiwgaW5uZXJTaWRlTW9kaWZpZWQyLCB1KSB7XG4gICAgICAgIGlmIChpbm5lclNpZGVNb2RpZmllZDIpIHtcbiAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZTIpIHtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1LCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1LCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1LCAwLjUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdSwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50UiwgdSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlMikge1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludEwsIHUsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdSwgMC41KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUsIDEpO1xuICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludFIsIHUsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdSwgMC41KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbihqb2luSXNPbkxlZnRTaWRlMiwgaW5uZXJTaWRlTW9kaWZpZWQyKSB7XG4gICAgICAgIGlmIChpbm5lclNpZGVNb2RpZmllZDIpIHtcbiAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZTIpIHtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFkZENhcEdlb21ldHJ5KGNlbnRlciwgcDEsIHAyLCBqb2luSXNPbkxlZnRTaWRlMiwgc3RhcnQsIHUpIHtcbiAgICAgICAgc3dpdGNoIChzdHlsZS5zdHJva2VMaW5lQ2FwKSB7XG4gICAgICAgICAgY2FzZSBcInJvdW5kXCI6XG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgbWFrZUNpcmN1bGFyU2VjdG9yKGNlbnRlciwgcDIsIHAxLCB1LCAwLjUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFrZUNpcmN1bGFyU2VjdG9yKGNlbnRlciwgcDEsIHAyLCB1LCAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgIHRlbXBWMl8xLnN1YlZlY3RvcnMocDEsIGNlbnRlcik7XG4gICAgICAgICAgICAgIHRlbXBWMl8yLnNldCh0ZW1wVjJfMS55LCAtdGVtcFYyXzEueCk7XG4gICAgICAgICAgICAgIHRlbXBWMl8zLmFkZFZlY3RvcnModGVtcFYyXzEsIHRlbXBWMl8yKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzQuc3ViVmVjdG9ycyh0ZW1wVjJfMiwgdGVtcFYyXzEpLmFkZChjZW50ZXIpO1xuICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZTIpIHtcbiAgICAgICAgICAgICAgICB0ZW1wVjJfMy50b0FycmF5KHZlcnRpY2VzLCAxICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgMCAqIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIDMgKiAzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wVjJfMy50b0FycmF5KHZlcnRpY2VzLCAxICogMyk7XG4gICAgICAgICAgICAgICAgdXZzWzMgKiAyICsgMV0gPT09IDEgPyB0ZW1wVjJfNC50b0FycmF5KHZlcnRpY2VzLCAzICogMykgOiB0ZW1wVjJfMy50b0FycmF5KHZlcnRpY2VzLCAzICogMyk7XG4gICAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgMCAqIDMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZW1wVjJfMS5zdWJWZWN0b3JzKHAyLCBjZW50ZXIpO1xuICAgICAgICAgICAgICB0ZW1wVjJfMi5zZXQodGVtcFYyXzEueSwgLXRlbXBWMl8xLngpO1xuICAgICAgICAgICAgICB0ZW1wVjJfMy5hZGRWZWN0b3JzKHRlbXBWMl8xLCB0ZW1wVjJfMikuYWRkKGNlbnRlcik7XG4gICAgICAgICAgICAgIHRlbXBWMl80LnN1YlZlY3RvcnModGVtcFYyXzIsIHRlbXBWMl8xKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgICAgY29uc3QgdmwgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlMikge1xuICAgICAgICAgICAgICAgIHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIHZsIC0gMSAqIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIHZsIC0gMiAqIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIHZsIC0gNCAqIDMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIHZsIC0gMiAqIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIHZsIC0gMSAqIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIHZsIC0gNCAqIDMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyhwb2ludHMyKSB7XG4gICAgICAgIGxldCBkdXBQb2ludHMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSBwb2ludHMyLmxlbmd0aCAtIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBpZiAocG9pbnRzMltpXS5kaXN0YW5jZVRvKHBvaW50czJbaSArIDFdKSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICBkdXBQb2ludHMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZHVwUG9pbnRzKVxuICAgICAgICAgIHJldHVybiBwb2ludHMyO1xuICAgICAgICBjb25zdCBuZXdQb2ludHMgPSBbXTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnRzMlswXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBuID0gcG9pbnRzMi5sZW5ndGggLSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvaW50czJbaV0uZGlzdGFuY2VUbyhwb2ludHMyW2kgKyAxXSkgPj0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50czJbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludHMyW3BvaW50czIubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU1ZHTG9hZGVyMjtcbn0pKCk7XG5leHBvcnQge1xuICBTVkdMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TVkdMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/SVGLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/postprocessing/Pass.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/postprocessing/Pass.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FullScreenQuad: () => (/* binding */ FullScreenQuad),\n/* harmony export */   Pass: () => (/* binding */ Pass)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\nclass Pass {\n  constructor() {\n    // if set to true, the pass is processed by the composer\n    __publicField(this, \"enabled\", true);\n    // if set to true, the pass indicates to swap read and write buffer after rendering\n    __publicField(this, \"needsSwap\", true);\n    // if set to true, the pass clears its buffer before rendering\n    __publicField(this, \"clear\", false);\n    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n    __publicField(this, \"renderToScreen\", false);\n  }\n  setSize(width, height) {\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n  }\n  dispose() {\n  }\n}\nclass FullScreenQuad {\n  constructor(material) {\n    __publicField(this, \"camera\", new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-1, 1, 1, -1, 0, 1));\n    __publicField(this, \"geometry\", new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(2, 2));\n    __publicField(this, \"mesh\");\n    this.mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, material);\n  }\n  get material() {\n    return this.mesh.material;\n  }\n  set material(value) {\n    this.mesh.material = value;\n  }\n  dispose() {\n    this.mesh.geometry.dispose();\n  }\n  render(renderer) {\n    renderer.render(this.mesh, this.camera);\n  }\n}\n\n//# sourceMappingURL=Pass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3Bvc3Rwcm9jZXNzaW5nL1Bhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ2dFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxREFBa0I7QUFDeEQsd0NBQXdDLGdEQUFhO0FBQ3JEO0FBQ0Esb0JBQW9CLHVDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxccG9zdHByb2Nlc3NpbmdcXFBhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhLCBQbGFuZUdlb21ldHJ5LCBNZXNoIH0gZnJvbSBcInRocmVlXCI7XG5jbGFzcyBQYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gaWYgc2V0IHRvIHRydWUsIHRoZSBwYXNzIGlzIHByb2Nlc3NlZCBieSB0aGUgY29tcG9zZXJcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5hYmxlZFwiLCB0cnVlKTtcbiAgICAvLyBpZiBzZXQgdG8gdHJ1ZSwgdGhlIHBhc3MgaW5kaWNhdGVzIHRvIHN3YXAgcmVhZCBhbmQgd3JpdGUgYnVmZmVyIGFmdGVyIHJlbmRlcmluZ1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuZWVkc1N3YXBcIiwgdHJ1ZSk7XG4gICAgLy8gaWYgc2V0IHRvIHRydWUsIHRoZSBwYXNzIGNsZWFycyBpdHMgYnVmZmVyIGJlZm9yZSByZW5kZXJpbmdcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2xlYXJcIiwgZmFsc2UpO1xuICAgIC8vIGlmIHNldCB0byB0cnVlLCB0aGUgcmVzdWx0IG9mIHRoZSBwYXNzIGlzIHJlbmRlcmVkIHRvIHNjcmVlbi4gVGhpcyBpcyBzZXQgYXV0b21hdGljYWxseSBieSBFZmZlY3RDb21wb3Nlci5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVuZGVyVG9TY3JlZW5cIiwgZmFsc2UpO1xuICB9XG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICB9XG4gIHJlbmRlcihyZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhVGltZSwgbWFza0FjdGl2ZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5QYXNzOiAucmVuZGVyKCkgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBkZXJpdmVkIHBhc3MuXCIpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gIH1cbn1cbmNsYXNzIEZ1bGxTY3JlZW5RdWFkIHtcbiAgY29uc3RydWN0b3IobWF0ZXJpYWwpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FtZXJhXCIsIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLCAxKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdlb21ldHJ5XCIsIG5ldyBQbGFuZUdlb21ldHJ5KDIsIDIpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWVzaFwiKTtcbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gIH1cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1lc2gubWF0ZXJpYWw7XG4gIH1cbiAgc2V0IG1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdmFsdWU7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLm1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG4gIHJlbmRlcihyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLm1lc2gsIHRoaXMuY2FtZXJhKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgRnVsbFNjcmVlblF1YWQsXG4gIFBhc3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXNzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/postprocessing/Pass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxMRU5PVk9cXERvY3VtZW50c1xcZ2l0aHViXFx6aWtyaWFuYmlhLmdpdGh1Yi5pb1xcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXHR5cGVzXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXNCO0FBQzdELHFDQUFxQyx5REFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU8sUUFBUSwwQ0FBTyxRQUFRLDBDQUFPO0FBQzFELHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBZTtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxMRU5PVk9cXERvY3VtZW50c1xcZ2l0aHViXFx6aWtyaWFuYmlhLmdpdGh1Yi5pb1xcbm9kZV9tb2R1bGVzXFx0aHJlZS1zdGRsaWJcXHV0aWxzXFxCdWZmZXJHZW9tZXRyeVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVHJpYW5nbGVzRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVmVjdG9yMywgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZ2V0V2l0aEtleSB9IGZyb20gXCIuLi90eXBlcy9oZWxwZXJzLmpzXCI7XG5jb25zdCBtZXJnZUJ1ZmZlckdlb21ldHJpZXMgPSAoZ2VvbWV0cmllcywgdXNlR3JvdXBzKSA9PiB7XG4gIGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbMF0uaW5kZXggIT09IG51bGw7XG4gIGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLmF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5tb3JwaEF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyaWVzWzBdLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tLCBpKSA9PiB7XG4gICAgbGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgaWYgKGlzSW5kZXhlZCAhPT0gKGdlb20uaW5kZXggIT09IG51bGwpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIGluZGV4IGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20uYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyAnLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20uYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBhdHRyaWJ1dGVzQ291bnQrKztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSAhPT0gZ2VvbS5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIC5tb3JwaFRhcmdldHNSZWxhdGl2ZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20ubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIW1vcnBoQXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuICAubW9ycGhBdHRyaWJ1dGVzIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKVxuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20ubW9ycGhBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgPSBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSB8fCBbXTtcbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YS5wdXNoKGdlb20udXNlckRhdGEpO1xuICAgIGlmICh1c2VHcm91cHMpIHtcbiAgICAgIGxldCBjb3VudDtcbiAgICAgIGlmIChnZW9tLmluZGV4KSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5pbmRleC5jb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZVwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAob2Zmc2V0LCBjb3VudCwgaSk7XG4gICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGlzSW5kZXhlZCkge1xuICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG4gICAgY29uc3QgbWVyZ2VkSW5kZXggPSBbXTtcbiAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbS5pbmRleDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsraikge1xuICAgICAgICBtZXJnZWRJbmRleC5wdXNoKGluZGV4LmdldFgoaikgKyBpbmRleE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRleE9mZnNldCArPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgfSk7XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0SW5kZXgobWVyZ2VkSW5kZXgpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAoIW1lcmdlZEF0dHJpYnV0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgYXR0cmlidXRlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBtZXJnZWRBdHRyaWJ1dGUpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdWzBdLmxlbmd0aDtcbiAgICBpZiAobnVtTW9ycGhUYXJnZXRzID09PSAwKVxuICAgICAgYnJlYWs7XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzID0gbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyArK2kpIHtcbiAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UucHVzaChtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal1baV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMobW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSk7XG4gICAgICBpZiAoIW1lcmdlZE1vcnBoQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgbW9ycGhBdHRyaWJ1dGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChtZXJnZWRNb3JwaEF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRHZW9tZXRyeTtcbn07XG5jb25zdCBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGl0ZW1TaXplID0gdm9pZCAwO1xuICBsZXQgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgVHlwZWRBcnJheSA9IGF0dHIuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGl0ZW1TaXplID09PSB2b2lkIDApXG4gICAgICBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG4gICAgaWYgKGl0ZW1TaXplICE9PSBhdHRyLml0ZW1TaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMClcbiAgICAgIG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IGF0dHIubm9ybWFsaXplZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gIH0pO1xuICBpZiAoVHlwZWRBcnJheSAmJiBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgYXJyYXkuc2V0KGF0dHIuYXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxufTtcbmNvbnN0IGludGVybGVhdmVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKVxuICAgICAgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHJpYnV0ZS5hcnJheS5sZW5ndGg7XG4gICAgc3RyaWRlICs9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgfVxuICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCksIHN0cmlkZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGNvbnN0IHNldHRlcnMgPSBbXCJzZXRYXCIsIFwic2V0WVwiLCBcInNldFpcIiwgXCJzZXRXXCJdO1xuICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICBjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcbiAgICBjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXMucHVzaChpYmEpO1xuICAgIG9mZnNldCArPSBpdGVtU2l6ZTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRXaXRoS2V5KGliYSwgc2V0dGVyc1trXSk7XG4gICAgICAgIGNvbnN0IGdldCA9IGdldFdpdGhLZXkoYXR0cmlidXRlLCBnZXR0ZXJzW2tdKTtcbiAgICAgICAgc2V0KGMsIGdldChjKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlc1VzZWQoZ2VvbWV0cnkpIHtcbiAgbGV0IG1lbSA9IDA7XG4gIGZvciAobGV0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgbWVtICs9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50ICogaW5kaWNlcy5pdGVtU2l6ZSAqIGluZGljZXMuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuICByZXR1cm4gbWVtO1xufVxuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSwgdG9sZXJhbmNlID0gMWUtNCkge1xuICB0b2xlcmFuY2UgPSBNYXRoLm1heCh0b2xlcmFuY2UsIE51bWJlci5FUFNJTE9OKTtcbiAgY29uc3QgaGFzaFRvSW5kZXggPSB7fTtcbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50O1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgY29uc3QgYXR0ckFycmF5cyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJzQXJyYXlzID0ge307XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGF0dHJBcnJheXNbbmFtZV0gPSBbXTtcbiAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgbW9ycGhBdHRyc0FycmF5c1tuYW1lXSA9IG5ldyBBcnJheShtb3JwaEF0dHIubGVuZ3RoKS5maWxsKDApLm1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGluZGljZXMgPyBpbmRpY2VzLmdldFgoaSkgOiBpO1xuICAgIGxldCBoYXNoID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgaGFzaCArPSBgJHt+fihhdHRyaWJ1dGVbZ2V0dGVyc1trXV0oaW5kZXgpICogc2hpZnRNdWx0aXBsaWVyKX0sYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICBjb25zdCBuZXdhcnJheSA9IGF0dHJBcnJheXNbbmFtZV07XG4gICAgICAgIGNvbnN0IG5ld01vcnBoQXJyYXlzID0gbW9ycGhBdHRyc0FycmF5c1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldHRlcnNba107XG4gICAgICAgICAgbmV3YXJyYXkucHVzaChhdHRyaWJ1dGVbZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgICBuZXdNb3JwaEFycmF5c1ttXS5wdXNoKG1vcnBoQXR0clttXVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFzaFRvSW5kZXhbaGFzaF0gPSBuZXh0SW5kZXg7XG4gICAgICBuZXdJbmRpY2VzLnB1c2gobmV4dEluZGV4KTtcbiAgICAgIG5leHRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IG9sZEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcihhdHRyQXJyYXlzW25hbWVdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlciwgb2xkQXR0cmlidXRlLml0ZW1TaXplLCBvbGRBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzdWx0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChuYW1lIGluIG1vcnBoQXR0cnNBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyc0FycmF5c1tuYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvbGRNb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBvbGRNb3JwaEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcihtb3JwaEF0dHJzQXJyYXlzW25hbWVdW2pdKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcjIsIG9sZE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLCBvbGRNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgcmVzdWx0Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXSA9IG1vcnBoQXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKGdlb21ldHJ5LCBkcmF3TW9kZSkge1xuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuXCIpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgfHwgZHJhd01vZGUgPT09IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSkge1xuICAgIGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpO1xuICAgICAgICBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WCgwKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcy5sZW5ndGggLyAzICE9PSBudW1iZXJPZlRyaWFuZ2xlcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgIG5ld0dlb21ldHJ5LnNldEluZGV4KG5ld0luZGljZXMpO1xuICAgIG5ld0dlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG4gICAgcmV0dXJuIG5ld0dlb21ldHJ5O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5rbm93biBkcmF3IG1vZGU6XCIsIGRyYXdNb2RlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIEJ1ZmZlckdlb21ldHJ5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEMgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEob2JqZWN0MiwgbWF0ZXJpYWwyLCBhdHRyaWJ1dGUsIG1vcnBoQXR0cmlidXRlLCBtb3JwaFRhcmdldHNSZWxhdGl2ZTIsIGEyLCBiMiwgYzIsIG1vZGlmaWVkQXR0cmlidXRlQXJyYXkpIHtcbiAgICBfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGEyKTtcbiAgICBfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGIyKTtcbiAgICBfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGMyKTtcbiAgICBjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QyLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBtYXRlcmlhbDIubW9ycGhUYXJnZXRzICYmIG1vcnBoQXR0cmlidXRlICYmIG1vcnBoSW5mbHVlbmNlc1xuICAgICkge1xuICAgICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBpbDIgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkyIDwgaWwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1tpMl07XG4gICAgICAgIGNvbnN0IG1vcnBoID0gbW9ycGhBdHRyaWJ1dGVbaTJdO1xuICAgICAgICBpZiAoaW5mbHVlbmNlID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYTIpO1xuICAgICAgICBfdGVtcEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYjIpO1xuICAgICAgICBfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYzIpO1xuICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUyKSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyksIGluZmx1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF92QS5hZGQoX21vcnBoQSk7XG4gICAgICBfdkIuYWRkKF9tb3JwaEIpO1xuICAgICAgX3ZDLmFkZChfbW9ycGhDKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdDIuaXNTa2lubmVkTWVzaCkge1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGEyLCBfdkEpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGIyLCBfdkIpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGMyLCBfdkMpO1xuICAgIH1cbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDBdID0gX3ZBLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAxXSA9IF92QS55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMl0gPSBfdkEuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDBdID0gX3ZCLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAxXSA9IF92Qi55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMl0gPSBfdkIuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDBdID0gX3ZDLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAxXSA9IF92Qy55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMl0gPSBfdkMuejtcbiAgfVxuICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgY29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gIGxldCBhLCBiLCBjO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICBjb25zdCBtb3JwaE5vcm1hbCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICBjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG4gIGxldCBpLCBqLCBpbCwgamw7XG4gIGxldCBncm91cCwgZ3JvdXBNYXRlcmlhbDtcbiAgbGV0IHN0YXJ0LCBlbmQ7XG4gIGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogcG9zaXRpb25BdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBjb25zdCBtb2RpZmllZE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gaW5kZXguZ2V0WChqKTtcbiAgICAgICAgICBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgYyA9IGluZGV4LmdldFgoaiArIDIpO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaW5kZXguZ2V0WChpKTtcbiAgICAgICAgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuICAgICAgICBjID0gaW5kZXguZ2V0WChpICsgMik7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBqO1xuICAgICAgICAgIGIgPSBqICsgMTtcbiAgICAgICAgICBjID0gaiArIDI7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpO1xuICAgICAgICBiID0gaSArIDE7XG4gICAgICAgIGMgPSBpICsgMjtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWRQb3NpdGlvbiwgMyk7XG4gIGNvbnN0IG1vcnBoZWROb3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZE5vcm1hbCwgMyk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbm9ybWFsQXR0cmlidXRlLFxuICAgIG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG4gIH07XG59XG5mdW5jdGlvbiB0b0NyZWFzZWROb3JtYWxzKGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzKSB7XG4gIGNvbnN0IGNyZWFzZURvdCA9IE1hdGguY29zKGNyZWFzZUFuZ2xlKTtcbiAgY29uc3QgaGFzaE11bHRpcGxpZXIgPSAoMSArIDFlLTEwKSAqIDEwMDtcbiAgY29uc3QgdmVydHMgPSBbbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKV07XG4gIGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIGhhc2hWZXJ0ZXgodikge1xuICAgIGNvbnN0IHggPSB+fih2LnggKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeSA9IH5+KHYueSAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB6ID0gfn4odi56ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIHJldHVybiBgJHt4fSwke3l9LCR7en1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyR2VvbWV0cnlVdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/utils/SkeletonUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SkeletonUtils: () => (/* binding */ SkeletonUtils)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nfunction retarget(target, source, options = {}) {\n  const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || { bone };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(\n            \".bones[\" + boneData.bone.name + \"].position\",\n            boneData.pos.times,\n            boneData.pos.values\n          )\n        );\n      }\n      convertedTracks.push(\n        new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(\n          \".bones[\" + boneData.bone.name + \"].quaternion\",\n          boneData.quat.times,\n          boneData.quat.values\n        )\n      );\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */ new Map();\n  const cloneLookup = /* @__PURE__ */ new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function(node) {\n    if (!node.isSkinnedMesh)\n      return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name)\n      return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = { retarget, retargetClip, clone };\n\n//# sourceMappingURL=SkeletonUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0o7QUFDbEosOENBQThDO0FBQzlDLGtCQUFrQiwwQ0FBTyxlQUFlLDZDQUFVLGdCQUFnQiwwQ0FBTyx5QkFBeUIsMENBQU8seUJBQXlCLDBDQUFPLHVCQUF1QiwwQ0FBTztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLGlEQUFjO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUd0QjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExFTk9WT1xcRG9jdW1lbnRzXFxnaXRodWJcXHppa3JpYW5iaWEuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXHRocmVlLXN0ZGxpYlxcdXRpbHNcXFNrZWxldG9uVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgUXVhdGVybmlvbiwgTWF0cml4NCwgQW5pbWF0aW9uTWl4ZXIsIFZlY3RvcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBBbmltYXRpb25DbGlwLCBTa2VsZXRvbkhlbHBlciB9IGZyb20gXCJ0aHJlZVwiO1xuZnVuY3Rpb24gcmV0YXJnZXQodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwb3MgPSBuZXcgVmVjdG9yMygpLCBxdWF0ID0gbmV3IFF1YXRlcm5pb24oKSwgc2NhbGUgPSBuZXcgVmVjdG9yMygpLCBiaW5kQm9uZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCksIHJlbGF0aXZlTWF0cml4ID0gbmV3IE1hdHJpeDQoKSwgZ2xvYmFsTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCA9IG9wdGlvbnMucHJlc2VydmVNYXRyaXggIT09IHZvaWQgMCA/IG9wdGlvbnMucHJlc2VydmVNYXRyaXggOiB0cnVlO1xuICBvcHRpb25zLnByZXNlcnZlUG9zaXRpb24gPSBvcHRpb25zLnByZXNlcnZlUG9zaXRpb24gIT09IHZvaWQgMCA/IG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiA6IHRydWU7XG4gIG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiA9IG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uIDogZmFsc2U7XG4gIG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4ID0gb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggIT09IHZvaWQgMCA/IG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4IDogZmFsc2U7XG4gIG9wdGlvbnMuaGlwID0gb3B0aW9ucy5oaXAgIT09IHZvaWQgMCA/IG9wdGlvbnMuaGlwIDogXCJoaXBcIjtcbiAgb3B0aW9ucy5uYW1lcyA9IG9wdGlvbnMubmFtZXMgfHwge307XG4gIGNvbnN0IHNvdXJjZUJvbmVzID0gc291cmNlLmlzT2JqZWN0M0QgPyBzb3VyY2Uuc2tlbGV0b24uYm9uZXMgOiBnZXRCb25lcyhzb3VyY2UpLCBib25lcyA9IHRhcmdldC5pc09iamVjdDNEID8gdGFyZ2V0LnNrZWxldG9uLmJvbmVzIDogZ2V0Qm9uZXModGFyZ2V0KTtcbiAgbGV0IGJpbmRCb25lcywgYm9uZSwgbmFtZSwgYm9uZVRvLCBib25lc1Bvc2l0aW9uO1xuICBpZiAodGFyZ2V0LmlzT2JqZWN0M0QpIHtcbiAgICB0YXJnZXQuc2tlbGV0b24ucG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnByZXNlcnZlTWF0cml4ID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbikge1xuICAgIGJvbmVzUG9zaXRpb24gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBib25lc1Bvc2l0aW9uLnB1c2goYm9uZXNbaV0ucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlTWF0cml4KSB7XG4gICAgdGFyZ2V0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgdGFyZ2V0Lm1hdHJpeFdvcmxkLmlkZW50aXR5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRhcmdldC5jaGlsZHJlbltpXS51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMub2Zmc2V0cykge1xuICAgIGJpbmRCb25lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJvbmUgPSBib25lc1tpXTtcbiAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmUubmFtZV0gfHwgYm9uZS5uYW1lO1xuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0c1tuYW1lXSkge1xuICAgICAgICBib25lLm1hdHJpeC5tdWx0aXBseShvcHRpb25zLm9mZnNldHNbbmFtZV0pO1xuICAgICAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlKTtcbiAgICAgICAgYm9uZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgfVxuICAgICAgYmluZEJvbmVzLnB1c2goYm9uZS5tYXRyaXhXb3JsZC5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgIGJvbmUgPSBib25lc1tpXTtcbiAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lLm5hbWVdIHx8IGJvbmUubmFtZTtcbiAgICBib25lVG8gPSBnZXRCb25lQnlOYW1lKG5hbWUsIHNvdXJjZUJvbmVzKTtcbiAgICBnbG9iYWxNYXRyaXguY29weShib25lLm1hdHJpeFdvcmxkKTtcbiAgICBpZiAoYm9uZVRvKSB7XG4gICAgICBib25lVG8udXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgIGlmIChvcHRpb25zLnVzZVRhcmdldE1hdHJpeCkge1xuICAgICAgICByZWxhdGl2ZU1hdHJpeC5jb3B5KGJvbmVUby5tYXRyaXhXb3JsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWxhdGl2ZU1hdHJpeC5jb3B5KHRhcmdldC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4Lm11bHRpcGx5KGJvbmVUby5tYXRyaXhXb3JsZCk7XG4gICAgICB9XG4gICAgICBzY2FsZS5zZXRGcm9tTWF0cml4U2NhbGUocmVsYXRpdmVNYXRyaXgpO1xuICAgICAgcmVsYXRpdmVNYXRyaXguc2NhbGUoc2NhbGUuc2V0KDEgLyBzY2FsZS54LCAxIC8gc2NhbGUueSwgMSAvIHNjYWxlLnopKTtcbiAgICAgIGdsb2JhbE1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxdWF0LnNldEZyb21Sb3RhdGlvbk1hdHJpeChyZWxhdGl2ZU1hdHJpeCkpO1xuICAgICAgaWYgKHRhcmdldC5pc09iamVjdDNEKSB7XG4gICAgICAgIGNvbnN0IGJvbmVJbmRleCA9IGJvbmVzLmluZGV4T2YoYm9uZSksIHdCaW5kTWF0cml4ID0gYmluZEJvbmVzID8gYmluZEJvbmVzW2JvbmVJbmRleF0gOiBiaW5kQm9uZU1hdHJpeC5jb3B5KHRhcmdldC5za2VsZXRvbi5ib25lSW52ZXJzZXNbYm9uZUluZGV4XSkuaW52ZXJ0KCk7XG4gICAgICAgIGdsb2JhbE1hdHJpeC5tdWx0aXBseSh3QmluZE1hdHJpeCk7XG4gICAgICB9XG4gICAgICBnbG9iYWxNYXRyaXguY29weVBvc2l0aW9uKHJlbGF0aXZlTWF0cml4KTtcbiAgICB9XG4gICAgaWYgKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkge1xuICAgICAgYm9uZS5tYXRyaXguY29weShib25lLnBhcmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgICBib25lLm1hdHJpeC5tdWx0aXBseShnbG9iYWxNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib25lLm1hdHJpeC5jb3B5KGdsb2JhbE1hdHJpeCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gJiYgbmFtZSA9PT0gb3B0aW9ucy5oaXApIHtcbiAgICAgIGJvbmUubWF0cml4LnNldFBvc2l0aW9uKHBvcy5zZXQoMCwgYm9uZS5wb3NpdGlvbi55LCAwKSk7XG4gICAgfVxuICAgIGJvbmUubWF0cml4LmRlY29tcG9zZShib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUpO1xuICAgIGJvbmUudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZS5uYW1lXSB8fCBib25lLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPT0gb3B0aW9ucy5oaXApIHtcbiAgICAgICAgYm9uZS5wb3NpdGlvbi5jb3B5KGJvbmVzUG9zaXRpb25baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCkge1xuICAgIHRhcmdldC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmV0YXJnZXRDbGlwKHRhcmdldCwgc291cmNlLCBjbGlwLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24gPSBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24gOiBmYWxzZTtcbiAgb3B0aW9ucy5mcHMgPSBvcHRpb25zLmZwcyAhPT0gdm9pZCAwID8gb3B0aW9ucy5mcHMgOiAzMDtcbiAgb3B0aW9ucy5uYW1lcyA9IG9wdGlvbnMubmFtZXMgfHwgW107XG4gIGlmICghc291cmNlLmlzT2JqZWN0M0QpIHtcbiAgICBzb3VyY2UgPSBnZXRIZWxwZXJGcm9tU2tlbGV0b24oc291cmNlKTtcbiAgfVxuICBjb25zdCBudW1GcmFtZXMgPSBNYXRoLnJvdW5kKGNsaXAuZHVyYXRpb24gKiAob3B0aW9ucy5mcHMgLyAxZTMpICogMWUzKSwgZGVsdGEgPSAxIC8gb3B0aW9ucy5mcHMsIGNvbnZlcnRlZFRyYWNrcyA9IFtdLCBtaXhlciA9IG5ldyBBbmltYXRpb25NaXhlcihzb3VyY2UpLCBib25lcyA9IGdldEJvbmVzKHRhcmdldC5za2VsZXRvbiksIGJvbmVEYXRhcyA9IFtdO1xuICBsZXQgcG9zaXRpb25PZmZzZXQsIGJvbmUsIGJvbmVUbywgYm9uZURhdGEsIG5hbWU7XG4gIG1peGVyLmNsaXBBY3Rpb24oY2xpcCkucGxheSgpO1xuICBtaXhlci51cGRhdGUoMCk7XG4gIHNvdXJjZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZyYW1lczsgKytpKSB7XG4gICAgY29uc3QgdGltZSA9IGkgKiBkZWx0YTtcbiAgICByZXRhcmdldCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib25lcy5sZW5ndGg7ICsraikge1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZXNbal0ubmFtZV0gfHwgYm9uZXNbal0ubmFtZTtcbiAgICAgIGJvbmVUbyA9IGdldEJvbmVCeU5hbWUobmFtZSwgc291cmNlLnNrZWxldG9uKTtcbiAgICAgIGlmIChib25lVG8pIHtcbiAgICAgICAgYm9uZSA9IGJvbmVzW2pdO1xuICAgICAgICBib25lRGF0YSA9IGJvbmVEYXRhc1tqXSA9IGJvbmVEYXRhc1tqXSB8fCB7IGJvbmUgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGlwID09PSBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFib25lRGF0YS5wb3MpIHtcbiAgICAgICAgICAgIGJvbmVEYXRhLnBvcyA9IHtcbiAgICAgICAgICAgICAgdGltZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzKSxcbiAgICAgICAgICAgICAgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KG51bUZyYW1lcyAqIDMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uT2Zmc2V0ID0gYm9uZS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9uZS5wb3NpdGlvbi5zdWIocG9zaXRpb25PZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib25lRGF0YS5wb3MudGltZXNbaV0gPSB0aW1lO1xuICAgICAgICAgIGJvbmUucG9zaXRpb24udG9BcnJheShib25lRGF0YS5wb3MudmFsdWVzLCBpICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFib25lRGF0YS5xdWF0KSB7XG4gICAgICAgICAgYm9uZURhdGEucXVhdCA9IHtcbiAgICAgICAgICAgIHRpbWVzOiBuZXcgRmxvYXQzMkFycmF5KG51bUZyYW1lcyksXG4gICAgICAgICAgICB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzICogNClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJvbmVEYXRhLnF1YXQudGltZXNbaV0gPSB0aW1lO1xuICAgICAgICBib25lLnF1YXRlcm5pb24udG9BcnJheShib25lRGF0YS5xdWF0LnZhbHVlcywgaSAqIDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaXhlci51cGRhdGUoZGVsdGEpO1xuICAgIHNvdXJjZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZURhdGFzLmxlbmd0aDsgKytpKSB7XG4gICAgYm9uZURhdGEgPSBib25lRGF0YXNbaV07XG4gICAgaWYgKGJvbmVEYXRhKSB7XG4gICAgICBpZiAoYm9uZURhdGEucG9zKSB7XG4gICAgICAgIGNvbnZlcnRlZFRyYWNrcy5wdXNoKFxuICAgICAgICAgIG5ldyBWZWN0b3JLZXlmcmFtZVRyYWNrKFxuICAgICAgICAgICAgXCIuYm9uZXNbXCIgKyBib25lRGF0YS5ib25lLm5hbWUgKyBcIl0ucG9zaXRpb25cIixcbiAgICAgICAgICAgIGJvbmVEYXRhLnBvcy50aW1lcyxcbiAgICAgICAgICAgIGJvbmVEYXRhLnBvcy52YWx1ZXNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb252ZXJ0ZWRUcmFja3MucHVzaChcbiAgICAgICAgbmV3IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKFxuICAgICAgICAgIFwiLmJvbmVzW1wiICsgYm9uZURhdGEuYm9uZS5uYW1lICsgXCJdLnF1YXRlcm5pb25cIixcbiAgICAgICAgICBib25lRGF0YS5xdWF0LnRpbWVzLFxuICAgICAgICAgIGJvbmVEYXRhLnF1YXQudmFsdWVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG1peGVyLnVuY2FjaGVBY3Rpb24oY2xpcCk7XG4gIHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcChjbGlwLm5hbWUsIC0xLCBjb252ZXJ0ZWRUcmFja3MpO1xufVxuZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gIGNvbnN0IHNvdXJjZUxvb2t1cCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNsb25lTG9va3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY2xvbmUyID0gc291cmNlLmNsb25lKCk7XG4gIHBhcmFsbGVsVHJhdmVyc2Uoc291cmNlLCBjbG9uZTIsIGZ1bmN0aW9uKHNvdXJjZU5vZGUsIGNsb25lZE5vZGUpIHtcbiAgICBzb3VyY2VMb29rdXAuc2V0KGNsb25lZE5vZGUsIHNvdXJjZU5vZGUpO1xuICAgIGNsb25lTG9va3VwLnNldChzb3VyY2VOb2RlLCBjbG9uZWROb2RlKTtcbiAgfSk7XG4gIGNsb25lMi50cmF2ZXJzZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzU2tpbm5lZE1lc2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY2xvbmVkTWVzaCA9IG5vZGU7XG4gICAgY29uc3Qgc291cmNlTWVzaCA9IHNvdXJjZUxvb2t1cC5nZXQobm9kZSk7XG4gICAgY29uc3Qgc291cmNlQm9uZXMgPSBzb3VyY2VNZXNoLnNrZWxldG9uLmJvbmVzO1xuICAgIGNsb25lZE1lc2guc2tlbGV0b24gPSBzb3VyY2VNZXNoLnNrZWxldG9uLmNsb25lKCk7XG4gICAgY2xvbmVkTWVzaC5iaW5kTWF0cml4LmNvcHkoc291cmNlTWVzaC5iaW5kTWF0cml4KTtcbiAgICBjbG9uZWRNZXNoLnNrZWxldG9uLmJvbmVzID0gc291cmNlQm9uZXMubWFwKGZ1bmN0aW9uKGJvbmUpIHtcbiAgICAgIHJldHVybiBjbG9uZUxvb2t1cC5nZXQoYm9uZSk7XG4gICAgfSk7XG4gICAgY2xvbmVkTWVzaC5iaW5kKGNsb25lZE1lc2guc2tlbGV0b24sIGNsb25lZE1lc2guYmluZE1hdHJpeCk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmUyO1xufVxuZnVuY3Rpb24gZ2V0Qm9uZUJ5TmFtZShuYW1lLCBza2VsZXRvbikge1xuICBmb3IgKGxldCBpID0gMCwgYm9uZXMgPSBnZXRCb25lcyhza2VsZXRvbik7IGkgPCBib25lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBib25lc1tpXS5uYW1lKVxuICAgICAgcmV0dXJuIGJvbmVzW2ldO1xuICB9XG59XG5mdW5jdGlvbiBnZXRCb25lcyhza2VsZXRvbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShza2VsZXRvbikgPyBza2VsZXRvbiA6IHNrZWxldG9uLmJvbmVzO1xufVxuZnVuY3Rpb24gZ2V0SGVscGVyRnJvbVNrZWxldG9uKHNrZWxldG9uKSB7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBTa2VsZXRvbkhlbHBlcihza2VsZXRvbi5ib25lc1swXSk7XG4gIHNvdXJjZS5za2VsZXRvbiA9IHNrZWxldG9uO1xuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gcGFyYWxsZWxUcmF2ZXJzZShhLCBiLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhhLCBiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFyYWxsZWxUcmF2ZXJzZShhLmNoaWxkcmVuW2ldLCBiLmNoaWxkcmVuW2ldLCBjYWxsYmFjayk7XG4gIH1cbn1cbmNvbnN0IFNrZWxldG9uVXRpbHMgPSB7IHJldGFyZ2V0LCByZXRhcmdldENsaXAsIGNsb25lIH07XG5leHBvcnQge1xuICBTa2VsZXRvblV0aWxzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2tlbGV0b25VdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\n");

/***/ })

};
;